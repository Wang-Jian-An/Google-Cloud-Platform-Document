{"title": "Google Kubernetes Engine (GKE) - Deploy WordPress on GKE with Persistent Disk and Cloud SQL", "url": "https://cloud.google.com/kubernetes-engine/docs/tutorials/persistent-disk", "abstract": "# Google Kubernetes Engine (GKE) - Deploy WordPress on GKE with Persistent Disk and Cloud SQL\nThis tutorial shows you how to set up a single-replica [WordPress](https://wordpress.com/) deployment on [Google Kubernetes Engine (GKE)](/kubernetes-engine) using a MySQL database. Instead of installing MySQL, you use [Cloud SQL](/sql) , which provides a managed version of MySQL. WordPress uses [PersistentVolumes (PV)](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) and [PersistentVolumeClaims (PVC)](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) to store data.\nA PV is a representation of storage volume in the cluster that is provisioned by an admin, or dynamically provisioned by Kubernetes, to fulfill a request made in a PVC. A PVC is a request for storage of a certain [storage class](/kubernetes-engine/docs/concepts/persistent-volumes#storageclasses) by a user that can be fulfilled by a PV. PVs and PVCs are independent from [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod/) lifecycles and preserve data through restarting, rescheduling, and even deleting Pods. WordPress uses [Persistent Disk](/persistent-disk) as storage to back the PVs.", "content": "## BackgroundWordPress is a blogging tool that uses a relational database to store the blog articles and their related objects and metadata, and the local file system to store assets, such as pictures in a blog post. This tutorial uses the official [WordPress Docker image](https://registry.hub.docker.com/_/wordpress/) from [Docker Hub](https://hub.docker.com/) .\nIn general, a container's root file system isn't suitable to store persistent data. The containers you run on GKE are typically disposable entities, and the cluster manager can delete, evict, or reschedule any containers that become unavailable due to node failures or other causes. When nodes fail, all data saved to a container's root file system is lost.\nUsing PVs backed by Persistent Disk let you store your WordPress platform data outside the containers. This way, even if the containers are deleted, their data persists. With the default storage class, your Persistent Disk (and hence your data) doesn't move with your Pod if the Pod is rescheduled to another node. There are different ways to handle moving the data, but that's outside the scope of this tutorial. For more information, see [Persistent volumes with Persistent Disk](/kubernetes-engine/docs/concepts/persistent-volumes#using_preexisting_persistent_disks_as_persistentvolumes) .\nWordPress requires a PV to store data. For this tutorial, you use the default storage class to dynamically create a Persistent Disk and create a PVC for the deployment.## Objectives\n- Create a GKE cluster.\n- Create a PV and a PVC backed by Persistent Disk.\n- Create a Cloud SQL for MySQL instance.\n- Deploy WordPress.\n- Set up your WordPress blog.\n## CostsIn this document, you use the following billable components of Google Cloud:- [GKE](/kubernetes-engine/pricing) \n- [Cloud SQL](/sql/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .## Before you begin- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) At the bottom of the Google Cloud console, a [Cloud Shell](/shell/docs/how-cloud-shell-works) session starts and displays a command-line prompt. Cloud Shell is a shell environment  with the Google Cloud CLI  already installed and with values already set for  your current project. It can take a few seconds for the session to initialize.\n- In Cloud Shell, enable the GKE and  Cloud SQL Admin APIs:```\ngcloud services enable container.googleapis.com sqladmin.googleapis.com\n```\n## Setting up your environment\n- In Cloud Shell, set the default region for the Google Cloud CLI:```\ngcloud config set compute/region region\n```Replace the following:- ``: Choose a region that's closest to you. For more information, see [Regions and Zones](/compute/docs/regions-zones) .\n- Set the `PROJECT_ID` environment variable to your [Google Cloud project ID](/resource-manager/docs/creating-managing-projects#identifying_projects) ( ).```\nexport PROJECT_ID=project-id\n```\n- Download the app manifest files from [the GitHub repository](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/tree/main/quickstarts/wordpress-persistent-disks) :```\ngit clone https://github.com/GoogleCloudPlatform/kubernetes-engine-samples\n```\n- Change to the directory with the `wordpress-persistent-disks` file:```\ncd kubernetes-engine-samples/quickstarts/wordpress-persistent-disks\n```\n- Set the `WORKING_DIR` environment variable:```\nWORKING_DIR=$(pwd)\n```For this tutorial, you create Kubernetes objects using manifest files in YAML format.\n## Creating a GKE clusterYou create a GKE [cluster](/kubernetes-engine/docs/clusters) to host your WordPress app container.- In Cloud Shell, create an GKE cluster named `persistent-disk-tutorial` :```\nCLUSTER_NAME=persistent-disk-tutorialgcloud container clusters create-auto $CLUSTER_NAME\n```Once created, connect to your new cluster:```\ngcloud container clusters get-credentials $CLUSTER_NAME --region REGION\n```\n## Creating a PV and a PVC backed by Persistent DiskCreate a PVC as the storage required for WordPress. GKE has a default `StorageClass` resource installed that lets you [dynamically provision](/kubernetes-engine/docs/concepts/persistent-volumes#dynamic_provisioning) PVs backed by Persistent Disk. You use the `wordpress-volumeclaim.yaml` file to create the PVCs required for the deployment.\nThis manifest file describes a PVC that requests 200\u00a0GB of storage. A `StorageClass` resource hasn't been defined in the file, so this PVC uses the default `StorageClass` resource to provision a PV backed by Persistent Disk.- In Cloud Shell, deploy the manifest file:```\nkubectl apply -f $WORKING_DIR/wordpress-volumeclaim.yaml\n```It can take up to ten seconds to provision the PV backed by Persistent Disk and to bind it to your PVC. You can check the status with the following command:```\nkubectl get persistentvolumeclaim\n```The output shows a PersistentVolumeClaim with a status of `Pending` , similar to the following:```\nNAME     STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE\nwordpress-volumeclaim Pending          standard-rwo 5s\n```This PersistentVolumeClaim remains in the `Pending` state until you use it later in this tutorial.\n## Creating a Cloud SQL for MySQL instance\n- In Cloud Shell, create an instance named `mysql-wordpress-instance` :```\nINSTANCE_NAME=mysql-wordpress-instancegcloud sql instances create $INSTANCE_NAME\n```\n- Add the instance connection name as an environment variable:```\nexport INSTANCE_CONNECTION_NAME=$(gcloud sql instances describe $INSTANCE_NAME \\\u00a0 \u00a0 --format='value(connectionName)')\n```\n- Create a database for WordPress to store its data:```\ngcloud sql databases create wordpress --instance $INSTANCE_NAME\n```\n- Create a database user called `wordpress` and a password for WordPress to authenticate to the instance:```\nCLOUD_SQL_PASSWORD=$(openssl rand -base64 18)gcloud sql users create wordpress --host=% --instance $INSTANCE_NAME \\\u00a0 \u00a0 --password $CLOUD_SQL_PASSWORD\n```If you close your Cloud Shell session, you lose the password. Make a note of the password because you need it later in the tutorial.\nYou have completed setting up the database for your new WordPress blog.## Deploying WordPressBefore you can deploy WordPress, you must create a service account. You create a Kubernetes secret to hold the service account credentials and another secret to hold the database credentials.\n### Configure a service account and create secrets\n- To let your WordPress app access the MySQL instance through a Cloud SQL proxy, create a service account:```\nSA_NAME=cloudsql-proxygcloud iam service-accounts create $SA_NAME --display-name $SA_NAME\n```\n- Add the service account email address as an environment variable:```\nSA_EMAIL=$(gcloud iam service-accounts list \\\u00a0 \u00a0 --filter=displayName:$SA_NAME \\\u00a0 \u00a0 --format='value(email)')\n```\n- Add the `cloudsql.client` role to your service account:```\ngcloud projects add-iam-policy-binding $PROJECT_ID \\\u00a0 \u00a0 --role roles/cloudsql.client \\\u00a0 \u00a0 --member serviceAccount:$SA_EMAIL\n```\n- Create a key for the service account:```\ngcloud iam service-accounts keys create $WORKING_DIR/key.json \\\u00a0 \u00a0 --iam-account $SA_EMAIL\n```This command downloads a copy of the `key.json` file.\n- Create a [Kubernetes secret](https://kubernetes.io/docs/concepts/configuration/secret/) for the MySQL credentials:```\nkubectl create secret generic cloudsql-db-credentials \\\u00a0 \u00a0 --from-literal username=wordpress \\\u00a0 \u00a0 --from-literal password=$CLOUD_SQL_PASSWORD\n```\n- Create a Kubernetes secret for the service account credentials:```\nkubectl create secret generic cloudsql-instance-credentials \\\u00a0 \u00a0 --from-file $WORKING_DIR/key.json\n```\n### Deploy WordPressThe next step is to deploy your WordPress container in the GKE cluster.\nThe `wordpress_cloudsql.yaml` manifest file describes a Deployment that creates a single Pod running a container with a WordPress instance. This container reads the `WORDPRESS_DB_PASSWORD` environment variable that contains the `cloudsql-db-credentials` secret you created.\nThis manifest file also configures the WordPress container to communicate with MySQL through the [Cloud SQL proxy running in the sidecar container](/sql/docs/mysql/connect-kubernetes-engine) .  The host address value is set on the `WORDPRESS_DB_HOST` environment  variable.- Prepare the file by replacing the `INSTANCE_CONNECTION_NAME` environment variable:```\ncat $WORKING_DIR/wordpress_cloudsql.yaml.template | envsubst > \\\u00a0 \u00a0 $WORKING_DIR/wordpress_cloudsql.yaml\n```\n- Deploy the `wordpress_cloudsql.yaml` manifest file:```\nkubectl create -f $WORKING_DIR/wordpress_cloudsql.yaml\n```It takes a few minutes to deploy this manifest file while a Persistent Disk is attached to the compute node.\n- Watch the deployment to see the status change to `running` :```\nkubectl get pod -l app=wordpress --watch\n```When the output shows a status of `Running` , you can move on to the next step.```\nNAME      READY  STATUS RESTARTS AGE\nwordpress-387015-02xxb 2/2  Running 0   2m47s\n```\n### Expose the WordPress serviceIn the previous step, you deployed a WordPress container, but it's currently not accessible from outside your cluster because it doesn't have an external IP address. You can expose your WordPress app to traffic from the internet by creating and configuring a Kubernetes Service [with an attached external load balancer](/kubernetes-engine/docs/concepts/network-overview) . To learn more about exposing apps using Services in GKE, see [the how-to guide](/kubernetes-engine/docs/how-to/exposing-apps) .- Create a [Service](https://kubernetes.io/docs/concepts/services-networking/service/) of `type:LoadBalancer` :```\nkubectl create -f $WORKING_DIR/wordpress-service.yaml\n```It takes a few minutes to create a load balancer.\n- Watch the deployment and wait for the service to have an external IP address assigned:```\nkubectl get svc -l app=wordpress --watch\n```\n- When the output shows an external IP address, you can proceed to the next step. Note that your external IP is different from the following example.```\nNAME  CLUSTER-IP  EXTERNAL-IP PORT(S)  AGE\nwordpress 10.51.243.233 203.0.113.3 80:32418/TCP 1m\n```\n- Make a note of the `EXTERNAL_IP` address field to use later.\n **Warning:** Don't leave your WordPress installation with a load balancer that exposes the cluster on the installation page. Other visitors can set up a website on your cluster and use it to serve potentially malicious content. Either continue setting up your WordPress blog or [clean up](#cleaning-up) this deployment.## Setting up your WordPress blogIn this section, you set up your WordPress blog.- In your browser, go to the following URL, replacing with the `EXTERNAL_IP` address of the service that exposes your WordPress instance:```\nhttp://external-ip-address\n```\n- On the **WordPress installation** page, select a language, and then click **Continue** .\n- Complete the **Information needed** page, and then click **Install WordPress** .\n- Click **Log In** .\n- Enter the username and password that you previously created.\n- You now have a blog site. To visit your blog, in your browser, go to the following URL:```\nhttp://external-ip-address\n```\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete the individual resourcesIf you used an existing project and you don't want to delete it, delete the individual resources.- Delete the service:```\nkubectl delete service wordpress\n```Wait for the load balancer provisioned for the `wordpress` Service to be deleted. The load balancer is deleted asynchronously in the background.Watch the deletion process:```\nwatch gcloud compute forwarding-rules list\n```The load balancer is deleted when you see the following output:```\nListed 0 items.\n```\n- Delete the Deployment:```\nkubectl delete deployment wordpress\n```\n- Delete the PVC for WordPress:```\nkubectl delete pvc wordpress-volumeclaim\n```This command also automatically deletes the PV and Persistent Disk.\n- Delete the GKE cluster:```\ngcloud container clusters delete $CLUSTER_NAME\n```\n- Delete the Cloud SQL instance:```\ngcloud sql instances delete $INSTANCE_NAME\n```\n- Remove the role from the service account:```\ngcloud projects remove-iam-policy-binding $PROJECT_ID \\\u00a0 \u00a0 --role roles/cloudsql.client \\\u00a0 \u00a0 --member serviceAccount:$SA_EMAIL\n```\n- Delete the service account:```\ngcloud iam service-accounts delete $SA_EMAIL\n```\n## What's next\n- Configure a [static IP and a domain name](/kubernetes-engine/docs/tutorials/configuring-domain-name-static-ip) for your app.\n- [Set up an external Application Load Balancer with Ingress](/kubernetes-engine/docs/tutorials/http-balancer) .\n- Explore other [Kubernetes Engine tutorials](/kubernetes-engine/docs/tutorials) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Google Kubernetes Engine (GKE)"}