{"title": "Google Kubernetes Engine (GKE) - About container image digests", "url": "https://cloud.google.com/kubernetes-engine/docs/concepts/about-container-images", "abstract": "# Google Kubernetes Engine (GKE) - About container image digests\nThis document describes image digests, including what image digests are, how to find them, and how to enforce their use in Kubernetes clusters. This document is intended for developers and operators who build and deploy container images.\nA [container image digest](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests) uniquely and immutably identifies a container image. When you deploy images by digest, you avoid the downsides of deploying by [image tags](https://github.com/opencontainers/distribution-spec/blob/main/spec.md) .\nThe commands in this document assume that you have access to a Linux or macOS shell environment with tools such as the [Google Cloud CLI](/sdk) , Docker, cURL, [jq](https://jqlang.github.io/jq/) , and [pack](https://buildpacks.io/docs/tools/pack/) already installed. Or, you can use [Cloud Shell](/shell) , which has these tools pre-installed.\n", "content": "## Container images and image tags\nWhen working with container images, you need a way to refer to the images that you use. [Image tags](https://github.com/opencontainers/distribution-spec/blob/main/spec.md) are a common way of referring to different revisions of an image. A common approach is to tag images with a version identifier at build time. For example, `v1.0.1` could refer to a version that you call `1.0.1` .\nTags make image revisions easy to look up by human-readable strings. However, tags are mutable references, which means the image referenced by a tag can change, as illustrated in the following diagram:\nAs the previous diagram shows, if you publish a new image using the same tag as an existing image, the tag stops pointing to the existing image and starts pointing to your new image.\n### Disadvantages of image tags\nBecause tags are mutable, they have the following disadvantages when you use them to deploy an image:\n- In Kubernetes, deploying by tag can result in unexpected results. For example, assume that you have an existing Deployment resource that references a container image by tag `v1.0.1` . To fix a bug or make a small change, your build process creates a new image with the same tag `v1.0.1` . New Pods that are created from your Deployment resource can end up using either the old or the new image, even if you don't change your Deployment resource specification. This problem also applies to other Kubernetes resources such as StatefulSets, DaemonSets, ReplicaSets, and Jobs.\n- If you use tools to scan or analyze images, results from these tools are only valid for the image that was scanned. To ensure that you deploy the image that was scanned, you cannot rely on the tag because the image referred by the tag might have changed.\n- If you use [Binary Authorization](/binary-authorization/docs) with [Google Kubernetes Engine (GKE)](/kubernetes-engine/docs) , tag-based deployment is disallowed because it's impossible to determine the exact image that is used when a Pod is created.\nWhen you deploy your images, you can use an image digest to avoid the disadvantages of using tags. You can still add tags to your images if you like, but you don't have to do so.\n## Structure of an image\nAn image consists of the following components:\n- An [image manifest](https://github.com/opencontainers/image-spec/blob/main/manifest.md#oci-image-manifest-specification) \n- A [configuration object](https://github.com/opencontainers/image-spec/blob/main/manifest.md#image-manifest-property-descriptions) \n- An array of one or more [file system layers](https://github.com/opencontainers/image-spec/blob/main/layer.md#image-layer-filesystem-changeset) \n- An optional [image index](https://github.com/opencontainers/image-spec/blob/main/image-index.md#oci-image-index-specification) \nThese components are illustrated in the following diagram:\nThe preceding image shows additional detail about image components:\n- The image manifest is a JSON document that contains a reference to the configuration object, the file system layers, and optional metadata.\n- The image manifest references the configuration object and each of the file system layers using their`digest`attributes. The value of a`digest`attribute is a cryptographic hash of the contents that the digest refers to, typically calculated using the [SHA-256](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#sha-256) algorithm.\n- The digest values are used to construct immutable addresses to the objects. This process is called [content-addressable storage](https://wikipedia.org/wiki/Content-addressable_storage) , and it means that you can retrieve image manifests, image indexes, configuration objects, and layers based on their digests.\n- The image digest is the hash of the image index or image manifest JSON document.\n- The configuration object is a JSON document that defines [properties of the image](https://github.com/opencontainers/image-spec/blob/main/config.md#properties) , such as the CPU architecture, entrypoint, exposed ports, and environment variables.\n- The file system layer array defines the order that the container runtime uses to stack the layers. The layers are distributed as [tar files](https://wikipedia.org/wiki/Tar_(computing)) , typically compressed using the [gzip](https://www.gzip.org/) utility.\n- The optional image index, sometimes referred to as the [manifest list](https://docs.docker.com/registry/spec/manifest-v2-2/#manifest-list) , refers to one or more image manifests. The reference is the digest of the image manifest. An image index is useful when you produce multiple related images for different [platforms](https://github.com/opencontainers/image-spec/blob/main/image-index.md#image-index-property-descriptions) , such as`amd64`and`arm64`architectures.\nFor more information, see the section [Exploring image manifests, digests, and tags](#exploring_image_manifests_digests_and_tags) .\n## Finding image digests\nTo use image digests for deployment, you must first find the digest. Then, you can use the digest with your deployment command or include it in your Kubernetes manifests.\nYou can get the digest of an image in various ways, depending on your current situation. The following sections contain examples for different products and tools.\nIn the following sections, run the commands in Cloud Shell or in a shell environment with tools such as the gcloud CLI, Docker, cURL, and `jq` already installed.\n### Artifact Registry\n- For images stored in [Artifact Registry](/artifact-registry/docs) , you can use the [gcloud artifacts docker images describe command](/sdk/gcloud/reference/artifacts/docker/images/describe) .```\ngcloud artifacts docker images describe \\\n LOCATION-docker.pkg.dev/PROJECT/REPOSITORY/IMAGE:TAG \\\n --format 'value(image_summary.digest)'\n```Replace the following:- ``: the regional or multi-regional [location](/artifact-registry/docs/repositories/repo-locations) of your repository\n- ``: your [Google Cloud project ID](/resource-manager/docs/creating-managing-projects#identifying_projects) \n- ``: your repository name\n- ``: your image name\n- ``: your image tag\n### Container Registry\n**Note:** Container Registry is deprecated and scheduled for shutdown. Organizations that haven't used Container Registry prior to January 8, 2024 have new gcr.io repositories hosted on Artifact Registry by default. After May 15, 2024, Google Cloud projects without previous usage of Container Registry will only support hosting and managing images for the `gcr.io` domain in [Artifact Registry](/artifact-registry/docs) .Container Registry is scheduled for shutdown on March 18, 2025. For details on the deprecation, see [Container Registry deprecation](/container-registry/docs/deprecations/container-registry-deprecation) .\n- For images stored in [Container Registry](/container-registry/docs) , you can use the [gcloud container images describe command](/sdk/gcloud/reference/container/images/describe) to get the digest for an image by providing the name and a tag. Use the [--format flag](/sdk/gcloud/reference/topic/formats) to only display the digest:```\ngcloud container images describe \\\u00a0 \u00a0 gcr.io/google-containers/pause-amd64:3.2 \\\u00a0 \u00a0 --format 'value(image_summary.digest)'\n```The output looks similar to the following, though your digest value might differ:```\nsha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108\n```\n### Cloud Build\nFor images built using [Cloud Build](/build/docs) , you can get the image digest by using the [gcloud builds describe command](/sdk/gcloud/reference/builds/describe) with the `--format` flag. This approach works regardless of which registry you used to publish your image.\n- For an already completed build, do the following:- Get a list of builds for your project:```\ngcloud builds list\n```Make a note of a `` .\n- Get the image digest:```\ngcloud builds describe BUILD_ID \\\n --format 'value(results.images[0].digest)'\n```Replace `` with the unique ID that Cloud Build assigned to your build.\n- Get the image name and digest for the latest build from Cloud Build for your current project:```\ngcloud builds describe \\\u00a0 \u00a0 $(gcloud builds list --limit 1 --format 'value(id)') \\\u00a0 \u00a0 --format 'value[separator=\"@\"](results.images[0].name,results.images[0].digest)'\n```\n- If your build produced multiple images, filter the output and get the digest of one of the images:```\ngcloud builds describe BUILD_ID --format json \\\n | jq -r '.results.images[] | select(.name==\"YOUR_IMAGE_NAME\") | .digest'\n```Replace `` with the name of one of the images from your [cloudbuild.yaml file](/build/docs/build-config#images) .\n- If you submit a build to Cloud Build using the [gcloud builds submit command](/sdk/gcloud/reference/builds/submit) , you can capture the image digest from the output in an environment variable:```\nIMAGE_DIGEST=$(gcloud builds submit \\\u00a0 \u00a0 --format 'value(results.images[0].digest)' | tail -n1)\n```\n### Cloud Native Buildpacks\n- If you use [Cloud Native Buildpacks](/blog/products/containers-kubernetes/google-cloud-now-supports-buildpacks) and the Google Cloud builder to build and publish images, you can capture the image name and digest by using the `--quiet` flag with the `pack` command:```\npack build --builder gcr.io/buildpacks/builder:v1 --publish --quiet \\\n LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY/IMAGE \\\n > image-with-digest.txt\n```Replace the following:- ``: the regional or multi-regional [location](/artifact-registry/docs/repositories/repo-locations) of your repository\n- ``: your [Google Cloud project ID](/resource-manager/docs/creating-managing-projects#identifying_projects) \n- ``: your repository name\n- ``: your image name\nThe file `image-with-digest.txt` contains the image name and digest.Use the `--tag` flag if you want to add tags to the image.\n### Docker client\n- The [manifest subcommand](https://docs.docker.com/engine/reference/commandline/manifest/) of the `docker` command line client can fetch image manifests and manifest lists from container image registries.Get the digest from the manifest list of the image `registry.k8s.io/pause:3.9` , for the `amd64` CPU architecture and the `linux` operating system:```\ndocker manifest inspect --verbose registry.k8s.io/pause:3.9 | \\\u00a0 \u00a0 jq -r 'if type==\"object\"\u00a0 \u00a0 \u00a0 \u00a0 then .Descriptor.digest\u00a0 \u00a0 \u00a0 \u00a0 else .[] | select(.Descriptor.platform.architecture==\"amd64\" and\u00a0 \u00a0 \u00a0 \u00a0 .Descriptor.platform.os==\"linux\") | .Descriptor.digest\u00a0 \u00a0 \u00a0 \u00a0 end'\n```The output looks similar to the following:```\nsha256:8d4106c88ec0bd28001e34c975d65175d994072d65341f62a8ab0754b0fafe10\n```\n- For images that are stored in your local [Docker daemon](https://docs.docker.com/config/daemon/) , and that have been either pulled from or pushed to an image registry, you can use the Docker command line tool to get the image digest:- Pull the image to your local [Docker daemon](https://docs.docker.com/config/daemon/) :```\ndocker pull docker.io/library/debian:bookworm\n```\n- Get the image digest:```\ndocker inspect docker.io/library/debian:bookworm \\\u00a0 \u00a0 | jq -r '.[0].RepoDigests[0]' \\\u00a0 \u00a0 | cut -d'@' -f2\n```The output looks similar to the following, though your digest value may differ:```\nsha256:3d868b5eb908155f3784317b3dda2941df87bbbbaa4608f84881de66d9bb297b\n```\n- List all images and digests in your local Docker daemon:```\ndocker images --digests\n```The output shows digests for images that have a digest value. Images only have a digest value if they were pulled from or pushed to an image registry.\n### crane and gcrane\nYou can use the open source [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) and [gcrane](https://github.com/google/go-containerregistry/blob/main/cmd/gcrane/README.md) command-line tools to get the digest of an image without pulling the image to a local Docker daemon.\n- Download `crane` and `gcrane` to your current directory:```\nVERSION=$(curl -sL https://api.github.com/repos/google/go-containerregistry/releases/latest | jq -r .tag_name)curl -L \"https://github.com/google/go-containerregistry/releases/download/${VERSION}/go-containerregistry_$(uname -s)_$(uname -m).tar.gz\" | tar -zxf - crane gcrane\n```\n- Get image digests:```\n./gcrane digest gcr.io/distroless/static-debian11:nonroot\n````crane` and `gcrane` have other features that are outside the scope of this document. For more information, see the documentation for [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md#crane) and [gcrane](https://github.com/google/go-containerregistry/blob/main/cmd/gcrane/README.md#gcrane) .## Enforcing the use of image digests in Kubernetes deployments\nIf you want to enforce using digests for images that you deploy to your Kubernetes clusters, you can use [Policy Controller](/anthos-config-management/docs/concepts/policy-controller) or [Open Policy Agent (OPA) Gatekeeper](https://open-policy-agent.github.io/gatekeeper/website/) . Policy Controller is built from the OPA Gatekeeper open source project.\nPolicy Controller and OPA Gatekeeper both build on the [OPA policy engine](https://www.openpolicyagent.org/) . Policy Controller and OPA Gatekeeper provide a [Kubernetes validating admission webhook](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/) to enforce policies, and [custom resource definitions (CRDs)](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) for [constraint templates](https://github.com/open-policy-agent/frameworks/tree/master/constraint#what-is-a-constraint-template) and [constraints](https://github.com/open-policy-agent/frameworks/tree/master/constraint#what-is-a-constraint) .\nConstraint templates contain policy logic that is expressed using a high-level declarative language called [Rego](https://www.openpolicyagent.org/docs/latest/#rego) . The following is a constraint template that validates that containers, [init containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) , and [ephemeral containers](https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/) in a Kubernetes resource specification use images with digests:\n[  library/general/imagedigests/template.yaml ](https://github.com/open-policy-agent/gatekeeper-library/blob/HEAD/library/general/imagedigests/template.yaml) [View on GitHub](https://github.com/open-policy-agent/gatekeeper-library/blob/HEAD/library/general/imagedigests/template.yaml)\n```\napiVersion: templates.gatekeeper.sh/v1kind: ConstraintTemplatemetadata:\u00a0 name: k8simagedigests\u00a0 annotations:\u00a0 \u00a0 metadata.gatekeeper.sh/title: \"Image Digests\"\u00a0 \u00a0 metadata.gatekeeper.sh/version: 1.0.1\u00a0 \u00a0 description: >-\u00a0 \u00a0 \u00a0 Requires container images to contain a digest.\u00a0 \u00a0 \u00a0 https://kubernetes.io/docs/concepts/containers/images/spec:\u00a0 crd:\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 names:\u00a0 \u00a0 \u00a0 \u00a0 kind: K8sImageDigests\u00a0 \u00a0 \u00a0 validation:\u00a0 \u00a0 \u00a0 \u00a0 openAPIV3Schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: object\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: >-\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Requires container images to contain a digest.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 https://kubernetes.io/docs/concepts/containers/images/\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 properties:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 exemptImages:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: >-\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Any container that uses an image that matches an entry in this list will be excluded\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 from enforcement. Prefix-matching can be signified with `*`. For example: `my-image-*`.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 It is recommended that users use the fully-qualified Docker image name (e.g. start with a domain name)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 in order to avoid unexpectedly exempting images from an untrusted repository.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: array\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 items:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\u00a0 targets:\u00a0 \u00a0 - target: admission.k8s.gatekeeper.sh\u00a0 \u00a0 \u00a0 rego: |\u00a0 \u00a0 \u00a0 \u00a0 package k8simagedigests\u00a0 \u00a0 \u00a0 \u00a0 import data.lib.exempt_container.is_exempt\u00a0 \u00a0 \u00a0 \u00a0 violation[{\"msg\": msg}] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 container := input.review.object.spec.containers[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not is_exempt(container)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not regex.match(\"@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+\", container.image)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 msg := sprintf(\"container <%v> uses an image without a digest <%v>\", [container.name, container.image])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 violation[{\"msg\": msg}] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 container := input.review.object.spec.initContainers[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not is_exempt(container)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not regex.match(\"@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+\", container.image)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 msg := sprintf(\"initContainer <%v> uses an image without a digest <%v>\", [container.name, container.image])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 violation[{\"msg\": msg}] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 container := input.review.object.spec.ephemeralContainers[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not is_exempt(container)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not regex.match(\"@[a-z0-9]+([+._-][a-z0-9]+)*:[a-zA-Z0-9=_-]+\", container.image)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 msg := sprintf(\"ephemeralContainer <%v> uses an image without a digest <%v>\", [container.name, container.image])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 libs:\u00a0 \u00a0 \u00a0 \u00a0 - |\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 package lib.exempt_container\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 is_exempt(container) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 exempt_images := object.get(object.get(input, \"parameters\", {}), \"exemptImages\", [])\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 img := container.image\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 exemption := exempt_images[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _matches_exemption(img, exemption)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _matches_exemption(img, exemption) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 not endswith(exemption, \"*\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 exemption == img\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _matches_exemption(img, exemption) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 endswith(exemption, \"*\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 prefix := trim_suffix(exemption, \"*\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 startswith(img, prefix)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n```\nThe preceding policy contains a regular expression as input to the [re_match function](https://www.openpolicyagent.org/docs/v0.22.0/policy-reference/#regex) . This regular expression matches the container image digest, and it is based on the [digest format in the Open Container Initiative Image Specification](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests) .\nConstraints apply the policy to Kubernetes resources by matching against attributes such as `kind` and `namespace` . The following example constraint applies the policy from the constraint template to all `Pod` resources in the `default` namespace.\n[  library/general/imagedigests/samples/container-image-must-have-digest/constraint.yaml ](https://github.com/open-policy-agent/gatekeeper-library/blob/HEAD/library/general/imagedigests/samples/container-image-must-have-digest/constraint.yaml) [View on GitHub](https://github.com/open-policy-agent/gatekeeper-library/blob/HEAD/library/general/imagedigests/samples/container-image-must-have-digest/constraint.yaml)\n```\napiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sImageDigestsmetadata:\u00a0 name: container-image-must-have-digestspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaces:\u00a0 \u00a0 \u00a0 - \"default\"\n```\nAfter you create the constraint template and the constraint, any new pods in the `default` namespace must use image digests to reference container images.\nFor the full example, see the [imagedigests policy](https://github.com/open-policy-agent/gatekeeper-library/tree/master/library/general/imagedigests) in the Gatekeeper policy library.\n## About image manifests, digests, and tags\nIn this section, you learn how to explore existing images in registries using command-line tools such as `curl` and `docker` . Run the commands in Cloud Shell or in a shell environment with tools such as the gcloud CLI, Docker, cURL, and `jq` already installed. The following commands use public images in [Artifact Registry](/artifact-registry/docs) .\n- Get the manifest of the image `gcr.io/google-containers/pause-amd64:3.2` by using cURL and the [manifest URL](https://github.com/opencontainers/distribution-spec/blob/main/spec.md) :```\ncurl -s https://gcr.io/v2/google-containers/pause-amd64/manifests/3.2\n```The output is similar to the following:```\n{\n \"schemaVersion\": 2,\n \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n \"config\": {\n  \"mediaType\": \"application/vnd.docker.container.image.v1+json\",\n  \"size\": 759,\n  \"digest\": \"sha256:80d28bedfe5dec59da9ebf8e6260224ac9008ab5c11dbbe16ee3ba3e4439ac2c\"\n },\n \"layers\": [  {\n   \"mediaType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\",\n   \"size\": 296534,\n   \"digest\": \"sha256:c74f8866df097496217c9f15efe8f8d3db05d19d678a02d01cc7eaed520bb136\"\n  }\n ]\n}\n```The `config` section has a digest attribute, and you can use this value to retrieve the configuration object. Similarly, each layer has a `digest` attribute that you can use to retrieve the tar file for that layer.\n- If the image includes the optional image index, an HTTP `GET` request to the manifest URL using a tag returns the image index instead of the image manifest.Get the image index of the image `gcr.io/google-containers/pause:3.2` :```\ncurl -s https://gcr.io/v2/google-containers/pause/manifests/3.2\n```The output is similar to the following:```\n{\n \"schemaVersion\": 2,\n \"mediaType\": \"application/vnd.docker.distribution.manifest.list.v2+json\",\n \"manifests\": [  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 526,\n   \"digest\": \"sha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108\",\n   \"platform\": {\n   \"architecture\": \"amd64\",\n   \"os\": \"linux\"\n   }\n  },\n  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 526,\n   \"digest\": \"sha256:bbb7780ca6592cfc98e601f2a5e94bbf748a232f9116518643905aa30fc01642\",\n   \"platform\": {\n   \"architecture\": \"arm\",\n   \"os\": \"linux\",\n   \"variant\": \"v7\"\n   }\n  },\n  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 526,\n   \"digest\": \"sha256:31d3efd12022ffeffb3146bc10ae8beb890c80ed2f07363515580add7ed47636\",\n   \"platform\": {\n   \"architecture\": \"arm64\",\n   \"os\": \"linux\"\n   }\n  },\n  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 526,\n   \"digest\": \"sha256:7f82fecd72730a6aeb70713476fb6f7545ed1bbf32cadd7414a77d25e235aaca\",\n   \"platform\": {\n   \"architecture\": \"ppc64le\",\n   \"os\": \"linux\"\n   }\n  },\n  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 526,\n   \"digest\": \"sha256:1175fd4d728641115e2802be80abab108b8d9306442ce35425a4e8707ca60521\",\n   \"platform\": {\n   \"architecture\": \"s390x\",\n   \"os\": \"linux\"\n   }\n  }\n ]\n}\n```\n- Filter the result to extract the image digest for the platform that you want. Get the digest of the image manifest for the `amd64` CPU architecture and the `linux` operating system:```\ncurl -s https://gcr.io/v2/google-containers/pause/manifests/3.2 | \\\u00a0 \u00a0 jq -r '.manifests[] | select(.platform.architecture==\"amd64\" and .platform.os==\"linux\") | .digest'\n```The filtering in this command mimics how container runtimes, such as [containerd](https://github.com/containerd/containerd/blob/main/docs/content-flow.md#image-format) , select the image that matches the target platform from the image index.The output is similar to the following:```\nsha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108\n```The [image digest](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests) is the result of applying a [collision-resistant hash](https://wikipedia.org/wiki/Collision_resistance) to the image index or image manifest, typically the [SHA-256](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#sha-256) algorithm.\n- Get the digest of the image `gcr.io/google-containers/pause-amd64:3.2` :```\ncurl -s https://gcr.io/v2/google-containers/pause-amd64/manifests/3.2 \\\u00a0 \u00a0 | shasum -a 256 \\\u00a0 \u00a0 | cut -d' ' -f1\n```The output is similar to the following:```\n4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108\n```You can reference this image using the image digest value as follows:```\ngcr.io/google-containers/pause-amd64@sha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108\n```\n- Using the [content-addressable storage](https://wikipedia.org/wiki/Content-addressable_storage) concept, get the image manifest by using the digest as a reference:```\ncurl -s https://gcr.io/v2/google-containers/pause-amd64/manifests/sha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108\n```\n- Many container image registries return the digest of manifests, image indexes, configuration objects, and file system layers in the `Docker-Content-Digest` header in response to HTTP `HEAD` requests. Get the digest of the image index of the image `gcr.io/google-containers/pause-amd64:3.2` :```\ncurl -s --head https://gcr.io/v2/google-containers/pause/manifests/3.2 \\\u00a0 \u00a0 | grep -i Docker-Content-Digest \\\u00a0 \u00a0 | cut -d' ' -f2\n```The output is similar to the following:```\nsha256:927d98197ec1141a368550822d18fa1c60bdae27b78b0c004f705f548c07814f\n```The `Docker-Content-Digest` header is [not mandated by the Open Container Initiative Distribution specifications](https://github.com/opencontainers/distribution-spec/blob/main/spec.md#checking-if-content-exists-in-the-registry) , so this approach might not work with all container image registries. You can use it with [Artifact Registry](/artifact-registry/docs) and [Container Registry](/container-registry/docs) .\n- To retrieve an image configuration object using the digest value from the image manifest, do the following:- Get the configuration digest:```\nCONFIG_DIGEST=$(curl -s https://gcr.io/v2/google-containers/pause-amd64/manifests/3.2 \\\u00a0 \u00a0 | jq -r '.config.digest')\n```\n- Use the configuration digest to retrieve the configuration object, and use `jq` to format the output to make it easier to read:```\ncurl -sL https://gcr.io/v2/google-containers/pause-amd64/blobs/$CONFIG_DIGEST \\\u00a0 \u00a0 | jq\n```The output is similar to the following:```\n{\n \"architecture\": \"amd64\",\n \"config\": {\n \"Env\": [  \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\n ],\n \"Entrypoint\": [  \"/pause\"\n ],\n \"WorkingDir\": \"/\",\n \"OnBuild\": null\n },\n \"created\": \"2020-02-14T10:51:50.60182885-08:00\",\n \"history\": [ {\n  \"created\": \"2020-02-14T10:51:50.60182885-08:00\",\n  \"created_by\": \"ARG ARCH\",\n  \"comment\": \"buildkit.dockerfile.v0\",\n  \"empty_layer\": true\n },\n {\n  \"created\": \"2020-02-14T10:51:50.60182885-08:00\",\n  \"created_by\": \"ADD bin/pause-amd64 /pause # buildkit\",\n  \"comment\": \"buildkit.dockerfile.v0\"\n },\n {\n  \"created\": \"2020-02-14T10:51:50.60182885-08:00\",\n  \"created_by\": \"ENTRYPOINT [\\\"/pause\\\"]\",\n  \"comment\": \"buildkit.dockerfile.v0\",\n  \"empty_layer\": true\n }\n ],\n \"os\": \"linux\",\n \"rootfs\": {\n \"type\": \"layers\",\n \"diff_ids\": [  \"sha256:ba0dae6243cc9fa2890df40a625721fdbea5c94ca6da897acdd814d710149770\"\n ]\n }\n}\n```\n- To retrieve file system layers using digest values from the image manifest, do the following:- Get the digest of the layer that you want to retrieve:```\nLAYER_DIGEST=$(curl -s https://gcr.io/v2/google-containers/pause-amd64/manifests/3.2 \\\u00a0 \u00a0 | jq -r '.layers[0].digest')\n```\n- Use the layer digest to retrieve the layer tar file, and list the contents:```\ncurl -sL https://gcr.io/v2/google-containers/pause-amd64/blobs/$LAYER_DIGEST \\\u00a0 \u00a0 | tar --list\n```This layer has only one file, called `pause` .\n- To look up tags associated with an image digest, do the following:- Define the digest that you want to look up:```\nIMAGE_DIGEST=$(curl -s https://gcr.io/v2/google-containers/pause-amd64/manifests/3.2 \\\u00a0 \u00a0 | shasum -a 256 \\\u00a0 \u00a0 | cut -d' ' -f1)\n```The `IMAGE_DIGEST` environment variable contains the digest of the image referenced by the tag `3.2` .\n- Use the [image tags list endpoint, /tags/list](https://github.com/opencontainers/distribution-spec/blob/main/spec.md) , to list tag information, and extract the tags for the digest value:```\ncurl -s \"https://gcr.io/v2/google-containers/pause-amd64/tags/list?n=1\" \\\u00a0 \u00a0 | jq \".manifest.\\\"sha256:$IMAGE_DIGEST\\\".tag\"\n```The output is similar to the following:```\n[ \"3.2\"\n]\n```\n- To get the manifest of an image from a Artifact Registry container image repository by using cURL, include an [access token](https://developers.google.com/identity/protocols/oauth2) in the `Authorization` request header:```\ncurl -s -H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n https://LOCATION-docker.pkg.dev/v2/PROJECT_ID/REPOSITORY/IMAGE/manifests/DIGEST\n```Replace the following:- ``: the regional or multi-regional [location](/artifact-registry/docs/repositories/repo-locations) of your repository\n- ``: your [Google Cloud project ID](/resource-manager/docs/creating-managing-projects#identifying_projects) \n- ``: your repository name\n- ``: your image name\n- ``: your image digest in the format`sha256:` ``\n## What's next\n- Learn best practices for [building containers](/architecture/best-practices-for-building-containers) .\n- Learn best practices for [operating containers](/architecture/best-practices-for-operating-containers) .\n- To learn more about images, see the Open Container Initiative [Image Format](https://github.com/opencontainers/image-spec/blob/main/spec.md#image-format-specification) and [Distribution](https://github.com/opencontainers/distribution-spec/blob/main/spec.md#distribution-specification) specifications.", "guide": "Google Kubernetes Engine (GKE)"}