{"title": "Google Kubernetes Engine (GKE) - Deploying a Windows Server application", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/deploying-windows-app", "abstract": "# Google Kubernetes Engine (GKE) - Deploying a Windows Server application\nIn this page, you learn how to deploy a stateless Windows Server application on a Google Kubernetes Engine (GKE) cluster, which can be either [public](#public_cluster) or [private](#private_cluster) . You can also learn how to [deploy a stateful Windows application](/kubernetes-engine/docs/how-to/stateful-apps) .\n", "content": "## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable   the Artifact Registry API and    the Google Kubernetes Engine API.\n- [    Enable APIs   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com,artifactregistry.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.## Deploying a Windows Server application to a cluster\nTo deploy a Windows Server application to a GKE public cluster, you'll need to perform the following tasks:\n- [Create a cluster.](#create_a_cluster) \n- [Create a Deployment manifest file.](#create_a_deployment_manifest_file) \n- [Create and expose the Deployment.](#create_and_expose_the_deployment) \n- [Verify that the Pod is running.](#verify_the_pod_is_running) \n### Create a cluster\nIf you already have a GKE cluster that uses Windows Server node pools, continue to the next step. Otherwise, [create a cluster using Windows Server node pools](/kubernetes-engine/docs/how-to/creating-a-cluster-windows) .\n### Create a Deployment manifest file\nWindows Server nodes are [tainted](/kubernetes-engine/docs/how-to/node-taints) with the following key-value pair: `node.kubernetes.io/os=windows:NoSchedule` .\nThis taint ensures that the GKE scheduler does not attempt to run Linux containers on Windows Server nodes. To schedule Windows Server containers on Windows Server nodes, your manifest file must include this node selector:\n```\nnodeSelector:\u00a0kubernetes.io/os: windows\n```\nAn admission webhook running in the cluster checks new workloads for the presence of this Windows node selector and when found, applies the following toleration to the workload which lets it run on the tainted Windows Server nodes:\n```\ntolerations:- effect: NoSchedule\u00a0 key: node.kubernetes.io/os\u00a0 operator: Equal\u00a0 value: windows\n```\nIn some cases you may need to include this toleration explicitly in your manifest file. For example, if you are deploying a DaemonSet with a [multi-arch](/kubernetes-engine/docs/how-to/creating-a-cluster-windows#building_multi-arch_images) container image to run on all Linux and Windows Server nodes in the cluster, then your manifest file will not include the Windows node selector. You must explicitly include the toleration for the Windows taint.\nThe following example Deployment file ( `iis.yaml` ) deploys Microsoft's IIS image to a single Pod:\n```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: iis\u00a0 labels:\u00a0 \u00a0 app: iisspec:\u00a0 replicas: 1\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: iis\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: iis\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 nodeSelector:\u00a0 \u00a0 \u00a0 \u00a0 kubernetes.io/os: windows\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: iis-server\u00a0 \u00a0 \u00a0 \u00a0 image: mcr.microsoft.com/windows/servercore/iis\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 80\n```\nThis file is for a cluster where all workloads use the same Windows Server node image type and version. For details on how to work with mixed node images, see the [Using mixed node images](#mixed) section.\n### Create and expose the Deployment\nCreate and expose the Deployment file you created in the preceding step as a Kubernetes Service with an external load balancer Deployment.\n- To create the Deployment resource, run the following command:```\nkubectl apply -f iis.yaml\n```\n- To expose the Deployment as an external load balancer, run the following command:```\nkubectl expose deployment iis \\\u00a0 \u00a0 --type=LoadBalancer \\\u00a0 \u00a0 --name=iis\n```\n### Verify that the Pod is running\nMake sure the Pod is functioning by validating it.\n- Check the status of the Pod using `kubectl` :```\nkubectl get pods\n```\n- Wait until the returned output shows that the Pod has `Running` as its status:```\nNAME     READY  STATUS RESTARTS AGE\niis-5c997657fb-w95dl 1/1  Running 0   28s\n```\n- Get the status of the service, and wait until the `EXTERNAL-IP` field is populated:```\nkubectl get service iis\n```You should see the following output:```\nNAME TYPE   CLUSTER-IP EXTERNAL-IP  PORT(S)  AGE\niis LoadBalancer 10.44.2.112 external-ip 80:32233/TCP 17s\n```\nNow, you can use your browser to open `http://` `` to see the IIS web page.\n## Deploying a Windows Server application to a private cluster\nThis section shows you how to deploy a Windows Server container application to a [private cluster](/kubernetes-engine/docs/concepts/private-cluster-concept) .\nWindows Server container images have several layers and the base layers are provided by Microsoft. The base layers are stored as a foreign layer instead of being embedded with the image as Linux Docker image layers are. When a Windows Server container image is pulled for the first time, the base layers must typically be downloaded from Microsoft servers. Because private cluster nodes don't have connectivity to the internet, the Windows Server base container layers cannot be pulled from Microsoft servers directly.\nTo use private clusters, you can configure the Docker daemon to allow pushing non-distributable layers to private registries. To learn more, see [Considerations for air-gapped registries](https://github.com/docker/docker.github.io/blob/master/registry/deploying.md#considerations-for-air-gapped-registries) on Docker's GitHub page.\nTo deploy your Windows Server application to a private cluster:\n- [Create a private cluster with Windows Server nodes.](#create_a_private_cluster) \n- [Build the Windows Server application Docker image.](#build_image) \n- [Deploy the application to a private cluster.](#deployment_private) \n- [Verify that the Pod is running.](#verify_the_pod_is_running_2) \n### Create a private cluster\nFollow the instructions in [Creating a cluster with Windows Server nodes](/kubernetes-engine/docs/how-to/creating-a-cluster-windows) and [Creating a private cluster](/kubernetes-engine/docs/how-to/private-clusters) to create and add a Windows node pool to a private cluster.\n### Build the Windows Server application Docker image\n- To build the Docker image, start a [Compute Engine instance](/compute/docs/instances) with the Windows Server version that you want to run your application containers on, such as Windows Server 2019 or Windows Server version 20H2. Also, ensure you have internet connectivity.\n- In the Compute Engine instance, navigate to the Docker daemon config:```\ncat C:\\ProgramData\\docker\\config\\daemon.json\n```\n- Configure the Docker `daemon.json` file to allow foreign layers to be pushed to your private registry by adding these lines:```\n{\u00a0 \"allow-nondistributable-artifacts\": [\"REGISTRY_REGION-docker.pkg.dev\"]}\n```In this example, `` `-docker.pkg.dev` refers to [Artifact Registry](/artifact-registry) , where the image will be hosted.\n- Restart the Docker daemon:```\nRestart-Service docker\n```\n- [Create a Docker repository in Artifact Registry](/artifact-registry/docs/manage-repos#create) .\n- Build and tag the Docker image for your application:```\ncd C:\\my-app\n``````\ndocker build -t REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/my-app:v2 .\n```This command instructs Docker to build the image using the Dockerfile in the current directory and tag it with a name, such as `us-central1-docker.pkg.dev/my-project/my-repository/my-app:v2` .\n- Push the application's Docker image to the Artifact Registry repository in your project. The `allow-nondistributable-artifacts` configuration set causes the Windows base layers to be pushed to your private registry.```\ndocker push REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/my-app:v2\n```\n### Create a Deployment manifest file\nThe following is a sample Deployment manifest file named `my-app.yaml` . The image in this example is the one you pushed in the previous step ( `` `-docker.pkg.dev/` `` `/` `` `/my-app:v2` ).\n```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: my-app\u00a0 labels:\u00a0 \u00a0 app: my-appspec:\u00a0 replicas: 1\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: my-app\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: my-app\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 nodeSelector:\u00a0 \u00a0 \u00a0 \u00a0 kubernetes.io/os: windows\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: my-server\u00a0 \u00a0 \u00a0 \u00a0 image: REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/my-app:v2\n```\n- Use the [get-credentials](/sdk/gcloud/reference/container/clusters/get-credentials) command to enable `kubectl` to work with the cluster you created:```\ngcloud container clusters get-credentials CLUSTER_NAME\n```Replace `` with the name of the private cluster you created.\n- Deploy the application specified in the `my-app.yaml` file to your private cluster:```\nkubectl apply -f my-app.yaml\n```\n### Verify the Pod is running\nList all Pods to ensure the application is running correctly:\n```\nkubectl get pods\n```\nYou should see the Pod with a status of `Running` like in the following output:\n```\nNAME      READY STATUS RESTARTS AGE\nmy-app-c95fc5596-c9zcb 1/1  Running 0   5m\n```\n## Using mixed node images\nYour clusters can contain node pools with multiple Windows Server types and Windows Server versions. They can also combine Windows Server and Linux workloads. The following sections provide details on how to configure your workloads to use these types of clusters.\n### Using workloads with different Windows Server node image types\nYou can add node pools using different Windows Server image types to your cluster. In a cluster with mixed Windows Server types, you need to ensure that your Windows Server containers are not scheduled onto an incompatible Windows Server node.\nIf you have one Windows Server LTSC node pool and one Windows Server SAC node pool, add the `gke-os-distribution` node label to both of your workloads.\nInclude the following nodeSelector in the manifest file for your Windows Server LTSC workloads:\n```\nnodeSelector:\u00a0 \u00a0kubernetes.io/os: windows\u00a0 \u00a0cloud.google.com/gke-os-distribution: windows_ltsc\n```\nInclude the following nodeSelector in the manifest file for your Windows Server SAC workloads.\n**Warning:** Windows Server Semi-Annual Channel (SAC) images aren't supported after August 9, 2022 because Microsoft is removing support for the SAC. For potential impact and migration instructions, refer to [Windows Server Semi-Annual Channel end of servicing](/kubernetes-engine/docs/deprecations/windows-server-sac) .\n```\nnodeSelector:\u00a0 \u00a0kubernetes.io/os: windows\u00a0 \u00a0cloud.google.com/gke-os-distribution: windows_sac\n```\nAdding this label ensures that your LTSC container images do not get scheduled onto incompatible SAC nodes and vice-versa.\n### Using workloads with different Windows Server LTSC OS versions\nWindows Server nodes support both LTSC2022 and LTSC2019 OS images. You can specify the Windows OS version to use (LTSC2022) with the following key-value pair in nodeSelector: `cloud.google.com/gke-windows-os-version=2022` .\nThis node label ensures that the GKE scheduler will choose the correct Windows Server nodes to run either LTSC2022 or LTSC2019 workloads. The Windows Server nodes both belong to image type `windows_ltsc_containerd` . The value of the node label can be `2022` or `2019` . If the node label is not specified, then both LTSC2019 or LTSC2022 nodes can be used to schedule containers. To schedule Windows Server containers only on Windows Server LTSC2022 nodes, your manifest file must include this node selector:\n```\nnodeSelector:\u00a0 \u00a0kubernetes.io/os: windows\u00a0 \u00a0cloud.google.com/gke-os-distribution: windows_ltsc\u00a0 \u00a0cloud.google.com/gke-windows-os-version: 2022\n```\n### Using workloads with different Windows Server versions\nIf you need to run Windows Server node pools with multiple different LTSC or SAC versions, we recommend building your container images as [multi-arch images](/kubernetes-engine/docs/how-to/creating-a-cluster-windows#building_multi-arch_images) that can run on all of the Windows Server versions in use in your cluster. The `gke-os-distribution` node label is not sufficient to prevent your workloads from potentially being scheduled onto incompatible nodes.\n### Using Linux and Windows Server workloads in a cluster\nAdd the following node selector to your Linux workloads to ensure they are always scheduled to Linux nodes:\n```\nnodeSelector:\u00a0 \u00a0kubernetes.io/os: linux\n```\nThis provides additional protection to avoid Linux workloads being scheduled onto Windows Server nodes in case the [NoSchedule taint](#create_a_deployment_manifest_file) is accidentally removed from the Windows Server nodes.\n**Note:** For DaemonSets that run on Linux only, this nodeSelector is .", "guide": "Google Kubernetes Engine (GKE)"}