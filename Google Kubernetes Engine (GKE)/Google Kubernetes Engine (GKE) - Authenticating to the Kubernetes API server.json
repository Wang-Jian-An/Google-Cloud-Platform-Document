{"title": "Google Kubernetes Engine (GKE) - Authenticating to the Kubernetes API server", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication", "abstract": "# Google Kubernetes Engine (GKE) - Authenticating to the Kubernetes API server\nThis page describes the supported authentication methods when connecting to the Kubernetes API server in Google Kubernetes Engine (GKE) clusters.\nFor information on authenticating Kubernetes workloads to Google Cloud APIs, refer to [workload identity federation for GKE](/kubernetes-engine/docs/how-to/workload-identity) .\n", "content": "## Overview\nThere are several [methods for authenticating](https://kubernetes.io/docs/reference/access-authn-authz/authentication/) to a Kubernetes API server. In GKE, OAuth authentication is recommended for cluster authentication and is automatically configured for you.\n## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.## Authenticating users\nGKE manages end-user authentication for you through the Google Cloud CLI. The gcloud CLI authenticates users to Google Cloud, sets up the Kubernetes configuration, gets an OAuth access token for the cluster, and keeps the access token up-to-date.\nAll GKE clusters are configured to accept Google Cloud user and service account identities, by validating the credentials presented by `kubectl` and retrieving the email address associated with the user or service account identity. As a result, the credentials for those accounts must include the `userinfo.email` OAuth scope to successfully authenticate.\nWhen you use `gcloud` to [set up your environment's kubeconfig](/kubernetes-engine/docs/how-to/cluster-access-for-kubectl#store_info) for a new or existing cluster, `gcloud` gives `kubectl` the same credentials used by `gcloud` itself. For example, if you use `gcloud auth login` , your personal credentials are provided to `kubectl` , including the `userinfo.email` scope. This allows the GKE cluster to authenticate the `kubectl` client.\nAlternatively, you may choose to configure `kubectl` to use the credentials of a Google Cloud service account, while running on a Compute Engine instance. However, by default, the `userinfo.email` scope is included in credentials created by Compute Engine instances. Therefore, you **must** add this scope explicitly, such as by using the `--scopes` flag when the Compute Engine instance is created.\nYou can authorize actions in your cluster using [Identity and Access Management (IAM) or Kubernetes Role Based Access Control (RBAC)](/kubernetes-engine/docs/concepts/access-control) .\n**Note:** Before OAuth integration with GKE, the pre-provisioned X.509 certificate or a static password were the only available authentication methods. These methods are no longer recommended and are disabled by default on all new clusters. If you use [legacy authentication methods](#legacy-auth) , we recommend that you migrate to newer authentication methods.\n### Authenticating using OAuth\nTo authenticate to your cluster using the OAuth method, perform the following:\n- Sign in to the gcloud CLI using your credentials. This opens a web browser to complete the authentication process to Google Cloud:```\ngcloud auth login\n``` **Caution:** Do not perform this on a Compute Engine VM. Use a service account for authentication. For more details, see the [Service within Google Cloud](#service_within) section.\n- Retrieve the Kubernetes credentials for a specific cluster:```\ngcloud container clusters get-credentials CLUSTER_NAME \\\u00a0 \u00a0 --zone=COMPUTE_ZONE\n```\n- Verify that you are authenticated:```\nkubectl cluster-info\n```\nOnce users or Google Cloud service accounts are authenticated, they must also be to perform any action on a GKE cluster. For more information on how to configure authorization, see [role-based access control](/kubernetes-engine/docs/how-to/role-based-access-control) .\n## Authenticating applications\nYou can also authenticate to the API server from an application in a Pod without user interaction, such as from a script in your CI/CD pipeline. How you achieve this depends on the environment where your application is running.\n### Application in the same cluster\nIf your application is running in the same GKE cluster, use a Kubernetes service account to authenticate.\n- Create a [Kubernetes service account](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) and attach it to your Pod. If your Pod already has a Kubernetes service account, or if you want to use the namespace's default service account, skip this step.\n- Use Kubernetes RBAC to grant the Kubernetes service account the permissions that your application requires.The following example grants `view` permissions to resources in the `prod` namespace to a service account named `cicd` in the `cicd-ns` namespace:```\nkubectl create rolebinding cicd-secret-viewer \\\u00a0 \u00a0 --namespace=prod \\\u00a0 \u00a0 --clusterrole=view \\\u00a0 \u00a0 --serviceaccount=cicd-ns:cicd\n```\n- At runtime, when your application sends a Kubernetes API request, the API server authenticates the service account credentials.\n### Applications within Google Cloud\nIf your application runs inside Google Cloud but outside the target cluster (for example, a Compute Engine VM or another GKE cluster), you should authenticate to the API server using the IAM service account credentials available in the environment.\n- Assign an IAM service account to your environment. If your application is running inside a Compute Engine VM, [assign an IAM service account](/compute/docs/access/service-accounts#user-managed_service_accounts) to the instance. If your application is running in a different GKE cluster, use [workload identity federation for GKE](/kubernetes-engine/docs/how-to/workload-identity) to configure your Pod to run as an IAM service account.The examples that follow use `ci-cd-pipeline@` `` `.iam.gserviceaccount.com` as the IAM service account.\n- Grant the IAM service account access to the cluster.The following example grants the `roles/container.developer` IAM role, which provides access to Kubernetes API objects inside clusters:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:ci-cd-pipeline@PROJECT_ID.iam.gserviceaccount.com \\\u00a0 \u00a0 --role=roles/container.developer\n```Alternatively, you can use RBAC to grant the IAM service account access to the cluster. Run the `kubectl create rolebinding` command from [Applications in the same cluster](#application_in_the_same_cluster) and use `--user=ci-cd-pipeline@` `` `.iam.gserviceaccount.com` instead of the `--service-account` flag.\n- Retrieve the cluster credentials:```\ngcloud container clusters get-credentials CLUSTER_NAME \\\u00a0 \u00a0 --zone=COMPUTE_ZONE\n```Your application is automatically authenticated using the IAM service account set on the environment.\n### Applications in other environments\nIf your application is authenticating from an environment outside Google Cloud, it cannot access managed IAM service account credentials. To retrieve cluster credentials, you can create an IAM service account, download its key, and use the key at runtime from your service to retrieve cluster credentials with the gcloud CLI.\n**Caution:** IAM service account keys are long-lived credentials. Anyone with access to the key can use it to perform authorized actions in your Google Cloud project. Managing keys can be difficult at scale. Consider using [workload identity federation](/iam/docs/configuring-workload-identity-federation) , which configures credentials issued by external identity providers to impersonate IAM service accounts and access Google Cloud resources.\n- Create an IAM service account for your application. If you already have an IAM service account, skip this step.The following command creates an IAM service account named `ci-cd-pipeline` :```\ngcloud iam service-accounts create ci-cd-pipeline\n```\n- Grant the IAM service account access to your cluster.The following command grants the `roles/container.developer` IAM role to the `ci-cd-pipeline@` `` `.iam.gserviceaccount.com` IAM service account:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:ci-cd-pipeline@PROJECT_ID.iam.gserviceaccount.com \\\u00a0 \u00a0 --role=roles/container.developer\n```You can also use RBAC to grant the IAM service account access to the cluster. Run the `kubectl create rolebinding` command from [Applications in the same cluster](#application_in_the_same_cluster) and use `--user=ci-cd-pipeline@` `` `.iam.gserviceaccount.com` instead of the `--service-account` flag.\n- Create and download a key for your IAM service account. Make it available to your application at runtime:```\ngcloud iam service-accounts keys create gsa-key.json \\\u00a0 \u00a0 --iam-account=ci-cd-pipeline@PROJECT_ID.iam.gserviceaccount.com\n```\n- At runtime, in the environment running your application, authenticate to the gcloud CLI by using your IAM service account key:```\ngcloud auth activate-service-account ci-cd-pipeline@PROJECT_ID.iam.gserviceaccount.com \\\u00a0 \u00a0 --key-file=gsa-key.json\n```\n- Use the gcloud CLI to retrieve the cluster credentials:```\ngcloud config set project PROJECT_IDgcloud container clusters get-credentials CLUSTER_NAME \\\u00a0 \u00a0 --zone=COMPUTE_ZONE\n```\n### Environments without gcloud\nUsing the gcloud CLI to retrieve cluster credentials is recommended because this method is resilient to cluster events like a control plane [IP rotation](/kubernetes-engine/docs/how-to/ip-rotation) or [credential rotation](/kubernetes-engine/docs/how-to/credential-rotation) . However, if you cannot install the gcloud CLI in your environment, you can still create a static kubeconfig file to authenticate to the cluster:\n- Create an IAM service account for your application. If you already have an IAM service account, skip this step.The following command creates an IAM service account named `ci-cd-pipeline` :```\ngcloud iam service-accounts create ci-cd-pipeline\n```\n- Grant the IAM service account access to your cluster.The following command grants the `roles/container.developer` IAM role to the `ci-cd-pipeline@` `` `.iam.gserviceaccount.com` IAM service account:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:ci-cd-pipeline@PROJECT_ID.iam.gserviceaccount.com \\\u00a0 \u00a0 --role=roles/container.developer\n```You can also create a [custom IAM role](/iam/docs/creating-custom-roles) for fine-grained control over the permissions that you grant.\n- Create and download a key for your IAM service account.In the following example, the key file is named `gsa-key.json` :```\ngcloud iam service-accounts keys create gsa-key.json \\\u00a0 \u00a0 --iam-account=ci-cd-pipeline@PROJECT_ID.iam.gserviceaccount.com\n```\n- Get the `endpoint` and `clusterCaCertificate` values for your cluster:```\ngcloud container clusters describe CLUSTER_NAME \\\u00a0 \u00a0 --zone=COMPUTE_ZONE \\\u00a0 \u00a0 \u00a0--format=\"value(endpoint)\"gcloud container clusters describe CLUSTER_NAME \\\u00a0 \u00a0 --zone=COMPUTE_ZONE \\\u00a0 \u00a0 --format=\"value(masterAuth.clusterCaCertificate)\"\n```\n- Create a `kubeconfig.yaml` file containing the following:```\napiVersion: v1kind: Configclusters:- name: CLUSTER_NAME\u00a0 cluster:\u00a0 \u00a0 server: https://endpoint\u00a0 \u00a0 certificate-authority-data: masterAuth.clusterCaCertificateusers:- name: ci-cd-pipeline-gsa\u00a0 user:\u00a0 \u00a0 exec:\u00a0 \u00a0 \u00a0 apiVersion: client.authentication.k8s.io/v1beta1\u00a0 \u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 - --use_application_default_credentials\u00a0 \u00a0 \u00a0 command: gke-gcloud-auth-plugin\u00a0 \u00a0 \u00a0 installHint: Install gke-gcloud-auth-plugin for kubectl by following\u00a0 \u00a0 \u00a0 \u00a0 https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-access-for-kubectl#install_plugin\u00a0 \u00a0 \u00a0 provideClusterInfo: truecontexts:- context:\u00a0 \u00a0 cluster: CLUSTER_NAME\u00a0 \u00a0 user: ci-cd-pipeline-gsa\u00a0 name: CLUSTER_NAME-ci-cdcurrent-context: CLUSTER_NAME-ci-cd\n```Replace the following:- ``: the name of your cluster.\n- ``: the value you obtained for`endpoint`from the previous step.\n- ``: the value you obtained for`clusterCaCertificate`from the previous step (you don't need to decode the base64-encoded certificate).\n- Deploy `kubeconfig.yaml` and `gsa-key.json` alongside your application in your environment. At runtime, in the environment running your application, set these environment variables:```\nexport KUBECONFIG=path/to/kubeconfig.yamlexport GOOGLE_APPLICATION_CREDENTIALS=path/to/gsa-key.json\n```\n- Your application can now send requests to the Kubernetes API and will be authenticated as the IAM service account.## Legacy authentication methods\n**Note:** For GKE Autopilot clusters, legacy authentication methods cannot be used.\n**Note:** Basic authentication is deprecated and has been removed in GKE 1.19 and later.\nBefore OAuth integration with GKE, the pre-provisioned X.509 certificate or a static password were the only available authentication methods, but are no longer recommended and should be disabled. These methods present a wider surface of attack for cluster compromise and are disabled by default on clusters running GKE version 1.12 and later. If you use legacy authentication methods, we recommend that you turn them off.\nIf enabled, a user with the `container.clusters.getCredentials` permission can retrieve the client certificate and static password. The `roles/container.admin` , `roles/owner` , and `roles/editor` roles all have this permission, so use those roles wisely. Read more about [IAM roles in GKE](/kubernetes-engine/docs/how-to/iam) .\n### Disabling authentication with a static password\nA static password is a username and password combination that the API server validates. In GKE, this authentication method is referred to as basic authentication.\n**Note:** Basic authentication is deprecated and has been removed in GKE 1.19 and later.\nTo update an existing cluster and remove the static password:\n```\ngcloud container clusters update CLUSTER_NAME --no-enable-basic-auth\n```\n### Disabling authentication with a client certificate\nWith certificate authentication, a client presents a certificate that the API server verifies with the specified certificate authority. In GKE, the [cluster root Certificate Authority (CA)](/kubernetes-engine/docs/concepts/cluster-trust) signs client certificates.\nClient certificate authentication has implications on authorization to the Kubernetes API server. If legacy [Attribute Based Access Control (ABAC)](https://kubernetes.io/docs/reference/access-authn-authz/abac/) authorization is enabled on the cluster, by default, client certificates can authenticate and perform any action on the API server. On the other hand, with Role Based Access Control (RBAC) enabled, client certificates must be granted specific authorization to Kubernetes resources.\n**Note:** In GKE 1.8 and later, legacy ABAC is disabled by default, and the client certificate is not granted permissions.\nTo create a cluster without generating a client certificate, use the `--no-issue-client-certificate` flag:\n```\ngcloud container clusters create CLUSTER_NAME \\\u00a0 \u00a0 --no-issue-client-certificate\n```\nCurrently, there is no way to remove a client certificate from an existing cluster. To stop using client certificate authentication on an existing cluster, ensure you have RBAC enabled on the cluster, and that the client certificate does not have any authorization on the cluster.\n**Note:** The `--no-issue-client-certificate` flag only disables legacy GKE client certificate issuance. It does not disable the [Kubernetes certificates API](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/) , which is used to operate the cluster and cannot be disabled.\n## What's next\n- Learn about [Google Cloud Authentication](/docs/authentication) .\n- Learn about [Access Control in GKE](/kubernetes-engine/docs/concepts/access-control) .\n- Learn about [Google service accounts](/iam/docs/understanding-service-accounts) .\n- Learn about [workload identity federation for GKE](/kubernetes-engine/docs/how-to/workload-identity) .\n- Learn about [Hardening your cluster's security](/kubernetes-engine/docs/how-to/hardening-your-cluster)", "guide": "Google Kubernetes Engine (GKE)"}