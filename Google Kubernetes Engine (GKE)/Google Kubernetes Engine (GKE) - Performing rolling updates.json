{"title": "Google Kubernetes Engine (GKE) - Performing rolling updates", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/updating-apps", "abstract": "# Google Kubernetes Engine (GKE) - Performing rolling updates\nThis page explains how to perform rolling updates for applications in Google Kubernetes Engine (GKE).\n", "content": "## Overview\nYou can perform a **rolling update** to update the images, configuration, labels, annotations, and resource limits/requests of the workloads in your clusters. Rolling updates incrementally replace your resource's Pods with new ones, which are then scheduled on nodes with available resources. Rolling updates are designed to update your workloads without downtime.\nThe following objects represent Kubernetes workloads. You can trigger a rolling update on these workloads by updating their Pod template:\n- DaemonSets\n- Deployments\n- StatefulSets\nEach of these objects have a [Pod template](https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates) represented by the `spec: template` field in the object's manifest. The Pod template field contains a specification for the Pods that the controller creates to realize the desired state or behavior. You trigger an update by updating the object's `spec: template` .\nThe Pod template includes the following fields:\n- [containers](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core) \n- [containers: image](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core) \n- [metadata: labels](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#objectmeta-v1-meta) \n- [volumes](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core) \nTo learn more about the Pod template, refer to the [PodTemplateSpec](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates) documentation.\n[Scaling a resource](/kubernetes-engine/docs/how-to/scaling-apps) or updating fields outside of the Pod template does not trigger a rollout.\n## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.## Updating an application\nThe following section explains how you can update an application using the Google Cloud console or `kubectl` .\nYou can use [kubectl set](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#set) to make changes to an object's `image` , `resources` (compute resource such as CPU and memory), or `selector` fields.\nFor example, to update a Deployment from `nginx` version 1.7.9 to 1.9.1, run the following command:\n```\nkubectl set image deployment nginx nginx=nginx:1.9.1\n```\nThe `kubectl set image` command updates the `nginx` image of the Deployment's Pods one at a time.\nAs another example, to set the resource requests and limits of the Deployment:\n```\nkubectl set resources deployment nginx --limits cpu=200m,memory=512Mi --requests cpu=100m,memory=256Mi\n```\nOr, to remove the Deployment's resource requests:\n```\nkubectl set resources deployment nginx --limits cpu=0,memory=0 --requests cpu=0,memory=0\n```\nYou can use [kubectl apply](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply) to update a resource by a new or updated configuration.\n **Note:** To update a resource with `kubectl apply` , the resource must be created using `kubectl apply` or `kubectl create --save-config` .\nTo apply a new or updated configuration to a resource, run the following command:\n```\nkubectl apply -f MANIFEST\n```\nReplace `` with the name of the manifest file. If the file doesn't exist, this command creates the resource and applies the configuration; otherwise, the updated configuration is applied.\nTo edit the live configuration of an application, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- Select the desired workload.\n- Click **Edit** .\n- Use the editor to make the desired changes to the object's labels or Pod template.\n- Click **Save** .## Managing an update rollout\nYou can use [kubectl rollout](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout) to inspect a rollout as it occurs, to pause and resume a rollout, to rollback an update, and to view an object's rollout history.\n### Inspecting a rollout with kubectl rollout status\nYou can inspect the status of a rollout using the `kubectl rollout status` command.\nFor example, you can inspect the `nginx` Deployment's rollout by running the following command:\n```\nkubectl rollout status deployment nginx\n```\nThe output is similar to the following:\n```\nWaiting for rollout to finish: 2 out of 3 newreplicas have been updated...\ndeployment \"nginx\" successfully rolled out\n```\nAfter the rollout succeeds, run `kubectl get deployment nginx` to verify that all of its Pods are running. The output is similar to the following:\n```\nNAME    DESIRED CURRENT UP-TO-DATE AVAILABLE AGE\nnginx    3   3   3   3   36s\n```\n### Pausing and resuming a rollout\n**Note:** Currently, only Deployments support `kubectl rollout pause` and `resume` .\nYou can use `kubectl rollout pause` to pause a rollout.\nFor example, to pause the `nginx` Deployment's rollout, run the following command:\n```\nkubectl rollout pause deployment nginx\n```\nTo resume, run the following command:\n```\nkubectl rollout resume deployment nginx\n```\n### Viewing rollout history with kubectl rollout history\nYou can use `kubectl rollout history` to view an object's rollout history.\nFor example, to view the `nginx` Deployment's rollout history, run the following command:\n```\nkubectl rollout history deployment nginx\n```\nTo see the history of the third revision, run the following command:\n```\nkubectl rollout history deployment nginx --revision 3\n```\n### Rollback an update with kubectl rollout undo\nYou can rollback an object's rollout using the `kubectl rollout undo` command.\nFor example, to rollback to the previous version of the `nginx` Deployment, run the following command:\n```\nkubectl rollout undo deployments nginx\n```\nOr, as another example, to rollback to the third revision of the Deployment, run the following command:\n```\nkubectl rollout undo deployment nginx --to-revision 3\n```\n## Considerations for StatefulSets and DaemonSets\nStatefulSets since Kubernetes 1.7 and DaemonSets since Kubernetes 1.6 use an to configure and disable automated rolling updates for containers, labels, resource request/limits, and annotations for its Pods. The update strategy is configured using the `spec.updateStrategy` field.\nThe `spec.updateStrategy.type` field accepts either `OnDelete` or `RollingUpdate` as values.\n`OnDelete` is the default behavior when `spec.updateStrategy.type` is not specified. `OnDelete` prevents the controller from automatically updating its Pods. You must manually delete the Pods to cause the controller to create new Pods that reflect your changes. `OnDelete` is useful if you prefer to manually update Pods.\n`RollingUpdate` implements automated, rolling updates for the Pods in the StatefulSet. `RollingUpdate` causes the controller to delete and recreate each of its Pod, and each Pod one at a time. It waits until an updated Pod is running and ready before to updating its predecessor.\nThe StatefulSet controller updates all Pods in reverse ordinal order while respecting the StatefulSet guarantees.\n### Using the RollingUpdate strategy\nYou can use the `RollingUpdate` strategy to automatically update all Pods in a StatefulSet or DaemonSet.\nFor example, to patch the `web` StatefulSet to apply the `RollingUpdate` strategy, run the following command:\n```\nkubectl patch statefulset web -p '{\"spec\":{\"updateStrategy\":{\"type\":\"RollingUpdate\"}}}'\n```\nNext, make a change to the StatefulSet's `spec.template` . For example, you can use `kubectl set` to change the container image. In the following example, the `web` StatefulSet is set to have its `nginx` container run the `nginx-slim:0.7` image:\n```\nkubectl set image statefulset web nginx=nginx-slim:0.7\n```\nTo check that the Pods in the StatefulSet running the `nginx` container are updating, run the following command:\n```\nkubectl get pods -l app=nginx -w\n```\nThe output is similar to the following:\n```\nNAME  READY  STATUS    RESTARTS AGE\nweb-0  1/1  Running    0   7m\nweb-1  1/1  Running    0   7m\nweb-2  1/1  Running    0   8m\nweb-2  1/1  Terminating   0   8m\nweb-2  1/1  Terminating   0   8m\nweb-2  0/1  Terminating   0   8m\nweb-2  0/1  Terminating   0   8m\nweb-2  0/1  Terminating   0   8m\nweb-2  0/1  Terminating   0   8m\nweb-2  0/1  Pending    0   0s\nweb-2  0/1  Pending    0   0s\nweb-2  0/1  ContainerCreating 0   0s\nweb-2  1/1  Running    0   19s\nweb-1  1/1  Terminating   0   8m\nweb-1  0/1  Terminating   0   8m\nweb-1  0/1  Terminating   0   8m\nweb-1  0/1  Terminating   0   8m\nweb-1  0/1  Pending    0   0s\nweb-1  0/1  Pending    0   0s\nweb-1  0/1  ContainerCreating 0   0s\nweb-1  1/1  Running    0   6s\nweb-0  1/1  Terminating   0   7m\nweb-0  1/1  Terminating   0   7m\nweb-0  0/1  Terminating   0   7m\nweb-0  0/1  Terminating   0   7m\nweb-0  0/1  Terminating   0   7m\nweb-0  0/1  Terminating   0   7m\nweb-0  0/1  Pending    0   0s\nweb-0  0/1  Pending    0   0s\nweb-0  0/1  ContainerCreating 0   0s\nweb-0  1/1  Running    0   10s\n```\nThe Pods in the StatefulSet are updated in reverse ordinal order. The StatefulSet controller terminates each Pod, and waits for it to transition to Running and Ready prior to updating the next Pod.\n**Note:** Although the controller does not proceed to update the next Pod until its ordinal successor is Running and Ready, it restores any Pod that fails during the update to its current version. Pods that have already received the update are restored to the updated version, and Pods that have not yet received the update are restored to the previous version.\nYou can specify a `partition` parameter a StatefulSet's `RollingUpdate` field.\nIf you specify a `partition` , all Pods with an ordinal number that is greater than or equal to the `partition` value are updated. All Pods with an ordinal number that is less than the `partition` value are not updated and, even if they are deleted, are recreated at the previous version.\nIf a `partition` value is greater than its number of `replicas` , updates are not propagated to its Pods. Partitioning is useful if you want to stage an update, roll out a canary, or perform a phased roll out.\nFor example, to partition the `web` StatefulSet, run the following command:\n```\nkubectl patch statefulset web -p '{\"spec\":{\"updateStrategy\":{\"type\":\"RollingUpdate\",\"rollingUpdate\":{\"partition\":3}}}}'\n```\nThis causes Pods with an ordinal number greater than or equal to `3` to be updated.\nDaemonSet's optional `maxUnavailable` and `maxSurge` parameter are children of the DaemonSet's `rollingUpdate` field.\n`maxUnavailable` determines the maximum number of DaemonSet Pods that can be unavailable during updates. The default value, if omitted, is `1` .\n`maxSurge` is the maximum number of Pods that could be scaled up during updates. The default value, if omitted, is `0` .\nNeither value can be `0` if the other value is `0` . Both the values can be an absolute number or a percentage.\nTo learn more, see the [DaemonSetSpec](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec) .\n**Note:** During a rolling update, the `maxUnavailable` value takes precedence over [Pod disruption budgets](https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets) .\n### Updating with the OnDelete strategy\nIf you prefer to update a StatefulSet or DaemonSet manually, you can omit the `spec.updateStrategy` field, which instructs the controller to use the `OnDelete` strategy.\nTo update a controller that uses the `OnDelete` strategy, you must manually delete its Pods after making changes to its Pod template.\nFor example, you can set the `web` StatefulSet to use the `nginx-slim:0.7` image:\n```\nkubectl set image statefulset web nginx=nginx-slim:0.7\n```\nThen, to delete the first `web` Pod, run the following command:\n```\nkubectl delete pod web-0\n```\nTo watch as the Pod is recreated by the StatefulSet and transitions to Running and Ready, run the following command:\n```\nkubectl get pod web-0 -w\n```\nThe output of this command is similar to the following:\n```\nNAME  READY  STATUS    RESTARTS AGE\nweb-0  1/1  Running    0   54s\nweb-0  1/1  Terminating   0   1m\nweb-0  0/1  Terminating   0   1m\nweb-0  0/1  Terminating   0   1m\nweb-0  0/1  Terminating   0   1m\nweb-0  0/1  Pending    0   0s\nweb-0  0/1  Pending    0   0s\nweb-0  0/1  ContainerCreating 0   0s\nweb-0  1/1  Running    0   3s\n```\n## Updating a Job\nWhen you update a Job's configuration, the new Job and its Pods run with the new configuration. After updating a Job, you must manually delete the old Job and its Pods, if desired.\nTo delete a Job and all of its Pods, run the following command:\n```\nkubectl delete job my-job\n```\nTo delete a Job but keep its Pods running, specify the `--cascade=false` flag:\n```\nkubectl delete job my-job --cascade=false\n```\nYou can also run `kubectl describe deployment nginx` , which yields even more information about the Deployment.\n## What's next\n- [Learn about upgrading your cluster](/kubernetes-engine/docs/how-to/upgrading-a-cluster) .", "guide": "Google Kubernetes Engine (GKE)"}