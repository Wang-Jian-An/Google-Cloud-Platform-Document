{"title": "Google Kubernetes Engine (GKE) - Secure a Gateway", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/secure-gateway", "abstract": "# Google Kubernetes Engine (GKE) - Secure a Gateway\nThis page explains how you can secure a Gateway using various security features:\n- SSL Policies to ensure the Gateway is using the required secure protocols and algorithms\n- Certificates to secure Client-to-Gateway and Gateway-to-Backends traffic with TLS\n- Google Cloud Armor security policy to protect Services from DDoS attacks\n- Identity-Aware Proxy (IAP) to provide a layer of authentication and authorization before allowing access to a Service\nTo learn more about Gateway security, see [Gateway security](/kubernetes-engine/docs/concepts/gateway-security) .\n", "content": "## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.\n### GKE Gateway controller requirements\n- For Standard, GKE version 1.24 or later.\n- For Autopilot, GKE version 1.26 or later.\n- Google Cloud CLI version 407.0.0 or later.\n- The Gateway API is supported on [VPC-native](/kubernetes-engine/docs/concepts/alias-ips) clusters only.\n- If you are using the internal GatewayClasses, you must enable a [proxy-only subnet](/load-balancing/docs/proxy-only-subnets) .\n- Your cluster must have the`HttpLoadBalancing`add-on enabled.\n- If you are using Istio, you must upgrade Istio to one of the following versions:- 1.15.2 or later\n- 1.14.5 or later\n- 1.13.9 or later.\n- If you are using Shared VPC, then in the host project, you need to assign the`Compute Network User`role to the GKE Service account for the service project.\n### Restrictions and limitations\nIn addition to the GKE Gateway controller [restrictions and limitations](/kubernetes-engine/docs/how-to/deploying-gateways#limitations) , the following limitations apply specifically to Gateway security:\n- TLS configurations using either an [SSL Certificate](/kubernetes-engine/docs/how-to/secure-gateway#secure-using-ssl-certificate) or [Certificate Manager](/kubernetes-engine/docs/how-to/secure-gateway#secure-using-certificate-manager) on Gateways are not supported with GKE version 1.28.4-gke.1083000. Use a [Kubernetes secret](/kubernetes-engine/docs/how-to/secure-gateway#secure-using-secret) as a workaround for this GKE version.\n- You cannot use the`networking.gke.io/certmap`annotation with a`tls.certificateRefs`on the same Gateway resource. If you reference a`CertificateMap`in a Gateway, GKE will treat this as an error.\n- Certificate Manager supports both self-managed and Google-managed certificates but is not compatible with regional Gateways.\n- When using Google-managed SSL certificates, you must create the SSL certificates outside of GKE before you attach them to your Gateway.\n- Google-managed SSL certificates are not compatible with regional Gateways. For more information about TLS termination methods for each GatewayClass, see [GatewayClass TLS support](/kubernetes-engine/docs/concepts/gateway-security#tls-support) .\n- The Gateway controller does not support the `ManagedCertificate` resource.\n- The Gateway controller does not support the `networking.gke.io/managed-certificates` annotation.\n- The `appProtocol` field in the Service configuration only accepts capital letters for the protocol value ( `HTTP` , `HTTPS` or `HTTP2` ). Using lowercase letters results in using HTTP as the protocol with the backends.## Secure a Gateway using a Kubernetes Secret\nIn this example, you configure a Gateway using a [Kubernetes Secret](https://kubernetes.io/docs/concepts/configuration/secret/) .\n### Store a certificate in a Kubernetes Secret\nYou can use a certificate issued and validated by your certificate authority (CA) or create a self-signed certificate. The following steps use a self-signed certificate.\n- Create a private key:```\nopenssl genrsa -out PRIVATE_KEY_FILE 2048\n```Replace `` with the name of your private key file, such as `private-key.pem` . For more information, see [Select or create a private key](/load-balancing/docs/ssl-certificates/self-managed-certs#private-key) .\n- Create an [Open SSL configuration file](https://github.com/openssl/openssl/blob/master/apps/openssl.cnf) :```\ncat <<EOF >CONFIG_FILE\n[req]\ndefault_bits    = 2048\nreq_extensions   = extension_requirements\ndistinguished_name  = dn_requirements\nprompt     = no\n[extension_requirements]\nbasicConstraints   = CA:FALSE\nkeyUsage     = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName   = @sans_list\n[dn_requirements]\n0.organizationName  = example\ncommonName    = store.example.com\n[sans_list]\nDNS.1      = store.example.com\nEOF\n```Replace `` with the name for the new config file, such as `config-file.cnf` .\n- Create a certificate signing request (CSR) file:```\nopenssl req -new -key PRIVATE_KEY_FILE \\\u00a0 \u00a0 -out CSR_FILE \\\u00a0 \u00a0 -config CONFIG_FILE\n```Replace `` with the name of the new CSR file, such as `cert.pem` . For more information, see [Create a CSR](/load-balancing/docs/ssl-certificates/self-managed-certs#create-csr) .\n- Sign the CSR:```\nopenssl x509 -req \\\u00a0 \u00a0 -signkey PRIVATE_KEY_FILE \\\u00a0 \u00a0 -in CSR_FILE \\\u00a0 \u00a0 -out CERTIFICATE_FILE \\\u00a0 \u00a0 -extfile CONFIG_FILE \\\u00a0 \u00a0 -extensions extension_requirements \\\u00a0 \u00a0 -days 30\n```Replace `` with the path and name of the file that the command generates, such as `cert-file.pem` . For more information, see [Sign the CSR](/load-balancing/docs/ssl-certificates/self-managed-certs#create-cert) .\n- Create a Kubernetes TLS Secret using the key and the certificate file that you created:```\nkubectl create secret tls store-example-com \\\u00a0 \u00a0 --cert=CERTIFICATE_FILE \\\u00a0 \u00a0 --key=PRIVATE_KEY_FILE\n```GKE saves the certificate and key as a Kubernetes resource that you can attach to your Gateway.\n### Create a Gateway and HTTPRoute\n- Save the following manifest as `external-gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: external-httpspec:\u00a0 gatewayClassName: gke-l7-global-external-managed\u00a0 listeners:\u00a0 - name: https\u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 port: 443\u00a0 \u00a0 tls:\u00a0 \u00a0 \u00a0 mode: Terminate\u00a0 \u00a0 \u00a0 certificateRefs:\u00a0 \u00a0 \u00a0 - name: store-example-com\n```This manifest describes a Gateway with the following properties:- `gatewayClassName: gke-l7-global-external-managed`: deploys a global external Application Load Balancer.\n- `protocol: HTTPS`and`port: 443`: required for enabling TLS.\n- `tls`: references the Kubernetes Secret created in the previous step.\n- Apply the manifest to the cluster:```\nkubectl apply -f external-gateway.yaml\n```\n- Save the following manifest as `store-external-route.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-external\u00a0 labels:\u00a0 \u00a0 gateway: external-httpspec:\u00a0 parentRefs:\u00a0 - name: external-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 port: 8080\n```This manifest describes an HTTPRoute that matches traffic to `store.example.com` and sends it to the `store-v1` Service.\n- Apply the manifest to the cluster:```\nkubectl apply -f store-external-route.yaml\n```\n### Verify the Gateway\nVerify that the Gateway works by sending a request over the internet.\n- Get the IP address of the Gateway:```\nkubectl get gateway external-http -o=jsonpath=\"{.status.addresses[0].value}\"\n```The output is similar to the following:```\n203.0.113.12\n```This output is a public IP address, which means any client with internet access can connect to it.\n- Access the domain of the Gateway using `curl` :```\ncurl https://store.example.com --resolve store.example.com:443:GATEWAY_IP_ADDRESS --cacert CERTIFICATE_FILE -v\n```Replace the following:- ``: the IP address of the Gateway load balancer.\n- ``: the certificate file that you generated. You must Save this file on the machine that you are using to connect to the Gateway. The certificate is required to authenticate the Gateway because the Gateway uses a self-signed certificate.\nThe `--resolve` option resolves the domain name to the IP address of the Gateway, which is required because DNS is not configured for this domainThe output is similar to the following:```\n...\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n* SSL connection using TLSv1.2 / ECDHE-RSA-CHACHA20-POLY1305\n* ALPN, server accepted to use h2\n* Server certificate:\n* subject: O=example; CN=store.example.com\n* start date: Apr 19 15:54:50 2021 GMT\n* expire date: Apr 19 15:54:50 2022 GMT\n* common name: store.example.com (matched)\n* issuer: O=example; CN=store.example.com\n* SSL certificate verify ok.\n...\n{\n \"cluster_name\": \"gw\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"store-v1\",\n \"node_name\": \"gke-gw-default-pool-51ccbf30-yya8.c.agmsb-k8s.internal\",\n \"pod_name\": \"store-v1-84b47c7f58-tj5mn\",\n \"pod_name_emoji\": \"\ud83d\ude0d\",\n \"project_id\": \"agmsb-k8s\",\n \"timestamp\": \"2021-04-19T16:30:08\"\n # Several lines of output omitted here.\n}\n```This output includes a successful TLS handshake followed by a response from the application. The TLS connection is terminated at the Gateway and the application responds to the client securely.## Secure a Gateway using an SSL certificate\nIn this example, you configure a Gateway with a [Google-managed SSLcertificate](/load-balancing/docs/ssl-certificates) .\n**Note:** Configuring an SSL Certificate and the `networking.gke.io/certmap` annotation on the same Gateway is not a valid configuration and the controller will treat this as an error.\n### Create an SSL certificate\n- Create a Google-managed global `SslCertificate` resource:```\ngcloud compute ssl-certificates create store-example-com \\\u00a0 \u00a0 --domains=store.example.com \\\u00a0 \u00a0 --global\n```\n### Create a Gateway and HTTPRoute\n- Save the following manifest as `external-gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: external-httpspec:\u00a0 gatewayClassName: gke-l7-global-external-managed\u00a0 listeners:\u00a0 - name: https\u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 port: 443\u00a0 \u00a0 tls:\u00a0 \u00a0 \u00a0 mode: Terminate\u00a0 \u00a0 \u00a0 options:\u00a0 \u00a0 \u00a0 \u00a0 networking.gke.io/pre-shared-certs: store-example-com\n```This manifest describes a Gateway with the following properties:- `gatewayClassName: gke-l7-global-external-managed`: deploys a global external Application Load Balancer.\n- `protocol:HTTPS`and`port:443`: required for enabling TLS.\n- `tls.mode:Terminate`: terminates TLS using your SSL certificate.\n- Apply the manifest to your cluster:```\nkubectl apply -f external-gateway.yaml\n```\n- Save the following HTTPRoute manifest as `store-external-route.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-external\u00a0 labels:\u00a0 \u00a0 gateway: external-httpspec:\u00a0 parentRefs:\u00a0 - name: external-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 port: 8080\n```\n- Deploy the HTTPRoute in your cluster:```\nkubectl apply -f store-external-route.yaml\n```It might take several minutes for GKE to deploy the Gateway.\n### Verify the Gateway\n- Get the IP address of the Gateway:```\nkubectl get gateway external-http -o=jsonpath=\"{.status.addresses[0].value}\"\n```The output is similar to the following:```\n203.0.113.12\n```This output is a public IP address, which means any client with internet access can connect to it.\n- [Update an A or AAAA record](/load-balancing/docs/ssl-certificates/google-managed-certs#update-dns) to direct your domain to the IP address of the Gateway.This step is only necessary if you are configuring a Google-managed SSL certificate. If you are configuring a self-managed certificate, you can skip this step.After the DNS records are updated, it can take up to 10 minutes for your load balancer to begin using the Google-managed certificate.\n- Verify that the Gateway is working by sending a request over the internet using `curl` :```\ncurl https://store.example.com -v\n```The output is similar to the following:```\n...\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n* SSL connection using TLSv1.2 / ECDHE-RSA-CHACHA20-POLY1305\n* ALPN, server accepted to use h2\n* Server certificate:\n* subject: O=example; CN=store.example.com\n* start date: Apr 19 15:54:50 2021 GMT\n* expire date: Apr 19 15:54:50 2022 GMT\n* common name: store.example.com (matched)\n* issuer: O=example; CN=store.example.com\n* SSL certificate verify ok.\n...\n{\n \"cluster_name\": \"gw\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"store-v1\",\n \"node_name\": \"gke-gw-default-pool-51ccbf30-yya8.c.agmsb-k8s.internal\",\n \"pod_name\": \"store-v1-84b47c7f58-tj5mn\",\n \"pod_name_emoji\": \"\ud83d\ude0d\",\n \"project_id\": \"agmsb-k8s\",\n \"timestamp\": \"2021-04-19T16:30:08\",\n \"zone\": \"us-west1-a\"\n}\n```This output includes a successful TLS handshake and a response from the application. TLS is terminated at the Gateway correctly and the application responds to the client securely.## Secure a Gateway using Certificate Manager\nIn this example, you configure a Gateway using [Certificate Manager](/certificate-manager/docs) .\n**Note:** Configuring an SSL Certificate and the `networking.gke.io/certmap` annotation on the same Gateway is not a valid configuration and the controller will treat this as an error.\n### Create a CertificateMap\n- Create a `CertificateMap` :```\ngcloud certificate-manager maps create store-example-com-map\n```\n- Load your self-managed certificate and key into a `Certificate` :```\ngcloud certificate-manager certificates create store-example-com-cert \\\u00a0 \u00a0 --certificate-file=\"cert.pem\" \\\u00a0 \u00a0 --private-key-file=\"PRIVATE_KEY_FILE\"\n```\n- Create a `CertificateMapEntry` which assigns the certificate to the `CertificateMap` :```\ngcloud certificate-manager maps entries create store-example-com-map-entry \\\u00a0 \u00a0 --map=store-example-com-map \\\u00a0 \u00a0 --hostname=store.example.com \\\u00a0 \u00a0 --certificates=store-example-com-cert\n```\n### Create a Gateway and HTTPRoute\n- Save the following manifest as `cert-map-gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: external-http\u00a0 annotations:\u00a0 \u00a0 networking.gke.io/certmap: store-example-com-mapspec:\u00a0 gatewayClassName: gke-l7-global-external-managed\u00a0 listeners:\u00a0 - name: https\u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 port: 443\n```This manifest describes a Gateway with the following properties:- `gatewayClassName: gke-l7-global-external-managed`: deploys a global external Application Load Balancer.\n- `protocol: HTTPS`and`port: 443`: required for enabling TLS.\nThere is no TLS section because TLS is configured with Certificate Manager using the annotation `networking.gke.io/certmap` .\n- Apply the manifest to the cluster:```\nkubectl apply -f cert-map-gateway.yaml\n```It might take several minutes for GKE to deploy the Gateway.\n- Save the following manifest as `cert-map-http-route.yaml` :```\napiVersion: gateway.networking.k8s.io/v1beta1kind: HTTPRoutemetadata:\u00a0 name: foo\u00a0 namespace: defaultspec:\u00a0 parentRefs:\u00a0 - name: external-http\u00a0 hostnames:\u00a0 - foo.example.com\u00a0 rules:\u00a0 - matches:\u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 value: /\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: foo-v1\u00a0 \u00a0 \u00a0 port: 8080\n```\n- Apply the manifest to the cluster:```\nkubectl apply -f cert-map-http-route.yaml\n```\n### Verify the Gateway\n- Get the IP address of the Gateway:```\nkubectl get gateway external-http -o=jsonpath=\"{.status.addresses[0].value}\"\n```The output is similar to the following:```\n203.0.113.12\n```This output is a public IP address, which means any client with internet access can connect to it.\n- [Update an A or AAAA record](/load-balancing/docs/ssl-certificates/google-managed-certs#update-dns) to direct your domain to the IP address of the Gateway.This step is only necessary if you are configuring a Google-managed SSL Certificate. If you are configuring a self-managed certificate, you can skip this step.After the DNS records are updated, it can take up to 10 minutes for your load balancer to begin using the Google-managed certificate.\n- Access the domain of the Gateway using `curl` :```\ncurl https://store.example.com -v\n```The output is similar to the following:```\n...\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n* SSL connection using TLSv1.2 / ECDHE-RSA-CHACHA20-POLY1305\n* ALPN, server accepted to use h2\n* Server certificate:\n* subject: O=example; CN=store.example.com\n* start date: Apr 19 15:54:50 2021 GMT\n* expire date: Apr 19 15:54:50 2022 GMT\n* common name: store.example.com (matched)\n* issuer: O=example; CN=store.example.com\n* SSL certificate verify ok.\n...\n{\n \"cluster_name\": \"gw\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"store-v1\",\n \"node_name\": \"gke-gw-default-pool-51ccbf30-yya8.c.agmsb-k8s.internal\",\n \"pod_name\": \"store-v1-84b47c7f58-tj5mn\",\n \"pod_name_emoji\": \"\ud83d\ude0d\",\n \"project_id\": \"agmsb-k8s\",\n \"timestamp\": \"2021-04-19T16:30:08\",\n \"zone\": \"us-west1-a\"\n}\n```This output includes a successful TLS handshake and a response from the application. TLS is terminated at the Gateway correctly and the application responds to the client securely.## Secure load balancer to application traffic using TLS\nYou can encrypt traffic from the load balancer to backend Pods using the `ports[].appProtocol` field. The supported fields for `appProtocol` are: `HTTP` , `HTTPS` , and `HTTP2` .\nThe following manifest describes a Service that specifies the load balancer must use HTTPS traffic to communication with the backend Pods:\n```\napiVersion: v1kind: Servicemetadata:\u00a0 name: store-v2spec:\u00a0 selector:\u00a0 \u00a0 app: store\u00a0 \u00a0 version: v2\u00a0 ports:\u00a0 - port: 8080\u00a0 \u00a0 targetPort: 8080\u00a0 \u00a0 appProtocol: HTTPS\n```\n**Note:** The `appProtocol` field is case sensitive and requires the value to be set using capital letters: `HTTP` , `HTTPS` or `HTTP2` . If you use lowercase letters, `appProtocol` defaults to `HTTP` .\nThe load balancer does not verify the certificate used by backend Pods. It is your responsibility to ensure the certificate used on the backend Pods is valid.\n**Note:** The previously supported `networking.gke.io/app-protocol` is deprecated. This annotation is not supported by the GKE Gateway controller.\n## Secure client to load balancer traffic using SSL policies\nWhen your applications are exposed through an external gateway that uses HTTPS, it is important to use the latest protocols or specify the minimum [SSL or TLS](/load-balancing/docs/ssl-policies-concepts) version. You can secure the client to load balancer traffic by using SSL policies.\nTo know more about SSL policies that can be attached to your Gateway and how to create them, see [Configure SSL Policies to secure client to load balancer traffic](/kubernetes-engine/docs/how-to/configure-gateway-resources#configure_ssl_policies) .\n## Protect your backends using Google Cloud Armor\n[Google Cloud Armor security policies](/armor/docs/security-policy-overview) help you protect your load-balanced applications from web-based attacks. Once you have [configured a Google Cloud Armor security policy](/armor/docs/configure-security-policies) , you can reference it in a `GCPBackendPolicy` applied to your Kubernetes Services.\nTo configure Google Cloud Armor policies with Gateway, see [Configure Google Cloud Armor security policy to secure your backend Services](/kubernetes-engine/docs/how-to/configure-gateway-resources#configure_cloud_armor) .\n## Authenticate requests to your backends using Identity-Aware Proxy\n[Identity-Aware Proxy](/iap/docs/concepts-overview) helps you protect your backends from unwanted traffic by authenticating clients sending requests to your applications and enforcing role-based traffic authorization. After you enable [Identity-Aware Proxy for GKE](/iap/docs/enabling-kubernetes-howto) , you can reference your OAuth credentials in a `GCPBackendPolicy` applied to your Kubernetes Services.\nTo configure Identity-Aware Proxy with Gateway, see [Configure Identity-Aware Proxy](/kubernetes-engine/docs/how-to/configure-gateway-resources#configure_iap) .\n## What's next\n- Learn more about [Gateway security](/kubernetes-engine/docs/concepts/gateway-security) .", "guide": "Google Kubernetes Engine (GKE)"}