{"title": "Google Kubernetes Engine (GKE) - Using container image digests in Kubernetes manifests", "url": "https://cloud.google.com/kubernetes-engine/docs/tutorials/using-container-image-digests-in-kubernetes-manifests", "abstract": "# Google Kubernetes Engine (GKE) - Using container image digests in Kubernetes manifests\nLast reviewed 2023-07-21 UTC\nThis tutorial shows developers and operators who deploy containers to Kubernetes how to use container image digests to identify container images. A container image digest uniquely and immutably identifies a container image.\nDeploying containers images by using the image digest provides several benefits compared to using image tags. For more information on image digests, see the accompanying document on [using container image digests](/architecture/using-container-images) before you continue this tutorial.\nThe `image` argument for containers in a Kubernetes Pod specification accepts images with digests. This argument applies everywhere you use a Pod specification, such as in the `template` section of Deployment, StatefulSet, DaemonSet, ReplicaSet, CronJob, and Job resources.\nTo deploy an image by using the digest, you use the image name, followed by `@sha256:` and the digest value. The following is an example of a Deployment resource that uses an image with a digest:\n```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: echo-deploymentspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: echo\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: echo\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: echoserver\u00a0 \u00a0 \u00a0 \u00a0 image: gcr.io/google-containers/echoserver@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 8080\n```\nOne downside of using image digests is that you don't know the digest value until after you have published your image to a registry. As you build new images, the digest value changes, and you need a way to update your Kubernetes manifests each time you deploy.\nThis tutorial shows how you can use tools such as [Skaffold](https://skaffold.dev/) , [kpt](https://kpt.dev/) , [digester](https://github.com/google/k8s-digester) , [kustomize](https://kustomize.io/) , [gke-deploy](/build/docs/deploying-builds/deploy-gke) , and [ko](https://ko.build/) to use image digests in your manifests.", "content": "## RecommendationsThis document presents several ways to use image digests in Kubernetes deployments. The tools described in this document are complementary. For example, you can use the output of a kpt function with kustomize to create variants for different environments. Skaffold can [build images using ko](https://skaffold.dev/docs/builders/builder-types/ko/) and deploy the images to your Kubernetes clusters using `kubectl` or kpt.\nThe reason the tools are complementary is that they perform [structured edits](https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/declarative-application-management.md) based on the [Kubernetes resource model (KRM)](https://kubernetes.io/docs/reference/using-api/api-concepts/) . This model makes the tools pluggable, and you can evolve your use of the tools to create processes and pipelines that help you deploy your apps and services.\nTo get started, we recommend the approach that works best with your existing tools and processes:- Skaffold can add digests to image references. You enable this function with a small configuration change. Adopting Skaffold provides additional benefits, such as abstracting away how different tools build and deploy container images.\n- By using the digester tool as a mutating admission webhook in your Kubernetes clusters, you can add digests to all your deployments with minimal impact on your current processes for building and deployment container images. The digester webhook also simplifies adoption of [Binary Authorization](/binary-authorization/docs) , because it only requires a label to be added to a namespace.\n- kpt is a great option if you need a flexible tool to manipulate Kubernetes manifests. The digester tool can be used as a client-side [KRM function](https://kpt.dev/book/02-concepts/03-functions) in a [kpt pipeline](https://kpt.dev/book/04-using-functions/01-declarative-function-execution) .\n- If you already use kustomize to manage Kubernetes manifests across environments, we recommend that you take advantage of its image transformers to deploy images by digest.\n- `ko` is a great way to build and publish images for Go apps, and it is used by open source projects such as [Knative](https://knative.dev/) , [Tekton](https://tekton.dev/) , and [sigstore](https://sigstore.dev/) .\nIf you don't use any of the tools described in this document, we recommend that you start with Skaffold and the digester webhook. Skaffold is a common tool used by both developers and release teams, and it integrates with the other tools described in this tutorial. You can take advantage of these integration options as your requirements evolve. The digester Kubernetes webhook complements Skaffold by enabling digest-based deployments for an entire cluster.## Objectives\n- Use Skaffold to build and push an image, and to insert the image name and digest in a Kubernetes manifest.\n- Use the digester client-side function and mutating admission webhook to add digests to images in Kubernetes Pods and Pod templates.\n- Use kpt setters to replace an image tag in a Kubernetes manifest with an image digest.\n- Use kustomize to generate a Kubernetes manifest with an image digest.\n- Use`gke-deploy`to resolve an image tag to a digest in a Kubernetes manifest.\n- Use`ko`to build and push an image, and to insert the image name and digest in a Kubernetes manifest.## CostsIn this document, you use the following billable components of Google Cloud:- [Artifact Registry](/artifact-registry/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .## Before you begin\n- In the Google Cloud console, on the project selector page,   select or [create a Google Cloud project](/resource-manager/docs/creating-managing-projects) . **Note** : If you don't plan to keep the  resources that you create in this procedure, create a project instead of  selecting an existing project. After you finish these steps, you can  delete the project, removing all resources associated with the project. [Go to project selector](https://console.cloud.google.com/projectselector2/home/dashboard) \n- [Make sure that billing is enabled for your Google Cloud project](/billing/docs/how-to/verify-billing-enabled#console) .\n- Enable the Artifact Registry API. [Enable the API](https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com) \n- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) \n- In Cloud Shell, set the default project for Google Cloud CLI:```\ngcloud config set project PROJECT_ID\n```Replace `` with your [project ID].\n- Create a container image repository in Artifact Registry:```\ngcloud artifacts repositories create REPOSITORY \\\u00a0 \u00a0 --location=LOCATION \\\u00a0 \u00a0 --repository-format=docker\n```Replace the following:- ``: the name you want to use for your repository, for instance`digest-tutorial`.\n- ``: an [Artifact Registry location](/artifact-registry/docs/repositories/repo-locations) , for instance`us-central1`.\n- Configure authentication to the Artifact Registry location for the CLI tools used in this tutorial:```\ngcloud auth configure-docker LOCATION-docker.pkg.dev\n```## Using Skaffold [Skaffold](https://skaffold.dev/) is a command-line tool for continuous development and deployment of applications to Kubernetes clusters.\nUse Skaffold to build an image, push the image to Artifact Registry, and replace the `image` placeholder value in a Kubernetes manifest template with the name, tag, and digest of the pushed image:- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/skaffoldcd ~/container-image-digests-tutorial/skaffold\n```\n- Clone the Skaffold Git repository:```\ngit clone https://github.com/GoogleContainerTools/skaffold.git\n```\n- Go to the directory of the `getting-started` example:```\ncd skaffold/examples/getting-started\n```\n- Checkout the Git tag that matches your version of Skaffold:```\ngit checkout $(skaffold version)\n```\n- View the `skaffold.yaml` configuration file:```\ncat skaffold.yaml\n```The file resembles the following:```\napiVersion: skaffold/v4beta6kind: Configbuild:\u00a0 artifacts:\u00a0 - image: skaffold-examplemanifests:\u00a0 rawYaml:\u00a0 - k8s-pod.yaml\n```The `build.artifacts` section contains a placeholder image name. Skaffold looks for this placeholder in the input manifest files.The `manifests` section tells Skaffold to read an input manifest from the current directory with the name `k8s-pod.yaml` .For an overview of all available options, see the [skaffold.yaml reference documentation](https://skaffold.dev/docs/references/yaml/) .\n- View the Kubernetes manifest template:```\ncat k8s-pod.yaml\n```The file is the following:```\napiVersion: v1kind: Podmetadata:\u00a0 name: getting-startedspec:\u00a0 containers:\u00a0 - name: getting-started\u00a0 \u00a0 image: skaffold-example\n```The `skaffold-example` placeholder value in the `image` field matches the value of the `image` field in the `skaffold.yaml` file. Skaffold replaces this placeholder value with the full image name and digest in the rendered output.\n- Build and push the image to Artifact Registry:```\nskaffold build \\\u00a0 \u00a0 --default-repo=LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY \\\u00a0 \u00a0 --file-output=artifacts.json \\\u00a0 \u00a0 --interactive=false \\\u00a0 \u00a0 --push=true \\\u00a0 \u00a0 --update-check=false\n```This command uses the following flags:- The`--file-output`flag specifies the file where Skaffold saves information about the built image, including the digest value.\n- The`--push`flag instructs Skaffold to push the built image to the container image registry specified by the`--default-repo`flag.\n- The`--interactive`and`--update-check`flags are both set to`false`. Set these flags to`false`in non-interactive environments, such as build pipelines, but leave them as their default values (`true`for both flags) for local development.\nIf you use Cloud Deploy to deploy to GKE, use the file from the `--file-output` flag as the value of the `--build-artifacts` flag when you [create a release](/deploy/docs/integrating-ci#build_artifacts_versus_images) .\n- Render the expanded Kubernetes manifest with the name, tag, and digest of the container image from the previous step:```\nskaffold render \\\u00a0 \u00a0 --build-artifacts=artifacts.json \\\u00a0 \u00a0 --digest-source=none \\\u00a0 \u00a0 --interactive=false \\\u00a0 \u00a0 --offline=true \\\u00a0 \u00a0 --output=rendered.yaml \\\u00a0 \u00a0 --update-check=false\n```This command uses the following flags:- The`--build-artifacts`flag references the output file from the`skaffold build`command in the previous step.\n- The`--digest-source=none`flag means that Skaffold uses the digest value from the file provided in the`--build-artifacts`flag, instead of resolving the digest from the container image registry.\n- The`--offline=true`flag means that you can run the command without requiring access to a Kubernetes cluster.\n- The`--output`flag specifies the output file for the rendered manifest.\n- View the rendered manifest:```\ncat rendered.yaml\n```The output resembles the following:```\napiVersion: v1kind: Podmetadata:\u00a0 name: getting-startedspec:\u00a0 containers:\u00a0 - image: LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY/skaffold-example:TAG@sha256:DIGEST\u00a0 \u00a0 name: getting-started\n```In this output, you see the following values:- ``: the tag that Skaffold assigned to the image.\n- ``: the image digest value## Using digester [Digester](https://github.com/google/k8s-digester) adds digests to container and init container images in Kubernetes Pod and Pod template specifications. Digester replaces container image references that use tags:\n```\nspec:\u00a0 containers:\u00a0 - image: gcr.io/google-containers/echoserver:1.10\n```\nWith references that use the image digest:\n```\nspec:\u00a0 containers:\u00a0 - image: gcr.io/google-containers/echoserver:1.10@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\n```\nDigester can run either as a [mutating admission webhook](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/) in a Kubernetes cluster, or as a client-side [KRM function](https://kpt.dev/book/02-concepts/03-functions) with the kpt or kustomize command-line tools.\n### Using the digester KRM function\n- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/digester-fncd ~/container-image-digests-tutorial/digester-fn\n```\n- Download the digester binary:```\nmkdir -p ${HOME}/binexport PATH=${HOME}/bin:${PATH}DIGESTER_VERSION=$(curl -sL https://api.github.com/repos/google/k8s-digester/releases/latest | jq -r .tag_name)curl -L \"https://github.com/google/k8s-digester/releases/download/${DIGESTER_VERSION}/digester_$(uname -s)_$(uname -m)\" --output ${HOME}/bin/digesterchmod +x ${HOME}/bin/digester\n```\n- Create a Kubernetes Pod manifest that references the image `gcr.io/google-containers/echoserver` using the tag `1.10` :```\ncat << EOF > pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n name: echo\nspec:\n containers:\n - name: echoserver\n image: gcr.io/google-containers/echoserver:1.10\n ports:\n - containerPort: 8080\nEOF\n```\n- Run the digester KRM function using kpt with the manifests in the current directory ( `.` ):```\nkpt fn eval . --exec digester\n```When you run this command, kpt performs an in-place update of the manifests in the current directory. If you want kpt to show the updated manifest on the console and leave the manifest file unchanged, add the `--output unwrap` flag.\n- View the updated manifest:```\ncat pod.yaml\n```The file is the following:```\napiVersion: v1kind: Podmetadata:\u00a0 name: echospec:\u00a0 containers:\u00a0 \u00a0 - name: echoserver\u00a0 \u00a0 \u00a0 image: gcr.io/google-containers/echoserver:1.10@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 8080\n```\n### Using the digester admission webhook\n- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/digester-webhookcd ~/container-image-digests-tutorial/digester-webhook\n```\n- Create a local Kubernetes cluster using [kind](https://kind.sigs.k8s.io/) :```\nkind create cluster\n```kind is a command-line tool to run local Kubernetes clusters using Docker.\n- Deploy the digester webhook:```\nDIGESTER_VERSION=$(curl -sL https://api.github.com/repos/google/k8s-digester/releases/latest | jq -r .tag_name)kustomize build \"https://github.com/google/k8s-digester.git/manifests?ref=${DIGESTER_VERSION}\" | kubectl apply -f ```\n- Create a Kubernetes namespace called `digester-demo` in the kind cluster:```\nkubectl create namespace digester-demo\n```\n- Add the `digest-resolution: enabled` label to the `digester-demo` namespace:```\nkubectl label namespace digester-demo digest-resolution=enabled\n```The digester webhook adds digests to Pods in namespaces with this label.\n- Create a Kubernetes Deployment manifest that references the image `gcr.io/google-containers/echoserver` using the tag `1.10` :```\ncat << EOF > deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n name: echo-deployment\nspec:\n selector:\n matchLabels:\n  app: echo\n template:\n metadata:\n  labels:\n  app: echo\n spec:\n  containers:\n  - name: echoserver\n  image: gcr.io/google-containers/echoserver:1.10\n  ports:\n  - containerPort: 8080\nEOF\n```\n- Apply the manifest in the `digester-demo` namespace:```\nkubectl apply --filename deployment.yaml --namespace digester-demo \\\u00a0 \u00a0 --output jsonpath='{.spec.template.spec.containers[].image}{\"\\n\"}'\n```The `--output` flag instructs `kubectl` to output the image name to the console, followed by a newline character. The output is the following:```\ngcr.io/google-containers/echoserver:1.10@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\n```This output shows that the digester webhook added the image digest to the Pod template specification in the Deployment resource.\n- Delete the kind cluster to free up resources in your Cloud Shell session:```\nkind delete cluster\n```\n## Using kpt setters [kpt](https://kpt.dev/) is a command-line tool to manage, manipulate, customize, and apply Kubernetes resource manifests.\nYou can use the `create-setters` and `apply-setters` KRM functions from the [kpt Functions Catalog](https://catalog.kpt.dev/) to update image digests in your Kubernetes manifests when you build new images.- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/kptcd ~/container-image-digests-tutorial/kpt\n```\n- Create a kpt package in the current directory:```\nkpt pkg init --description \"Container image digest tutorial\"\n```\n- Create a Kubernetes Pod manifest that references the image `gcr.io/google-containers/echoserver` using the tag `1.10` :```\ncat << EOF > pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n name: echo\nspec:\n containers:\n - name: echoserver\n image: gcr.io/google-containers/echoserver:1.10\n ports:\n - containerPort: 8080\nEOF\n```\n- Use kpt to create a setter called `echoimage` for the manifest field, where the existing value is `gcr.io/google-containers/echoserver:1.10` :```\nkpt fn eval . \\\u00a0 \u00a0 --image gcr.io/kpt-fn/create-setters@sha256:0220cc87f29ff9abfa3a3b5643aa50f18d355d5e9dc9e1f518119633ddc4895c \\\u00a0 \u00a0 -- \"echoimage=gcr.io/google-containers/echoserver:1.10\"\n```\n- View the manifest:```\ncat pod.yaml\n```The file is the following:```\napiVersion: v1kind: Podmetadata:\u00a0 name: echospec:\u00a0 containers:\u00a0 - name: echoserver\u00a0 \u00a0 image: gcr.io/google-containers/echoserver:1.10 # kpt-set: ${echoimage}\u00a0 \u00a0 ports:\u00a0 \u00a0 - containerPort: 8080\n```\n- Get the digest value of the container image:```\nDIGEST=$(gcloud container images describe \\\u00a0 \u00a0 gcr.io/google-containers/echoserver:1.10 \\\u00a0 \u00a0 --format='value(image_summary.digest)')\n```\n- Set the new field value:```\nkpt fn eval . \\\u00a0 \u00a0 --image gcr.io/kpt-fn/apply-setters@sha256:4d4295727183396f0c3c6a75d2560254c2f9041a39e95dc1e5beffeb49cc1a12 \\\u00a0 \u00a0 -- \"echoimage=gcr.io/google-containers/echoserver:1.10@$DIGEST\"\n```When you run this command, kpt performs an in-place replacement of the `image` field value in the manifest.\n- View the updated manifest:```\ncat pod.yaml\n```The file is the following:```\napiVersion: v1kind: Podmetadata:\u00a0 name: echospec:\u00a0 containers:\u00a0 - name: echoserver\u00a0 \u00a0 image: gcr.io/google-containers/echoserver:1.10@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229 # kpt-set: ${echoimage}\u00a0 \u00a0 ports:\u00a0 \u00a0 - containerPort: 8080\n```\n## Using kustomize image transformers [kustomize](https://kustomize.io/) is a command-line tool that lets you customize Kubernetes manifests by using overlays, patches, and transformers.\nYou can use the kustomize [image transformer](https://github.com/kubernetes-sigs/kustomize/blob/master/examples/transformerconfigs/README.md#images-transformer) to update the image name, tag, and digest in your existing manifest.\nThe following `kustomization.yaml` snippet shows you how to configure the image transformer to use the transformer `digest` value for images where the Pod specification `image` value matches the transformer `name` value:\n```\nimages:- name: gcr.io/google-containers/echoserver\u00a0 digest: sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\n```\nTo use a kustomize image transformer with an image digest, do the following:- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/kustomizecd ~/container-image-digests-tutorial/kustomize\n```\n- Create a `kustomization.yaml` file:```\nkustomize init\n```\n- Create a Kubernetes manifest with a Pod specification that references the image `gcr.io/google-containers/echoserver` using the tag `1.10` :```\ncat << EOF > pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n name: echo\nspec:\n containers:\n - name: echoserver\n image: gcr.io/google-containers/echoserver:1.10\n ports:\n - containerPort: 8080\nEOF\n```\n- Add the manifest as a resource in the `kustomization.yaml` file:```\nkustomize edit add resource pod.yaml\n```\n- Use an image transformer to update the digest of the image:```\nkustomize edit set image \\\u00a0 \u00a0 gcr.io/google-containers/echoserver@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\n```\n- View the image transformer in the `kustomization.yaml` file:```\ncat kustomization.yaml\n```The file is the following:```\napiVersion: kustomize.config.k8s.io/v1beta1kind: Kustomizationresources:- pod.yamlimages:- digest: sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u00a0 name: gcr.io/google-containers/echoserver\n```\n- View the resulting manifest:```\nkustomize build .\n```The output is the following:```\napiVersion: v1kind: Podmetadata:\u00a0 name: echospec:\u00a0 containers:\u00a0 - image: gcr.io/google-containers/echoserver@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u00a0 \u00a0 name: echoserver\u00a0 \u00a0 ports:\u00a0 \u00a0 - containerPort: 8080\n```\n- To run the kustomize transformer and apply the resulting manifest to a Kubernetes cluster in one step, you can use the `kubectl apply` command with the `--kustomize` flag:```\nkubectl apply --kustomize .\n```If you want to apply the output later, you can redirect the output of the `kustomize build` command to a file.\n## Using gke-deploy [gke-deploy](https://github.com/GoogleCloudPlatform/cloud-builders/blob/master/gke-deploy/README.md) is a command-line tool that you use with [Google Kubernetes Engine (GKE)](/kubernetes-engine) . `gke-deploy` wraps the `kubectl` command-line tool and can modify the resources that you create following Google's recommended practices.\nIf you use the `gke-deploy` sub-commands `prepare` or `run` , `gke-deploy` resolves your image tags to digests and saves the expanded manifests with the image digests in the file `output/expanded/aggregated-resources.yaml` by default.\nYou can use `gke-deploy run` to both substitute the image tag for a digest and apply the expanded manifest to your GKE cluster. Although this command is convenient, there is a downside: the image tag is substituted at deployment time. The image associated with the tag might have changed in the time between when you decided to deploy, and when you deployed, resulting in deploying an unexpected image. For production deployments, we recommend separate steps for generating and applying manifests.\nTo replace an image tag in a Kubernetes deployment manifest with the image digest, do the following:- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/gke-deploycd ~/container-image-digests-tutorial/gke-deploy\n```\n- Install `gke-deploy` :```\ngo install github.com/GoogleCloudPlatform/cloud-builders/gke-deploy@latest\n```\n- Create a Kubernetes Deployment manifest that references the image `gcr.io/google-containers/echoserver` using the tag `1.10` :```\ncat << EOF > deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n name: echo-deployment\nspec:\n selector:\n matchLabels:\n  app: echo\n template:\n metadata:\n  labels:\n  app: echo\n spec:\n  containers:\n  - name: echoserver\n  image: gcr.io/google-containers/echoserver:1.10\n  ports:\n  - containerPort: 8080\nEOF\n```\n- Generate an expanded manifest based on the `deployment.yaml` manifest:```\ngke-deploy prepare \\\u00a0 \u00a0 --filename deployment.yaml \\\u00a0 \u00a0 --image gcr.io/google-containers/echoserver:1.10 \\\u00a0 \u00a0 --version 1.10\n```\n- View the expanded manifest:```\ncat output/expanded/aggregated-resources.yaml\n```The output is the following:```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 labels:\u00a0 \u00a0 app.kubernetes.io/managed-by: gcp-cloud-build-deploy\u00a0 \u00a0 app.kubernetes.io/version: \"1.10\"\u00a0 name: echo-deployment\u00a0 namespace: defaultspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: echo\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: echo\u00a0 \u00a0 \u00a0 \u00a0 app.kubernetes.io/managed-by: gcp-cloud-build-deploy\u00a0 \u00a0 \u00a0 \u00a0 app.kubernetes.io/version: \"1.10\"\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - image: gcr.io/google-containers/echoserver@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u00a0 \u00a0 \u00a0 \u00a0 name: echoserver\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 8080\n```In the expanded manifest, the image tag is replaced by the digest.The `--version` argument you used with the `gke-deploy` command sets the value of [the app.kubernetes.io/version label](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/) in the deployment and the Pod template metadata of the expanded manifest.To learn how to use `gke-deploy` with Cloud Build, see the [Cloud Build documentation for gke-deploy](/build/docs/deploying-builds/deploy-gke) .\n## Using ko [ko](https://ko.build/) is a command-line tool and library for building [Go](https://golang.org/) container images and deploying them to Kubernetes clusters. `ko` builds images without using the Docker daemon, so you can use it in environments where you can't install Docker.\nThe `ko` sub-command [build](https://ko.build/reference/ko_build/) builds images and publishes them to a container image registry or loads them into your local Docker daemon.\nThe `ko` sub-command [resolve](https://ko.build/reference/ko_resolve/) does the following:- Identifies the images to build by finding placeholders in the`image`fields of the Kubernetes manifests that you provide by using the`--filename`argument.\n- Builds and publishes your images.\n- Replaces the`image`value placeholders with the names and digests of the images it built.\n- Prints the expanded manifests.\nThe `ko` sub-commands [apply](https://ko.build/reference/ko_apply/) , [create](https://ko.build/reference/ko_create/) , and [run](https://ko.build/reference/ko_run/) perform the same steps as `resolve` , and then execute `kubectl apply` , `create` , or `run` with the expanded manifests.\nTo build an image from Go source code, and add the digest of the image to a Kubernetes deployment manifest, do the following- In Cloud Shell, create and go to a directory to store the files that you create in this section:```\nmkdir -p ~/container-image-digests-tutorial/kocd ~/container-image-digests-tutorial/ko\n```\n- Download `ko` and add it to your `PATH` :```\nmkdir -p ${HOME}/binexport PATH=${HOME}/bin:${PATH}KO_VERSION=$(curl -sL https://api.github.com/repos/ko-build/ko/releases/latest | jq -r .tag_name | cut -c2-)curl -L \"https://github.com/ko-build/ko/releases/download/v${KO_VERSION}/ko_${KO_VERSION}_$(uname -s)_$(uname -m).tar.gz\" | tar -zxC ${HOME}/bin ko\n```\n- Create a Go app with the module name `example.com/hello-world` in a new directory called `app` :```\nmkdir -p app/cmd/ko-examplecd appgo mod init example.com/hello-worldcat << EOF > cmd/ko-example/main.gopackage mainimport \"fmt\"func main() {\u00a0 \u00a0 fmt.Println(\"hello world\")}EOF\n```\n- Define the image repository that `ko` uses to publish images:```\nexport KO_DOCKER_REPO=LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY\n```This example uses Artifact Registry, but you can use `ko` with a different container image registry.\n- To build and publish an image for your app, do one of the following steps:- Build and publish an image for your app by providing the path to your Go [main package](https://golang.org/ref/spec#Program_execution) :```\nko build --base-import-paths ./cmd/ko-example\n```The optional argument `--base-import-paths` means that `ko` uses the short name of the main package directory as the image name.`ko` prints the image name and digest to `stdout` in the following format:```\nLOCATION-docker.pkg.dev/PROJECT_ID/ko-example@sha256:DIGEST\n```In this output, `` is the image digest value. **Note:** All other`ko`output goes to`stderr`. If you want to capture the image name and digest, you can capture`stdout`in an environment variable:```\nIMAGE_AND_DIGEST=$(ko build --base-import-paths ./cmd/ko-example)\n```\n- Use `ko` to replace a manifest placeholder with the name and digest of the image it builds and publishes:- Create a Kubernetes Pod manifest. The manifest uses the placeholder `ko://` `` as the value of the `image` field:```\ncat << EOF > ko-pod.yamlapiVersion: v1kind: Podmetadata:\u00a0 name: ko-examplespec:\u00a0 containers:\u00a0 - name: hello-world\u00a0 \u00a0 image: ko://example.com/hello-world/cmd/ko-exampleEOF\n```\n- Build and publish an image for your app, and replace the manifest placeholder with the image name and digest:```\nko resolve --base-import-paths --filename ko-pod.yaml\n````ko` prints the manifest with the image name and digest to `stdout` :```\napiVersion: v1kind: Podmetadata:\u00a0 name: ko-examplespec:\u00a0 containers:\u00a0 - name: hello-world\u00a0 \u00a0 image: LOCATION-docker.pkg.dev/PROJECT_ID/ko-example@sha256:DIGEST\n```In this output, `` is the image digest value.\n## Clean upThe easiest way to eliminate billing is to delete the Google Cloud project that you created for the tutorial. Alternatively, you can delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete the resourcesIf you want to keep the Google Cloud project that you used in this tutorial, delete the individual resources:- In Cloud Shell, delete the files you created in this tutorial:```\ncdrm -rf ~/container-image-digests-tutorial\n```\n- Delete the container image repository in Artifact Registry:```\ngcloud artifacts repositories delete REPOSITORY \\\u00a0 \u00a0 --location=LOCATION --async --quiet\n```\n## What's next\n- Learn more about [container image digests](/architecture/using-container-images) .\n- Learn more about the [digester client-side KRM function and Kubernetes mutating webhook](https://github.com/google/k8s-digester) .\n- Explore [GitOps-style continuous delivery with Cloud Build](/kubernetes-engine/docs/tutorials/gitops-cloud-build) .\n- Learn best practices for [building containers](/architecture/best-practices-for-building-containers) .\n- Learn best practices for [operating containers](/architecture/best-practices-for-operating-containers) .", "guide": "Google Kubernetes Engine (GKE)"}