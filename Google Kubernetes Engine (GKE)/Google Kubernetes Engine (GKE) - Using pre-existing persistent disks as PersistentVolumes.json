{"title": "Google Kubernetes Engine (GKE) - Using pre-existing persistent disks as PersistentVolumes", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/preexisting-pd", "abstract": "# Google Kubernetes Engine (GKE) - Using pre-existing persistent disks as PersistentVolumes\nThis page explains how to create a [PersistentVolume](/kubernetes-engine/docs/concepts/persistent-volumes) using existing persistent disks populated with data, and how to use the PersistentVolume in a Pod.\n", "content": "## Overview\nThere are two common scenarios which use a pre-existing persistent disk.\n- [Manually creating a PersistentVolumeClaim and a PersistentVolume, binding them together, and referring to the PersistentVolumeClaim in a Pod specification.](#pvc_to_pv) \n- [Use a StatefulSet to automatically generate PersistentVolumeClaims which are bound to manually generated PersistentVolumes corresponding to a series of pre-existing persistent disks.](#pv_to_statefulset) \nThe examples in this page use existing [Compute Engine persistent disks](/compute/docs/disks) .\nWhile `ext4` is the default filesystem type, you can use a pre-existing persistent disk with the `xfs` filesystem instead as long as your [node image supports it](/kubernetes-engine/docs/concepts/node-images#storage_driver_support) . To use an `xfs` disk, change `spec.csi.fsType` to `xfs` in the PersistentVolume manifest.\nWindows does not support the `ext4` filesystem type. You must use the `NTFS` filesystem for Windows Server node pools. To use an `NTFS` disk, change `spec.csi.fsType` to `NTFS` in the PersistentVolume manifest.\n**Note:** If the filesystem type for the persistent disk you use doesn't match the `fsType` you specify in the PersistentVolume manifest, pods you create that consume the volumes will not start, and you will see errors in the Pod description. Similarly, Persistent Disk CSI volumes only support a single partition. Volumes created outside of GKE with multiple partitions cannot be used with this technique.\n## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.\n- Ensure that you have existing persistent disks. To provision a disk, see [Provisioning regional persistent disks](/kubernetes-engine/docs/how-to/persistent-volumes/regional-pd#manual-provisioning) .\n- Ensure that your cluster uses the [Compute Engine persistent disk CSI driver](/kubernetes-engine/docs/how-to/persistent-volumes/gce-pd-csi-driver) .## Using a PersistentVolumeClaim bound to the PersistentVolume\nFor a container to access your pre-existing persistent disk, you'll need to do the following:\n- [Provision the existing persistent disk as a PersistentVolume.](#create_pv_pvc) \n- [Bind the PersistentVolume to a PersistentVolumeClaim.](#create_pv_pvc) \n- [Give the containers in the Pod access to the PersistentVolume.](#use_pv_in_Pod) \n### Create the PersistentVolume and PersistentVolumeClaim\nThere are several ways to bind a PersistentVolumeClaim to a specific PersistentVolume. For example, the following YAML manifest creates a new PersistentVolume and PersistentVolumeClaim, and then binds the claim to the volume using a `claimRef` , which ensures that the PersistentVolume can only be bound to that PersistentVolumeClaim.\nTo bind a PersistentVolume to a PersistentVolumeClaim, the `storageClassName` of the two resources must match, as well as `capacity` , `accessModes` , and `volumeMode` . You can omit the `storageClassName` , but you must specify `\"\"` to prevent Kubernetes from using the default StorageClass.\nThe `storageClassName` does not need to refer to an existing StorageClass object. If all you need is to bind the claim to a volume, you can use any name you want. However, if you need extra functionality configured by a StorageClass, like volume resizing, then `storageClassName` must refer to an existing StorageClass object.\nFor more details, see the [Kubernetes documentation on PersistentVolumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) .\n**Note:** The persistent disk must be in the same [zone](/compute/docs/regions-zones) as the cluster nodes.\n- Save the following YAML manifest:```\napiVersion: v1kind: PersistentVolumemetadata:\u00a0 name: PV_NAMEspec:\u00a0 storageClassName: \"STORAGE_CLASS_NAME\"\u00a0 capacity:\u00a0 \u00a0 storage: DISK_SIZE\u00a0 accessModes:\u00a0 \u00a0 - ReadWriteOnce\u00a0 claimRef:\u00a0 \u00a0 namespace: default\u00a0 \u00a0 name: PV_CLAIM_NAME\u00a0 csi:\u00a0 \u00a0 driver: pd.csi.storage.gke.io\u00a0 \u00a0 volumeHandle: DISK_ID\u00a0 \u00a0 fsType: FS_TYPE---apiVersion: v1kind: PersistentVolumeClaimmetadata:\u00a0 namespace: default\u00a0 name: PV_CLAIM_NAMEspec:\u00a0 storageClassName: \"STORAGE_CLASS_NAME\"\u00a0 volumeName: PV_NAME\u00a0 accessModes:\u00a0 \u00a0 - ReadWriteOnce\u00a0 resources:\u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 storage: DISK_SIZE\n```Replace the following:- ``: the name of your new PersistentVolume.\n- ``: the name of your new StorageClass.\n- ``: the size of your pre-existing persistent disk. For example,`500G`.\n- ``: the name of your new PersistentVolumeClaim.\n- ``: the identifier of your pre-existing persistent disk. The format is`projects/{project_id}/zones/{zone_name}/disks/{disk_name}`for [Zonal persistent disks](/kubernetes-engine/docs/concepts/persistent-volumes#pd-zones) , or`projects/{project_id}/regions/{region_name}/disks/{disk_name}`for [Regional persistent disks](/kubernetes-engine/docs/concepts/persistent-volumes#regional_persistent_disks) .\n- ``: the filesystem type. You can leave this as the default (`ext4`), or use`xfs`. If your clusters use a Windows Server node pool, you must change this to`NTFS`.\n- To apply the configuration and create the PersistentVolume and PersistentVolumeClaim resources, run the following command:```\nkubectl apply -f FILE_PATH\n```Replace `` with the path to the YAML file.\n### Use the PersistentVolume in a Pod\nAfter you create and bind the PersistentVolume and PersistentVolumeClaim, you can give a Pod's containers access to the volume by specifying values in the `volumeMounts` field.\nThe following YAML configuration creates a new Pod and a container running an `nginx` image, and then mounts the PersistentVolume on the Pod:\n```\nkind: PodapiVersion: v1metadata:\u00a0 name: POD_NAMEspec:\u00a0 volumes:\u00a0 \u00a0 - name: VOLUME_NAME\u00a0 \u00a0 \u00a0 persistentVolumeClaim:\u00a0 \u00a0 \u00a0 \u00a0 claimName: PV_CLAIM_NAME\u00a0 containers:\u00a0 \u00a0 - name: CONTAINER_NAME\u00a0 \u00a0 \u00a0 image: nginx\u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 80\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: \"http-server\"\u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - mountPath: \"/usr/share/nginx/html\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: VOLUME_NAME\n```\nReplace the following:\n- ``: the name of your new Pod.\n- ``: the name of the volume.\n- ``: the name of the PersistentVolumeClaim you created in the previous step.\n- ``: the name of your new container.\nApply the configuration:\n```\nkubectl apply -f FILE_PATH\n```\nReplace `` with the path to the YAML file.\nTo verify that the volume was mounted, run the following command:\n```\nkubectl describe pods POD_NAME\n```\nIn the output, check that the PersistentVolumeClaim was mounted:\n```\n...\nVolumes:\n VOLUME_NAME:\n Type:  PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)\n ClaimName: PV_CLAIM_NAME\n ReadOnly: false\nEvents:\n Type Reason     Age From      Message\n ---- ------     ---- ----      ------ Normal Scheduled    29s default-scheduler  Successfully assigned default/POD_NAME to gke-cluster-1-default-pool-d5cde866-o4g4\n Normal SuccessfulAttachVolume 21s attachdetach-controller AttachVolume.Attach succeeded for volume \"PV_NAME\"\n Normal Pulling     19s kubelet     Pulling image \"nginx\"\n Normal Pulled     19s kubelet     Successfully pulled image \"nginx\"\n Normal Created     18s kubelet     Created container CONTAINER_NAME\n Normal Started     18s kubelet     Started container CONTAINER_NAME\n```\n## Using a pre-existing disk in a StatefulSet\nYou can use pre-existing Compute Engine persistent disks in a [StatefulSet](/kubernetes-engine/docs/concepts/statefulset) using PersistentVolumes. The StatefulSet automatically generates a PersistentVolumeClaim for each replica. You can predict the names of the generated PersistentVolumeClaims and bind them to the PersistentVolumes using `claimRef` .\nIn the following example, you take two pre-existing persistent disks, create PersistentVolumes to use the disks, and then mount the volumes on a StatefulSet with two replicas in the default namespace.\n- Decide on a name for your new StatefulSet, a name for your PersistentVolumeClaim template, and the number of replicas in the StatefulSet.\n- Work out the names of the automatically generated PersistentVolumeClaims. The StatefulSet uses the following format for PersistentVolumeClaim names:```\nPVC_TEMPLATE_NAME-STATEFULSET_NAME-REPLICA_INDEX\n```Replace the following:- ``: the name of your new PersistentVolumeClaim template.\n- ``: the name of your new StatefulSet.\n- ``: the index of the StatefulSet's replica. For this example, use`0`and`1`.\n- Create the PersistentVolumes. You must create a PersistentVolume for each replica in the StatefulSet.- Save the following YAML manifest:```\napiVersion: v1kind: PersistentVolumemetadata:\u00a0 name: pv-ss-demo-0spec:\u00a0 storageClassName: \"STORAGE_CLASS_NAME\"\u00a0 capacity:\u00a0 \u00a0 storage: DISK1_SIZE\u00a0 accessModes:\u00a0 \u00a0 - ReadWriteOnce\u00a0 claimRef:\u00a0 \u00a0 namespace: default\u00a0 \u00a0 name: PVC1_NAME\u00a0 csi:\u00a0 \u00a0 driver: pd.csi.storage.gke.io\u00a0 \u00a0 volumeHandle: DISK1_ID\u00a0 \u00a0 fsType: FS_TYPE\u00a0---apiVersion: v1kind: PersistentVolumemetadata:\u00a0 name: pv-ss-demo-1spec:\u00a0 storageClassName: \"STORAGE_CLASS_NAME\"\u00a0 capacity:\u00a0 \u00a0 storage: DISK2_SIZE\u00a0 accessModes:\u00a0 \u00a0 - ReadWriteOnce\u00a0 claimRef:\u00a0 \u00a0 namespace: default\u00a0 \u00a0 name: PVC2_NAME\u00a0 csi:\u00a0 \u00a0 driver: pd.csi.storage.gke.io\u00a0 \u00a0 volumeHandle: DISK2_ID\u00a0 \u00a0 fsType: FS_TYPE\n```Replace the following:- `` `and` ``: the sizes of your pre-existing persistent disks.\n- `` `and` ``: the identifiers of your pre-existing persistent disks.\n- `` `and` ``: the names of the automatically generated PersistentVolumeClaims.\n- ``: the name of your StorageClass.\n- Apply the configuration:```\nkubectl apply -f FILE_PATH\n```Replace `` with the path to the YAML file.\n- [Create a StatefulSet](/kubernetes-engine/docs/how-to/stateful-apps#creating_a_statefulset) using the values you chose in step 1. Ensure that the storage you specify in the `volumeClaimTemplates` is less than or equal to the total capacity of your PersistentVolumes.- Save the following YAML manifest:```\napiVersion: apps/v1kind: StatefulSetmetadata:\u00a0 name: STATEFULSET_NAMEspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: nginx\u00a0 serviceName: \"nginx\"\u00a0 replicas: 2\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: nginx\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 terminationGracePeriodSeconds: 10\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: nginx\u00a0 \u00a0 \u00a0 \u00a0 image: registry.k8s.io/nginx-slim:0.8\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 80\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: web\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - name: PVC_TEMPLATE_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /usr/share/nginx/html\u00a0 volumeClaimTemplates:\u00a0 - metadata:\u00a0 \u00a0 \u00a0 name: PVC_TEMPLATE_NAME\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 accessModes: [ \"ReadWriteOnce\" ]\u00a0 \u00a0 \u00a0 storageClassName: \"STORAGE_CLASS_NAME\"\u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 storage: 100Gi\n```Replace the following:- ``: the name of your new StatefulSet.\n- ``: the name of your new PersistentVolumeClaim template.\n- ``: the name of your StorageClass.\n **Note:** Make sure that your StatefulSet name and PersistentVolumeClaim name match the values you decided in step 1.\n- Apply the configuration:```\nkubectl apply -f FILE_PATH\n```Replace `` with the path to the YAML file.\n## What's next\n- [Learn how to deploy a stateful application](/kubernetes-engine/docs/how-to/stateful-apps) .", "guide": "Google Kubernetes Engine (GKE)"}