{"title": "Google Kubernetes Engine (GKE) - Gateway", "url": "https://cloud.google.com/kubernetes-engine/docs/concepts/gateway-api", "abstract": "# Google Kubernetes Engine (GKE) - Gateway\nThis page describes the Google Kubernetes Engine (GKE) implementation of the [Kubernetes Gateway API](https://gateway-api.sigs.k8s.io/) using the [GKE Gateway controller](#gateway_controller) .\nThe Gateway API is an open source standard for service networking. The Gateway API evolves the Ingress resource and improves upon it in the following ways:\n- **Role-oriented:** Gateway is composed of API resources that correspond to the organizational roles of cluster operator, developer, and infrastructure provider. This allows cluster operators to define how shared infrastructure can be used by many different and non-coordinating developer teams.\n- **Portable:** The Gateway API is an open source standard with many implementations. It's designed by using the concept of flexible conformance, which promotes a highly portable core API (like Ingress) that still has the flexibility and extensibility to support native capabilities of the environment and implementation. This enables the concepts and core resources to be consistent across implementations and environments, reducing complexity and increasing user familiarity.\n- **Expressive:** The Gateway API resources provide built-in capabilities for header-based matching, traffic weighting, and other capabilities that are only possible in Ingress through custom annotations.", "content": "## Gateway API resources\nThe Gateway API is a role-oriented resource model, designed for the personas who interact with Kubernetes networking. As shown by the following diagram, this model enables different non-coordinating service owners to share the same underlying network infrastructure safely in a way that centralizes policy and control for the platform administrator.\nThe Gateway API contains the following resource types:\n- **GatewayClass** : Defines a cluster-scoped resource that's a template for creating load balancers in a cluster. GKE provides GatewayClasses that can be used in GKE clusters.\n- **Gateway** : Defines where and how the load balancers listen for traffic. Cluster operators create Gateways in their clusters based on a GatewayClass. GKE creates load balancers that implement the configuration defined in the Gateway resource.\n- **HTTPRoute** : Defines protocol-specific rules for routing requests from a Gateway to Kubernetes services. GKE supports HTTPRoutes for HTTP(S)-based traffic routing. Application developers create HTTPRoutes to expose their HTTP applications using Gateways.\n- **Policy** : Defines a set of implementation-specific characteristics of a Gateway resource. You can attach a policy to a Gateway, a Route, or a Kubernetes Service.\n### GatewayClass\nA GatewayClass is a resource that defines a template for HTTP(S) (level 7) load balancers in a Kubernetes cluster. GKE provides GatewayClasses as cluster-scoped resources. Cluster operators specify a GatewayClass when creating Gateways in their clusters.\nThe different GatewayClasses correspond to different [Google Cloud loadbalancers](/load-balancing/docs/load-balancing-overview) . When you create a Gateway based on a GatewayClass, a corresponding load balancer is created to implement the specified configuration.\nSome GatewayClasses support multi-cluster load balancing.\nThe following table lists the GatewayClasses available in GKE clusters and their underlying load balancer type. For complete details on the GatewayClasses, see the [GatewayClass capabilities andspecifications](/kubernetes-engine/docs/how-to/gatewayclass-capabilities) .\n| GatewayClass name     | Description                           |\n|:------------------------------------|:---------------------------------------------------------------------------------------------------------------------|\n| gke-l7-global-external-managed  | Global external Application Load Balancer(s) built on the global external Application Load Balancer     |\n| gke-l7-regional-external-managed | Regional external Application Load Balancer(s) built on the regional external Application Load Balancer    |\n| gke-l7-rilb       | Internal Application Load Balancer(s) built on the internal Application Load Balancer        |\n| gke-l7-gxlb       | Global external Application Load Balancer(s) built on the classic Application Load Balancer       |\n| gke-l7-global-external-managed-mc | Multi-cluster Global external Application Load Balancer(s) built on the global external Application Load Balancer |\n| gke-l7-regional-external-managed-mc | Multi-cluster Regional external Application Load Balancer(s) built on the global external Application Load Balancer |\n| gke-l7-rilb-mc      | Multi-cluster Internal Application Load Balancer(s) built on the internal Application Load Balancer     |\n| gke-l7-gxlb-mc      | Multi-cluster Global external Application Load Balancer(s) built on the classic Application Load Balancer   |\n| asm-l7-gxlb       | Global external Application Load Balancer(s) built on Anthos Service Mesh           |\nEach GatewayClass is subject to the limitations of the underlying load balancer.\n**Note:** When considering the deployment of a Global external Application Load Balancer, we do recommend to use the `gke-l7-global-external-managed(-mc)` GatewayClasses over the `gke-l7-gxlb(-mc)` GatewayClasses to benefit from the advanced security and [trafficmanagement](/kubernetes-engine/docs/concepts/traffic-management) capabilities. To learn more about the different features supported with each GatewayClass, see [GatewayClass capabilities](/kubernetes-engine/docs/how-to/gatewayclass-capabilities) .\n### Gateway\nCluster operators create Gateways to define where and how the load balancers listen for traffic. Gateways take their behavior (that is, how they are implemented) from their associated GatewayClass.\nThe Gateway specification includes the GatewayClass for the Gateway, which ports and protocols to listen on, and which Routes can bind to the Gateway. A Gateway selects routes based on the Route metadata; specifically the kind, namespace, and labels of Route resources.\nFor an example of deploying a Gateway, see [DeployingGateways](/kubernetes-engine/docs/how-to/deploying-gateways) .\nFor an example of deploying a multi-cluster Gateway, see [Deploying multi-clusterGateways](/kubernetes-engine/docs/how-to/deploying-multi-cluster-gateways) .\n### HTTPRoute\nAn HTTPRoute defines how HTTP and HTTPS requests received by a Gateway are directed to Services. Application developers create HTTPRoutes to expose their applications through Gateways.\nAn HTTPRoute defines which Gateways it can route traffic from, which Services to route to, and rules that define what traffic the HTTPRoute matches. Gateway and Route binding is bidirectional, which means that both resources must select each other for them to bind. HTTPRoutes can match requests based on details in the request header.\n### Policy\nA Policy defines characteristics of a Gateway resource, typically implementation-specific, that cluster operators can attach to a Gateway, a Route, or a Kubernetes Service. A Policy defines how the underlying Google Cloud infrastructure should function.\nA Policy is typically attached to a namespace and can reference a resource in the same namespace and access is granted using RBAC. The hierarchical nature of the Gateway API lets you to attach a Policy to a top resource (Gateway) in a namespace, and have all the resources underneath in different namespaces receive the characteristics of that policy.\nThe GKE Gateway controller supports the following Policies:\n- `HealthCheckPolicy`: defines the parameters and behavior of the health check used to check the health status of the backend Pods.\n- `GCPGatewayPolicy`: defines specific parameters of the frontend of the Google Cloud load balancer. This is similar to a`FrontendConfig`for an Ingress resource.\n- `GCPBackendPolicy`: defines how the backend services of the load balancer should distribute the traffic to the endpoints. This is similar to a`BackendConfig`for an Ingress resource.\n**Note:** Google Cloud has replaced the `LbPolicy` policy with the `GCPBackendPolicy` policy. The `LbPolicy` is still supported, but with no additional attributes.\n## Gateway ownership and usage patterns\nGateway and Route resources provide flexibility in how they are owned and deployed within an organization. This means that a single load balancer can be deployed and managed by an infrastructure team, but routing under a particular domain or path can be delegated to another team in another Kubernetes Namespace. The GKE Gateway controller supports multi-tenant usage of a load balancer, shared across Namespaces, clusters, and regions. Gateways also don't have to be shared if more distributed ownership is required. The following are some of the most common usage patterns for Gateways in GKE.\n### Self-managed Gateway\nA single owner can deploy a Gateway and Route just for their applications and use them exclusively. Gateways and Routes deployed in this manner are similar to Ingress. The following diagram shows two different service owners who deploy and manage their own Gateways. Similar to Ingress, each Gateway corresponds to its own unique IP address and load balancer. TLS, routing, and other policies are fully controlled by the service owner.\nThis usage pattern is common for Ingress but is challenging to scale across many teams because of the lack of shared resources. The Gateway API resource model enables following usage patterns which provide a spectrum of options for distributed control and ownership.\n### Platform-managed Gateway per Namespace\nSeparation between Gateway and Route resources lets platform administrators control Gateways on behalf of service owners. Platform admins can deploy a Gateway per Namespace or team, giving that Namespace exclusive access to use the Gateway. This gives the service owner full control over the routing rules without any risk of conflict from other teams. This lets the platform administrator control aspects such as IP allocation, port exposure, protocols, domains, and TLS. Platform admins can also decide which kinds of Gateways are available to teams, such as internal or external Gateways. This usage pattern creates a clean separation of responsibilities between different roles.\n[Cross-Namespace routing](https://gateway-api.sigs.k8s.io/guides/multiple-ns/) is what lets Routes to attach to Gateways across Namespace boundaries. Gateways can restrict from which Namespaces Routes can attach. Similarly, Routes specify the Gateways that they attach to, but they can only attach to a Gateway that has permitted the Route's Namespace. This [bi-directional attachment](https://gateway-api.sigs.k8s.io/concepts/api-overview/#attaching-routes-to-gateways) provides each side with flexible controls that enable this diversity of usage patterns.\nIn the following diagram, the platform administrator has deployed a Gateway for exclusive access for each Namespace. For example, the `store` Gateway is configured so that only Routes from the `store` Namespace can attach to it. Each Gateway represents a unique, load balanced IP address and so it lets each team deploy any number of Routes against the Gateway for any domains or routes it chooses.### Shared Gateway per cluster\nSharing Gateways across Namespaces offers an even more centralized form of ownership to platform administrators. This lets different service owners, running in different Namespaces, share the same IP address, DNS domain, certificates, or paths for fine grained routing between services. Gateways provide control to platform administrators over which Namespaces can route for a specific domain. This is similar to the previous example except Gateways permit Route attachment from more than one Namespace.\nIn the following diagram, the platform administrator has deployed two Gateways into the `infra` Namespace. The `external` Gateway permits Routes from the `web` and `mobile` Namespaces to attach to the Gateway. Routes from the `accounts` Namespace cannot use the `external` Gateway because the `accounts` Namespace is only for internal services. The `internal` Gateway lets internal clients communicate privately within the VPC using private IP addresses.\nThe `m.example.com` domain is delegated to the `mobile` Namespace which lets mobile service owners configure any routing rules they need under the `m.example.com` domain. This gives the service owners a greater degree of control for introducing new API endpoints and controlling traffic without requesting a change from administrators.\n### Shared Gateway per Fleet\nUsing [multi-cluster Gateways](/kubernetes-engine/docs/how-to/deploying-multi-cluster-gateways) , a Gateway can be shared across both Namespaces, clusters, and regions. Large organizations with geographically distributed apps might benefit from multi-cluster Gateways because they can granularly control global traffic while also delegating routing ownership. Similar to the previous examples, a platform administrator manages the Gateway and delegates routing. The major addition to this use case is that Routes reference multi-cluster Services, which are deployed across clusters. Traffic can be routed in an explicit manner, traffic to `store.example.com/us` goes to `gke-us` Pods, or in an implicit manner, traffic to `example.com/*` gets routed to the closest cluster to the client. This flexibility lets service owners define the optimal routing strategy for their application.\n## GKE Gateway controller\nThe GKE Gateway controller is Google's implementation of the Gateway API for Cloud Load Balancing. Similar to the GKE Ingress controller, the Gateway controller watches a Kubernetes API for Gateway API resources and reconciles Cloud Load Balancing resources to implement the networking behavior specified by the Gateway resources.\nThere are two versions of the GKE Gateway controller:\n- **Single-cluster** : manages single-cluster Gateways for a single GKE cluster.\n- **Multi-cluster:** manages multi-cluster Gateways for one or more GKE clusters.\nBoth Gateway controllers are Google-hosted controllers that watch the Kubernetes API for GKE clusters. Unlike the GKE Ingress controller, the Gateway controllers are not hosted on GKE control planes or in the user project, enabling them to be more scalable and robust. Both Gateway controllers are Generally Available.\nThey sit out of band from traffic and manage various data planes that process traffic. The following diagram shows the architecture of the single-cluster and multi-cluster GKE Gateway controllers. The underlying controller that is used depends on the GatewayClass of the deployed Gateway.\n| Controller    | Single-cluster Gateway controller                      | Multi-cluster Gateway controller                        |\n|:-------------------------|:------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------|\n| Managed by    | Google Cloud                           | Google Cloud                             |\n| Cluster scope   | Single cluster Gateways                         | Multi-cluster Gateways                           |\n| Deployment location  | Deployed regionally in the same region as its GKE cluster.                | Deployed globally across multiple Google Cloud regions.                  |\n| How to enable   | Enabled by default in GKE.                        | Enabled through the Multi Cluster Ingress API and registration into a fleet. See Enabling multi-cluster Gateways.    |\n| Supported GatewayClasses | gke-l7-global-external-managed GA gke-l7-regional-external-managed GA gke-l7-rilb GA gke-l7-gxlb GA asm-l7-gxlb Preview | gke-l7-global-external-managed-mc GA gke-l7-regional-external-managed-mc GA gke-l7-rilb-mc GA gke-l7-gxlb-mc GA gke-td Preview |\nYou can use multiple Gateway controllers, including controllers not provided by Google, in a GKE cluster simultaneously. Every GatewayClass is supported by one and only one Gateway controller, which enables single and multi-cluster load balancing to be used simultaneously.\n## Ingress and Gateway\n### Comparison of Ingress and Gateway\nGateway and Ingress are both open source standards for routing traffic. Gateway was designed by the Kubernetes community, drawing on lessons learned from the Ingress and the service mesh ecosystems. Gateway is an evolution of Ingress that provides the same function, delivered as a superset of the Ingress capabilities. Both can be used simultaneously without conflict, though over time Gateway and Route resources will deliver more capabilities not available in Ingress, compelling users to start using Gateway where they might have previously used Ingress.\nIn GKE all Ingress resources are directly convertible to Gateway and HTTPRoute resources. A single Ingress corresponds to both a Gateway (for frontend configuration) and an HTTPRoute (for routing configuration). The following example shows what the corresponding Gateway and HTTPRoute configuration looks like. Note that the Gateway and HTTPRoute resources can be created separately, also by different users. Gateways can have many Routes and a Route can also attach to more than one Gateway. The relationships between Gateways and Routes is discussed in [Gateway usage patterns](#usage-patterns) .\n```\napiVersion: networking.k8s.io/v1kind: Ingressmetadata:\u00a0 name: my-ingress\u00a0 annotations:\u00a0 \u00a0 kubernetes.io/ingress.class: \"gce-internal\"spec:\u00a0 rules:\u00a0 - host: \"example.com\"\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: Prefix\u00a0 \u00a0 \u00a0 \u00a0 path: /\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: site\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 80\u00a0 \u00a0 \u00a0 - pathType: Prefix\u00a0 \u00a0 \u00a0 \u00a0 path: /shop\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: store\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 80\n```\n```\napiVersion: gateway.networking.k8s.io/v1beta1kind: Gatewaymetadata:\u00a0 name: my-gatewayspec:\u00a0 gatewayClassName: gke-l7-rilb\u00a0 listeners:\u00a0 - name: http\u00a0 \u00a0 protocol: HTTP\u00a0 \u00a0 port: 80\u00a0 \u00a0 allowedRoutes:\u00a0 \u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - kind: HTTPRoute\n```\n```\napiVersion: gateway.networking.k8s.io/v1beta1kind: HTTPRoutemetadata:\u00a0 name: my-routespec:\u00a0 parentRefs:\u00a0 - name: my-gateway\u00a0 hostnames:\u00a0 - \"example.com\"\u00a0 rules:\u00a0 - matches:\u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 value: /\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: site\u00a0 \u00a0 \u00a0 port: 80\u00a0 - matches:\u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 value: /shop\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: store\u00a0 \u00a0 \u00a0 port: 80\n```\n## Integrating the Gateway API with Service Meshes\nYou can configure a Traffic Director service mesh using the Gateway API. This enables service-to-service communications, traffic management, global load balancing, and security policy enforcement for service mesh use cases. For complete information on using Traffic Director with the Gateway API, including deployment setup guides, see [Traffic Director GKE service mesh overview](/traffic-director/docs/gke-gateway-overview) .\n## Pricing\nAll Compute Engine resources deployed through the Gateway controllers are charged against the project in which your GKE clusters reside. The single-cluster Gateway controller is offered at no additional charge as a part of GKE Standard and Autopilot pricing. Pricing for multi-cluster Gateways is described in the [Multi Cluster Ingress and Gateway pricing page](/kubernetes-engine/pricing#multi-cluster-ingress) .\n## What's next\n- Learn how to [Configure Gateway resources using Policies](/kubernetes-engine/docs/how-to/configure-gateway-resources) \n- Learn about [Deploying Gateways](/kubernetes-engine/docs/how-to/deploying-gateways) .\n- Learn about [Deploying multi-cluster Gateways](/kubernetes-engine/docs/how-to/deploying-multi-cluster-gateways) .\n- For complete information on using Traffic Director with the Gateway API, see [Traffic Director GKE service mesh overview](/traffic-director/docs/gke-gateway-overview) .", "guide": "Google Kubernetes Engine (GKE)"}