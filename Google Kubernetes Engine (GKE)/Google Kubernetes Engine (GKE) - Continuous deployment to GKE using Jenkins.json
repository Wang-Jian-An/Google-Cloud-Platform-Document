{"title": "Google Kubernetes Engine (GKE) - Continuous deployment to GKE using Jenkins", "url": "https://cloud.google.com/kubernetes-engine/docs/archive/continuous-delivery-jenkins-kubernetes-engine?hl=zh-cn", "abstract": "# Google Kubernetes Engine (GKE) - Continuous deployment to GKE using Jenkins\nLast reviewed 2023-02-03 UTC\n**Warning:** This page is **archived** and is not actively maintained. The commands on this page might not work and could cause disruptions to your cluster.\nThis tutorial shows you how to set up a continuous delivery pipeline using Jenkins and Google Kubernetes Engine (GKE), as described in the following diagram.", "content": "## Objectives\n- Understand a sample application.\n- Deploy an application to GKE.\n- Upload code to Cloud Source Repositories.\n- Create deployment pipelines in Jenkins.\n- Deploy development environments.\n- Deploy a canary release.\n- Deploy production environments.\n## CostsThis tutorial uses billable components of Google Cloud, including:- Compute Engine\n- Google Kubernetes Engine\n- Cloud Source Repositories\n- Cloud Build\nUse the [pricing calculator](/products/calculator#id=7ecbf600-bb93-4d6d-8381-d986f33dc9a0) to generate a cost estimate based on your projected usage for this tutorial. ## Before you begin\n## Preparing your environment\n- Complete the [Setting up Jenkins on GKE tutorial](/kubernetes-engine/docs/archive/jenkins-on-kubernetes-engine-tutorial) . Ensure that you have a working Jenkins install running in GKE.\n- In Cloud Shell, clone the sample code:```\ncd ~/git clone https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes\n```\n- Go to the sample app directory:```\ncd ~/continuous-deployment-on-kubernetes/sample-app\n```\n- Apply the `cluster-admin` role to the Jenkins service account:```\nkubectl create clusterrolebinding jenkins-deploy \\\u00a0 \u00a0 --clusterrole=cluster-admin --serviceaccount=default:cd-jenkins\n```In this tutorial, the Jenkins service account needs `cluster-admin` permissions so that it can create Kubernetes namespaces and any other resources that the app requires. For production use, you should catalog the individual permissions necessary and apply them to the service account individually.\n## Understanding the applicationYou'll deploy the sample application, `gceme` , in your continuous deployment pipeline. The application is written in the Go language, and is located in the repository's `sample-app` directory. When you run the `gceme` binary on a Compute Engine instance, the app displays the instance's metadata in an info card.\n \nThe application mimics a microservice by supporting two operation modes:- In backend mode, `gceme` listens on port 8080 and returns Compute Engine instance metadata in JSON format.\n- In frontend mode, `gceme` queries the backend `gceme` service, and renders the resulting JSON in the user interface. \nThe frontend and backend modes support two additional URLs:- `/version`prints the running version.\n- `/healthz`reports the application's health. In frontend mode, the health displays as`OK`if the backend is reachable.\n## Building the sample app\n- Build the sample app by running the following commands:```\nexport PROJECT_ID=$(gcloud info --format='value(config.project)')find . -type f -name \"*\" -exec sed -i 's|gcr.io/cloud-solutions-images/gceme:1.0.0|gcr.io/'\"${PROJECT_ID}\"'/gceme:1.0.0|g' {} +gcloud builds submit --tag gcr.io/${PROJECT_ID}/gceme:1.0.0\n```\n## Deploying the sample app to KubernetesDeploy the `gceme` frontend and backend to Kubernetes using manifest files that describe the deployment environment. The files use a default image that is updated later in this tutorial.\nDeploy the applications into two environments.- Production. The live site that your users access.\n- Canary. A smaller-capacity site that receives a percentage of your user traffic. Use this environment to sanity check your software with live traffic before it's released to the production environment.\nFirst, deploy your application into the production environment to seed the pipeline with working code.- Create the Kubernetes namespace to logically isolate the production deployment:```\nkubectl create ns production\n```\n- Create the canary and production deployments and services:```\nkubectl --namespace=production apply -f k8s/productionkubectl --namespace=production apply -f k8s/canarykubectl --namespace=production apply -f k8s/services\n```\n- Scale up the production environment frontends:```\nkubectl --namespace=production scale deployment gceme-frontend-production --replicas=4\n```\n- Retrieve the external IP address for the production services. It can take several minutes before you see the load balancer IP address.```\nkubectl --namespace=production get service gceme-frontend\n```When the process completes, the external IP address is displayed in the `EXTERNAL-IP` column.```\nNAME    TYPE   CLUSTER-IP  EXTERNAL-IP PORT(S)  AGE\ngceme-frontend LoadBalancer 10.35.254.91 35.196.48.78 80:31088/TCP 1m\n```If the external IP address does not appear, wait a few minutes and repeat the previous step until the external IP address is shown.\n- After the external IP address appears, store the frontend service load balancer IP address in an environment variable:```\nexport FRONTEND_SERVICE_IP=$(kubectl get -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\" \u00a0--namespace=production services gceme-frontend)\n```\n- Confirm that both services are working by going to the frontend external IP address in your browser.\n- Poll the production endpoint's `/version` URL so you can observe rolling updates in the next section:```\nwhile true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; \u00a0done\n```\n- Press `Ctrl+C` to exit the loop.\n## Creating a repository to host the sample app source codeNext, create a copy of the `gceme` sample app and push it to [Cloud Source Repositories](/source-repositories/docs) .- Create the repository in Cloud Source Repositories:```\ngcloud services enable sourcerepo.googleapis.comgcloud source repos create gceme\n```\n- Initialize the local Git repository:```\nrm -rf ../.gitgit config --global init.defaultBranch maingit initgit config credential.helper gcloud.shexport PROJECT_ID=$(gcloud config get-value project)git remote add origin https://source.developers.google.com/p/$PROJECT_ID/r/gceme\n```\n- Set the username and email address for your Git commits in this repository to the values from your logged-in account:```\ngit config --global user.email $(gcloud config list account --format \"value(core.account)\")git config --global user.name $(gcloud config list account --format \"value(core.account)\")\n```\n- Add, commit, and push the files:```\ngit add .git commit -m \"Initial commit\"git push origin main\n```\n## Create a service accountIn this section, you create a service account that Jenkins will use to access your Git repository and execute deployments to GKE.- Create the service account and grant source and GKE roles to it.```\nexport SA=jenkins-saexport SA_EMAIL=${SA}@${PROJECT_ID}.iam.gserviceaccount.comgcloud iam service-accounts create $SAgcloud projects add-iam-policy-binding $PROJECT_ID \\\u00a0 --member serviceAccount:$SA_EMAIL \\\u00a0 --role roles/source.writergcloud projects add-iam-policy-binding $PROJECT_ID \\\u00a0 --member serviceAccount:$SA_EMAIL \\\u00a0 --role roles/container.developer\n```\n- Create and download a JSON service account key for your newly created service account:```\ngcloud iam service-accounts keys create ~/jenkins-gke-key.json --iam-account $SA_EMAIL\n```Take note of where the file was created, because you upload it to Jenkins in a later step.For more information about downloading a service account key, see [Create a service account key](/iam/docs/creating-managing-service-account-keys#creating) .\n## Open the Jenkins web user interface\n- If you haven't done so already, set up port forwarding to enable access to the Jenkins web UI:```\nexport POD_NAME=$(kubectl get pods --namespace default -l \"app.kubernetes.io/component=jenkins-main\" -l \"app.kubernetes.io/instance=cd-jenkins\" -o jsonpath=\"{.items[0].metadata.name}\")kubectl port-forward $POD_NAME 8080:8080 >> /dev/null 2>&1 &\n```\n- Open the Jenkins user interface, click **Web Preview** in Cloud Shell, and click **Preview on port 8080** .\n## Configure Jenkins Cloud for Kubernetes\n- In the Jenkins user interface, select **Manage Jenkins > Manage nodes and clouds** .\n- Click **Configure Clouds** in the left navigation pane.\n- Click **Add a new cloud** and select **Kubernetes** .\n- Click **Kubernetes Cloud Details** .\n- In the **Jenkins URL** field, enter the following value:`http://cd-jenkins:8080`\n- In the **Jenkins tunnel** field, enter the following value:`cd-jenkins-agent:50000`\n- Click **Save** .\n## Creating a pipelineUse Jenkins to define and run a pipeline for testing, building, and deploying your copy of `gceme` to your Kubernetes cluster.\n### Add your service account credentialsConfigure your credentials to allow Jenkins to access the code repository.- In the Jenkins user interface, select **Manage Jenkins > Manage Credentials** in the left navigation pane.\n- Click the **(global)** link \n- Click **Add Credentials** in the left navigation.\n- In the **Kind** menu, select **Google Service Account from private key** .\n- Enter your project name, and then select your JSON key that was created in a previous section.\n- Click **Create** .\nMake a note of the credential's name for use later in this tutorial.\n \n### Create a Jenkins jobNext, use the [Jenkins Pipeline](https://jenkins.io/solutions/pipeline/) feature to configure the build pipeline. Jenkins Pipeline files are written using a [Groovy-like syntax](http://www.groovy-lang.org/) .\nNavigate to your Jenkins user interface and follow these steps to configure a Pipeline job.- Click the **Jenkins** link in the top left of the interface.\n- Click the **New Item** link in the left navigation.\n- Name the project **sample-app** , choose the **Multibranch Pipeline** option, and then click **OK** .\n- In the **Branch Sources** section, click **Add Source** and select **git** .\n- Paste the **HTTPS clone URL** of your `sample-app` repository in Cloud Source Repositories into the **Project Repository** field. Replace `[PROJECT_ID]` with your project ID.```\nhttps://source.developers.google.com/p/[PROJECT_ID]/r/gceme\n```\n- From the **Credentials** drop-down list, select the name of the credentials that you created when adding your service account.\n- In the **Scan Multibranch Pipeline** section, select the **Periodically if not otherwise run** box. Set the **Interval** value to '1 minute'.\n- Click **Save** . \nAfter you complete these steps, a job named \"Branch indexing\" runs. This meta-job identifies the branches in your repository and ensures changes haven't occurred in existing branches. If you refresh Jenkins, the `main` branch displays this job.\nThe first run of the job fails until you make a few code changes in the next step.\n### Modify the pipeline definition\n- Create a branch for the canary environment called `canary` .```\ngit checkout -b canary\n```\n- Update the `Jenkinsfile` to replace `REPLACE_WITH_YOUR_PROJECT_ID` on line 2 with your project ID.```\nsed -i 's|REPLACE_WITH_YOUR_PROJECT_ID|'\"$PROJECT_ID\"'|' Jenkinsfile\n```\nThe Jenkinsfile container that defines that pipeline is written using the [Jenkins Pipeline Groovy syntax](https://jenkins.io/doc/book/pipeline/syntax/) . Using a Jenkinsfile allows an entire build pipeline to be expressed in a single file that lives alongside your source code. Pipelines support powerful features like parallelization and requiring manual user approval.## Deploying a canary releaseNow that your pipeline is configured properly, you can make a change to the `gceme` application and let your pipeline test, package, and deploy it.\nThe canary environment is set up as a [canary release](https://sre.google/workbook/canarying-releases/) . As such, your change is released to a small percentage of the pods behind the production load balancer. You accomplish this in Kubernetes by maintaining multiple deployments that share the same labels. For this application, the `gceme-frontend` services load balance across all pods that have the labels `app: gceme` and `role: frontend` . The `k8s/frontend-canary.yaml` canary manifest file sets the replicas to `1` and includes labels required for the `gceme-frontend` service.\nCurrently, you have 1 out of 5 of the frontend pods running the canary code while the other 4 are running the production code. This helps ensure that the canary code doesn't negatively affect users before rolling out to your full fleet of pods.- Open`html.go`and replace the two instances of`blue`with`orange`.\n- Open `main.go` and change the version number from `1.0.0` to `2.0.0` :```\nconst version string = \"2.0.0\"\n```\n- Next, add and commit those files to your local repository:```\ngit add Jenkinsfile html.go main.gogit commit -m \"Version 2\"\n```\n- Finally, push your changes to the remote Git server:```\ngit push origin canary\n```\n- After the change is pushed to the Git repository, navigate to the Jenkins user interface where you can see that your build started. \n- After the build is running, click the down arrow next to the build in the left navigation and select **Console Output** . \n- During execution, you may notice the build waiting for a while with the following message:```\nStill waiting to schedule task'Jenkins' doesn't have label 'sample-app'\n```This message means that Jenkins is waiting for GKE to create the pods needed for the build steps. You can watch the progress on the [GKE Workloads](https://console.cloud.google.com/kubernetes/workload/overview) page.\n- Track the output of the build. When the build finishes, poll the endpoint at `/version` :```\nwhile true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; \u00a0done\n```The version begins to change in some of the requests. You have now rolled out that change to a subset of users.Press `Ctrl+C` to exit the loop.\n- After the change is deployed to the canary environment, you can continue to roll it out to the rest of your users by merging the code with the `main` branch and pushing that to the Git server:```\ngit checkout maingit merge canarygit push origin main\n```\n- In approximately 1 minute, the `main` job in the `sample-app` folder kicks off. \n- Click the `main` link to show the pipeline steps, as well as pass/fail information and timing characteristics. \n- Poll the production URL to verify that the new version 2.0.0 has been rolled out and is serving requests from all users.```\nexport FRONTEND_SERVICE_IP=$(kubectl get -o jsonpath=\"{.status.loadBalancer.ingress[0].ip}\" --namespace=production services gceme-frontend)while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; \u00a0done\n```\nYou can look at the Jenkinsfile in the project to see the workflow. The Jenkinsfile is located at `https://source.cloud.google.com/[PROJECT_ID]/gceme/+/main:Jenkinsfile`## Deploying a development branchSometimes you need to work with nontrivial changes that can't be pushed directly to the canary environment. A development branch is a set of environments your developers use to test their code changes before submitting them for integration into the production environment. These environments are a scaled-down version of your application, but are deployed using the same mechanisms as the production environment.\nTo create a development environment from a feature branch, you can push the branch to the Git server and let Jenkins deploy your environment. In a development scenario, you wouldn't use a public-facing load balancer. To help secure your application you can use [kubectl proxy](https://kubernetes.io/docs/tasks/extend-kubernetes/http-proxy-access-api/) . The proxy authenticates itself with the Kubernetes API, and proxies requests from your local machine to the service in the cluster without exposing your service to the Internet.- In your first terminal window, create another branch and push it to the Git server:```\ngit checkout -b new-featuregit push origin new-feature\n```Open the Jenkins web UI and review the console output for the `new-feature` job. A new job is created and your development environment is in the process of being created. At the bottom of the console output of the job are instructions for accessing your environment.\n- After the build has completed, start the proxy in the background:```\nkubectl proxy &\n```\n- Verify that your application is accessible by using localhost:```\ncurl http://localhost:8001/api/v1/namespaces/new-feature/services/gceme-frontend:80/proxy/\n```\n- You can now push code to this branch to update your development environment. When you are done, merge your branch back into `canary` to deploy that code to the canary environment.```\ngit checkout canarygit merge new-featuregit push origin canary\n```\n- When you are confident that your code won't cause problems in the production environment, merge from the `canary` branch to the `main` branch to kick off the deployment:```\ngit checkout maingit merge canarygit push origin main\n```\n- When you are done with the development branch, delete it from the server and delete the environment from your Kubernetes cluster:```\ngit push origin :new-featurekubectl delete ns new-feature\n```\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Deleting the project\nThe easiest way to eliminate billing is to delete the project that you created for the tutorial.\nTo delete the project:\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n## What's next\n- Learn more about [Jenkins on GKE best practices](/kubernetes-engine/docs/archive/jenkins-on-kubernetes-engine) .\n- See the [setting up Jenkins on GKE tutorial](/kubernetes-engine/docs/archive/jenkins-on-kubernetes-engine-tutorial) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Google Kubernetes Engine (GKE)"}