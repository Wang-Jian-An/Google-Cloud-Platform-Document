{"title": "Google Kubernetes Engine (GKE) - Setting up a custom kube-dns Deployment", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/custom-kube-dns", "abstract": "# Google Kubernetes Engine (GKE) - Setting up a custom kube-dns Deployment\nThis page explains how to run a custom Deployment of kube-dns for Google Kubernetes Engine (GKE) Standard mode clusters. This page doesn't apply to GKE Autopilot, where Google manages kube-dns.\n**Caution:** If you run a custom Deployment of kube-dns, you must keep the kube-dns image up to date with security patches and updates. You can get the latest image from the kube-dns Deployment in the kube-system namespace.\n", "content": "## Overview\nTo configure kube-dns CPU, memory, and other parameters, you must run a custom Deployment and disable the Deployment that GKE provides. You can also run a custom Deployment of Core DNS or any other DNS provider that follows the [Kubernetes DNS specification](https://github.com/kubernetes/dns/blob/master/docs/specification.md) using the instructions on this page.\nTo learn more about how GKE implements service discovery, see [Service discovery and DNS](/kubernetes-engine/docs/concepts/service-discovery) .\n## Creating a custom Deployment\n- Create a Deployment manifest for kube-dns, Core DNS or other DNS provider.The following sample kube-dns manifest includes the `-q` flag to log the results of queries. Save the manifest as `custom-kube-dns.yaml` .```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: DNS_DEPLOYMENT_NAME\u00a0 namespace: kube-system\u00a0 annotations:\u00a0 \u00a0 deployment.kubernetes.io/revision: \"1\"\u00a0 \u00a0 k8s-app: kube-dnsspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 k8s-app: kube-dns\u00a0 strategy:\u00a0 \u00a0 rollingUpdate:\u00a0 \u00a0 \u00a0 maxSurge: 10%\u00a0 \u00a0 \u00a0 maxUnavailable: 0\u00a0 \u00a0 type: RollingUpdate\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 creationTimestamp: null\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 k8s-app: kube-dns\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: kubedns\u00a0 \u00a0 \u00a0 \u00a0 image: registry.k8s.io/dns/k8s-dns-kube-dns:1.17.3\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 limits:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: '170Mi'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: 100m\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: '70Mi'\u00a0 \u00a0 \u00a0 \u00a0 livenessProbe:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 httpGet:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path: /healthcheck/kubedns\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port: 10054\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 scheme: HTTP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 initialDelaySeconds: 60\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 timeoutSeconds: 5\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 successThreshold: 1\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 failureThreshold: 5\u00a0 \u00a0 \u00a0 \u00a0 readinessProbe:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 httpGet:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path: /readiness\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port: 8081\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 scheme: HTTP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 initialDelaySeconds: 3\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 timeoutSeconds: 5\u00a0 \u00a0 \u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 \u00a0 - --domain=cluster.local.\u00a0 \u00a0 \u00a0 \u00a0 - --dns-port=10053\u00a0 \u00a0 \u00a0 \u00a0 - --config-dir=/kube-dns-config\u00a0 \u00a0 \u00a0 \u00a0 - --v=2\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: PROMETHEUS_PORT\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"10055\"\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 10053\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: dns-local\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: UDP\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 10053\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: dns-tcp-local\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 10055\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: metrics\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - name: kube-dns-config\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /kube-dns-config\u00a0 \u00a0 \u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 allowPrivilegeEscalation: false\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 readOnlyRootFilesystem: true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 runAsUser: 1001\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 runAsGroup: 1001\u00a0 \u00a0 \u00a0 - name: dnsmasq\u00a0 \u00a0 \u00a0 \u00a0 image: registry.k8s.io/dns/k8s-dns-dnsmasq-nanny:1.17.3\u00a0 \u00a0 \u00a0 \u00a0 livenessProbe:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 httpGet:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path: /healthcheck/dnsmasq\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port: 10054\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 scheme: HTTP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 initialDelaySeconds: 60\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 timeoutSeconds: 5\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 successThreshold: 1\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 failureThreshold: 5\u00a0 \u00a0 \u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 \u00a0 - -v=2\u00a0 \u00a0 \u00a0 \u00a0 - -logtostderr\u00a0 \u00a0 \u00a0 \u00a0 - -configDir=/etc/k8s/dns/dnsmasq-nanny\u00a0 \u00a0 \u00a0 \u00a0 - -restartDnsmasq=true\u00a0 \u00a0 \u00a0 \u00a0 - --\u00a0 \u00a0 \u00a0 \u00a0 - -k\u00a0 \u00a0 \u00a0 \u00a0 - --cache-size=1000\u00a0 \u00a0 \u00a0 \u00a0 - --no-negcache\u00a0 \u00a0 \u00a0 \u00a0 - --dns-forward-max=1500\u00a0 \u00a0 \u00a0 \u00a0 - --log-facility=-\u00a0 \u00a0 \u00a0 \u00a0 - --server=/cluster.local/127.0.0.1#10053\u00a0 \u00a0 \u00a0 \u00a0 - --server=/in-addr.arpa/127.0.0.1#10053\u00a0 \u00a0 \u00a0 \u00a0 - --server=/ip6.arpa/127.0.0.1#10053\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 53\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: dns\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: UDP\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 53\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: dns-tcp\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: 150m\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: 20Mi\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - name: kube-dns-config\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /etc/k8s/dns/dnsmasq-nanny\u00a0 \u00a0 \u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 capabilities:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 drop:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - all\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - NET_BIND_SERVICE\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - SETGID\u00a0 \u00a0 \u00a0 - name: sidecar\u00a0 \u00a0 \u00a0 \u00a0 image: registry.k8s.io/dns/k8s-dns-sidecar:1.17.3\u00a0 \u00a0 \u00a0 \u00a0 livenessProbe:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 httpGet:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path: /metrics\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port: 10054\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 scheme: HTTP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 initialDelaySeconds: 60\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 timeoutSeconds: 5\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 successThreshold: 1\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 failureThreshold: 5\u00a0 \u00a0 \u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 \u00a0 - --v=2\u00a0 \u00a0 \u00a0 \u00a0 - --logtostderr\u00a0 \u00a0 \u00a0 \u00a0 - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local,5,SRV\u00a0 \u00a0 \u00a0 \u00a0 - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local,5,SRV\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 10054\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: metrics\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: 20Mi\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: 10m\u00a0 \u00a0 \u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 allowPrivilegeEscalation: false\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 readOnlyRootFilesystem: true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 runAsUser: 1001\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 runAsGroup: 1001\u00a0 \u00a0 \u00a0 dnsPolicy: Default\u00a0 \u00a0 \u00a0 restartPolicy: Always\u00a0 \u00a0 \u00a0 schedulerName: default-scheduler\u00a0 \u00a0 \u00a0 securityContext: {}\u00a0 \u00a0 \u00a0 serviceAccount: kube-dns\u00a0 \u00a0 \u00a0 serviceAccountName: kube-dns\u00a0 \u00a0 \u00a0 terminationGracePeriodSeconds: 30\u00a0 \u00a0 \u00a0 tolerations:\u00a0 \u00a0 \u00a0 - key: CriticalAddonsOnly\u00a0 \u00a0 \u00a0 \u00a0 operator: Exists\u00a0 \u00a0 \u00a0 volumes:\u00a0 \u00a0 \u00a0 - configMap:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 defaultMode: 420\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: kube-dns\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 optional: true\u00a0 \u00a0 \u00a0 \u00a0 name: kube-dns-config\n```Replace `` with a name for the custom kube-dns Deployment.\n- Apply the manifest to the cluster:```\nkubectl create -f custom-kube-dns.yaml\n```\n- Verify that the Pods are running:```\nkubectl get pods -n kube-system -l=k8s-app=kube-dns\n```The output is similar to the following, showing the custom kube-dns Pods:```\nNAME \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 READY \u00a0 STATUS \u00a0 \u00a0RESTARTS \u00a0 AGEcustom-kube-dns-5685645b44-kzs8w \u00a0 3/3 \u00a0 \u00a0 Running \u00a0 0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a022h\n```The new Deployment has the same selector as kube-dns, which means that Pods use the same kube-dns service IP address to communicate with the Pods running the custom kube-dns Deployment.After this step completes, you must follow the steps in the next section to scale down kube-dns.## Scaling down kube-dns\nDisable the kube-dns managed by GKE by scaling the kube-dns Deployment and autoscaler to zero using the following command:\n```\nkubectl scale deployment --replicas=0 kube-dns-autoscaler --namespace=kube-systemkubectl scale deployment --replicas=0 kube-dns --namespace=kube-system\n```\n## Creating a custom autoscaler\nIf your custom DNS requires autoscaling, you must configure and deploy a separate autoscaler. The kube-dns-autoscaler only scales the default kube-dns Deployment on the cluster. You also need to configure a custom ClusterRole for your autoscaler and add permissions to modify your custom kube-dns deployments.\n- Create a ClusterRole and Deployment manifest for the autoscaler and save the manifest as `custom-dns-autoscaler.yaml` :```\napiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:\u00a0 name: system:custom-dns-autoscalerroleRef:\u00a0 apiGroup: rbac.authorization.k8s.io\u00a0 kind: ClusterRole\u00a0 name: system:custom-dns-autoscalersubjects:- kind: ServiceAccount\u00a0 name: kube-dns-autoscaler\u00a0 namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata:\u00a0 name: system:custom-dns-autoscalerrules:- apiGroups:\u00a0 - \"\"\u00a0 resources:\u00a0 - nodes\u00a0 verbs:\u00a0 - list\u00a0 - watch- apiGroups:\u00a0 - apps\u00a0 resourceNames:\u00a0 - DNS_DEPLOYMENT_NAME\u00a0 resources:\u00a0 - deployments/scale\u00a0 verbs:\u00a0 - get\u00a0 - update- apiGroups:\u00a0 - \"\"\u00a0 resources:\u00a0 - configmaps\u00a0 verbs:\u00a0 - get\u00a0 - create---apiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: custom-dns-autoscaler\u00a0 namespace: kube-system\u00a0 labels:\u00a0 \u00a0 k8s-app: custom-dns-autoscalerspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 k8s-app: custom-dns-autoscaler\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 k8s-app: custom-dns-autoscaler\u00a0 \u00a0 \u00a0 annotations:\u00a0 \u00a0 \u00a0 \u00a0 seccomp.security.alpha.kubernetes.io/pod: 'docker/default'\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 priorityClassName: system-cluster-critical\u00a0 \u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 \u00a0 supplementalGroups: [ 65534 ]\u00a0 \u00a0 \u00a0 \u00a0 fsGroup: 65534\u00a0 \u00a0 \u00a0 nodeSelector:\u00a0 \u00a0 \u00a0 \u00a0 kubernetes.io/os: linux\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: autoscaler\u00a0 \u00a0 \u00a0 \u00a0 image: registry.k8s.io/cluster-proportional-autoscaler-amd64:1.7.1\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: \"20m\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: \"10Mi\"\u00a0 \u00a0 \u00a0 \u00a0 command:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - /cluster-proportional-autoscaler\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - --namespace=kube-system\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - --configmap=custom-dns-autoscaler\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - --target=Deployment/DNS_DEPLOYMENT_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - --default-params={\"linear\":{\"coresPerReplica\":256,\"nodesPerReplica\":16,\"preventSinglePointFailure\":true}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - --logtostderr=true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - --v=2\u00a0 \u00a0 \u00a0 tolerations:\u00a0 \u00a0 \u00a0 - key: \"CriticalAddonsOnly\"\u00a0 \u00a0 \u00a0 \u00a0 operator: \"Exists\"\u00a0 \u00a0 \u00a0 serviceAccountName: kube-dns-autoscaler\n```\n- Apply the manifest to the cluster:```\nkubectl create -f custom-dns-autoscaler.yaml\n```## What's next\n- Read an overview of how GKE provides [managed DNS](/kubernetes-engine/docs/concepts/service-discovery) .\n- Read [DNS for Services and Pods](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service) for a general overview of how DNS is used in Kubernetes clusters.", "guide": "Google Kubernetes Engine (GKE)"}