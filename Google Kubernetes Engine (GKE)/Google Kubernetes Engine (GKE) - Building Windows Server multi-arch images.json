{"title": "Google Kubernetes Engine (GKE) - Building Windows Server multi-arch images", "url": "https://cloud.google.com/kubernetes-engine/docs/tutorials/building-windows-multi-arch-images", "abstract": "# Google Kubernetes Engine (GKE) - Building Windows Server multi-arch images\n**Warning:** Windows Server Semi-Annual Channel (SAC) images aren't supported after August 9, 2022 because Microsoft is removing support for the SAC. For potential impact and migration instructions, refer to [Windows Server Semi-Annual Channel end of servicing](/kubernetes-engine/docs/deprecations/windows-server-sac) .\nThis tutorial demonstrates how to manage the versioning complexity of building images that target multiple Windows Server versions. Windows Server containers have [version compatibility requirements](/kubernetes-engine/docs/how-to/creating-a-cluster-windows#version_compatibility) that prevent containers from running on more than one Windows Server host version. However, Docker on Windows Server supports multi-arch (or multi-platform) container images that can run across multiple Windows Server versions.\nWith multi-arch images, you can upgrade your Google Kubernetes Engine (GKE) Windows Server node pools to your preferred Windows Server version without rebuilding the image and changing the Pod specs. For example: - GKE version 1.15 supports Windows Server 1809\n- GKE version 1.16 supports Windows Server 1909\nTo upgrade from one GKE version to a later version automatically, you must build multi-arch images for your Windows workloads. Building a multi-arch image involves building an image for each Windows Server version, and then building a manifest that references those images for each Windows Server version. You can build the images manually if you want full control over the image creation and build process. Alternatively, you can use Cloud Build to automatically build the Windows Server multi-arch images.", "content": "## Objectives\nIn this tutorial, you learn how to create Windows Server multi-arch images manually or by using Cloud Build.\n- Build the images manually:- Create 2 Docker images with different versions or types of Windows Server, for example Long-Term Servicing Channel (LTSC) and Semi-Annual Channel (SAC).\n- Create a Windows Server VM.\n- Create a manifest and push it to the registry.\n- Build the images using Cloud Build:- Prepare your environment by creating a project, enabling APIs, and granting permissions.\n- Create an application, Dockerfiles, and build files.\n- Run a command to build the image.## CostsIn this document, you use the following billable components of Google Cloud:- [Compute Engine](/compute/pricing) \n- [Artifact Registry](/artifact-registry/pricing) \n- [Cloud Build](/build/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .## Before you begin\nBefore you start, make sure that you have performed the following tasks:\n- [Install the Google Cloud CLI](/sdk/docs) to run`gcloud`commands.\n- [Install Docker](https://docs.microsoft.com/en-us/virtualization/windowscontainers/quick-start/set-up-environment?tabs=Windows-Server) to build containers.\n- [Install Go](https://golang.org/doc/install) to build Windows Server binaries.\n- This tutorial uses Artifact Registry as the repository. Ensure you have [created your Docker repository](/artifact-registry/docs/manage-repos) .\n **Note:** The `gcloud` commands in this tutorial assume you are using a Linux machine.## Building multi-arch images manually **Warning:** The instructions in this section make use of an [ experimental feature in Docker](https://docs.docker.com/engine/reference/commandline/manifest) which should not be used in production environments. Consider the implications of enabling this feature on your systems.\nBuilding multi-arch images manually provides you with the flexibility to build an image that includes any Windows Server versions that you need. To build a multi-arch image manually:- Create an LTSC 2019 Docker single-arch image. See details about creating Docker images in [Deploying a Windows Server application](/kubernetes-engine/docs/how-to/deploying-windows-app#create_a_windows_server_application_image_for_use_with_private_clusters) . For example,`us-docker.pkg.dev/my-project/docker-repo/foo:1.0-2019`.\n- Create an LTSC 2022 Docker single-arch image. For example,`us-docker.pkg.dev/my-project/docker-repo/foo:1.0-2022`\n- Create a SAC 20H2 Docker single-arch image. For example,`us-docker.pkg.dev/my-project/docker-repo/foo:1.0-20h2`.\n- Create a Windows Server VM, for example version 20H2. See the [Quickstart using a Windows Server VM](/compute/docs/create-windows-server-vm-instance) .\n- Use RDP to connect to the VM.\n- Open a PowerShell window to run the commands in the next steps.\n- Enable the `docker manifest` experimental feature. A Docker manifest is a list of images to push to a registry:```\nPS C:\\> $env:DOCKER_CLI_EXPERIMENTAL = 'enabled'\n```\n- Create the multi-arch manifest:```\ndocker manifest create `\u00a0 REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/foo:1.0 `\u00a0 REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/foo:1.0-2019 `\u00a0 REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/foo:1.0-2022 `\u00a0 REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/foo:1.0-20h2\n```\n- Push the newly created multi-arch image manifest to your Artifact Registry repository:```\n\u00a0docker manifest push `\u00a0 \u00a0REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/foo:1.0\n```\n- To ensure that your multi-arch image was built and pushed successfully, navigate to `` `-docker.pkg.dev/` `` `/` `` `/foo` and click on that image. You'll see the 3 images inside:- `foo:1.0-2019`\n- `foo:1.0-2022`\n- `foo:1.0-20h2`\n- `foo:1.0`\nNow you can refer to the multi-arch image `` `-docker.pkg.dev/` `` `/` `` `/foo:1.0` in your Pod specs. This will let you safely use auto-upgrade for your GKE Windows node pools.## Building multi-arch images using the Cloud Build gke-windows-builderTo ease the effort of the manual build steps, you can use the [gke-windows-builder](https://console.cloud.google.com/artifacts/docker/gke-windows-tools/us/docker-repo/gke-windows-builder) based on the [OSS gke-windows-builder](https://github.com/GoogleCloudPlatform/kubernetes-engine-windows-tools/tree/master/gke-windows-builder) . You can use the gke-windows-builder with Cloud Build to build the Windows Server multi-arch images automatically. GKE updates the builder to include new supported Windows SAC and LTSC versions when they are released. Another benefit of using the builder is that you don't have to create your own Windows VM with Powershell to build the images. The Windows VM is replaced by a Docker container that runs the commands for you inside Cloud Build.\nTo help you understand how the builder works, follow this example to build a \"hello world\" multi-arch image. These steps can be performed on Linux or Windows servers.\n### Preparing the environmentTo prepare your environment, complete the following steps:- Create a workspace directory on your work machine, for example:`~/gke-windows-builder/hello-world`.\n- Create or select a project for this tutorial.\n- Make sure that [billing is enabled](/billing/docs/how-to/modify-project) for your project.\n- Enable the Compute Engine, Cloud Build and Artifact Registry APIs for your project. The gke-windows-builder is invoked using Cloud Build, and the resulting multi-arch container images are pushed to Artifact Registry. Compute Engine is required for the builder to create and manage Windows Server VMs.```\ngcloud services enable compute.googleapis.com cloudbuild.googleapis.com \\\u00a0 artifactregistry.googleapis.com cloudbuild.googleapis.com\n```\n- Grant the following Identity and Access Management (IAM) roles to your Cloud Build service account by using the Google Cloud CLI:- Set variables:```\nexport PROJECT=$(gcloud info --format='value(config.project)')export MEMBER=$(gcloud projects describe $PROJECT --format 'value(projectNumber)')@cloudbuild.gserviceaccount.com\n```\n- Assign roles. These roles are required for the builder to create the Windows Server VMs, to copy the workspace to a Cloud Storage bucket, to configure the networks to build the Docker image and to push resulting image to Artifact Registry:```\ngcloud projects add-iam-policy-binding $PROJECT --member=serviceAccount:$MEMBER --role='roles/compute.instanceAdmin'gcloud projects add-iam-policy-binding $PROJECT --member=serviceAccount:$MEMBER --role='roles/iam.serviceAccountUser'gcloud projects add-iam-policy-binding $PROJECT --member=serviceAccount:$MEMBER --role='roles/compute.networkViewer'gcloud projects add-iam-policy-binding $PROJECT --member=serviceAccount:$MEMBER --role='roles/storage.admin'gcloud projects add-iam-policy-binding $PROJECT --member=serviceAccount:$MEMBER --role='roles/artifactregistry.writer'\n```\n- Add a firewall rule named `allow-winrm-ingress` to allow WinRM to connect to Windows Server VMs to run a Docker build: **Note:** The firewall rule name must be `allow-winrm-ingress` , as gke-windows-builder uses this particular name to check whether this firewall rule exists.```\ngcloud compute firewall-rules create allow-winrm-ingress --allow=tcp:5986 --direction=INGRESS\n```\n- Create a Docker repository in Artifact Registry for your project. If you have never used Docker repositories in Artifact Registry before, complete the [Quickstart for Docker](/artifact-registry/docs/docker/quickstart) first. Run this command to create your repository:```\ngcloud artifacts repositories create REPOSITORY \\\u00a0 --repository-format=docker --location=REGISTRY_REGION \\\u00a0 --description=\"Docker repository\"\n```Replace the following:- ``: a name such as`windows-multi-arch-images`.\n- ``: a valid [Artifact Registry location](/artifact-registry/docs/repo-locations) .\n### Creating the hello.exe binary in your workspaceFor this tutorial, create a simple \"hello world\" application, written in Go. The code for the sample app is [onGitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/tree/main/windows/windows-multi-arch) .- Clone the repository containing the sample code for this tutorial to your local machine by using the following commands:```\n\u00a0git clone https://github.com/GoogleCloudPlatform/kubernetes-engine-samples\u00a0cd kubernetes-engine-samples/windows/windows-multi-arch\n```\n- The `hello.go` file prints the words \"Hello World\": [  windows/windows-multi-arch/hello.go ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/windows/windows-multi-arch/hello.go) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/windows/windows-multi-arch/hello.go) ```\npackage mainimport \"fmt\"func main() {\u00a0 \u00a0 \u00a0 \u00a0 fmt.Println(\"Hello World!\")}\n```\n- Generate the `hello.exe` binary:```\nGOOS=windows go build hello.go\n```\nYou'll see the `hello.exe` binary in your workspace.\n### Creating a Dockerfile and build files in your workspaceIn this section you use a `Dockerfile` to build each Windows Server image and then use a build file to trigger the Cloud Build. The build combines the single-arch images into a multi-arch image.- The `Dockerfile` is a text document that contains instructions for Docker to build an image. The gke-windows-builder replaces the `WINDOWS_VERSION` with a specific Windows Server version to build the image for. For example, the builder will run `docker build -t multi-arch-helloworld:latest_20h2 --build-arg WINDOWS_VERSION=20H2 .` on Windows Server 20H2. [  windows/windows-multi-arch/Dockerfile ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/windows/windows-multi-arch/Dockerfile) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/windows/windows-multi-arch/Dockerfile) ```\nARG WINDOWS_VERSION=FROM mcr.microsoft.com/windows/servercore:${WINDOWS_VERSION}COPY hello.exe /hello.exeUSER ContainerUserENTRYPOINT [\"hello.exe\"]\n```\n- In the same directory that contains the `Dockerfile` , the `cloudbuild.yaml` file is your build config file. Replace and with the name and region for the Artifact Registry repository that you created in the previous step. At build time, Cloud Build automatically replaces `$PROJECT_ID` with your project ID. [  windows/windows-multi-arch/cloudbuild.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/windows/windows-multi-arch/cloudbuild.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/windows/windows-multi-arch/cloudbuild.yaml) ```\ntimeout: 3600ssteps:- name: 'us-docker.pkg.dev/gke-windows-tools/docker-repo/gke-windows-builder:latest'\u00a0 args:\u00a0 - --container-image-name\u00a0 # Replace <REGISTRY_REGION> and <REPOSITORY>.\u00a0 - '<REGISTRY_REGION>-docker.pkg.dev/$PROJECT_ID/<REPOSITORY>/multiarch-helloworld:latest'\u00a0 # Specify specific variants of images to be built. Or, remove the following 2 lines to default to all available variants.\u00a0 - --versions\u00a0 - '20H2,ltsc2019'\n```\n### Building the imageNow you can build the image and view your logs to verify a successful build.- To build the image, run the following command:```\ngcloud builds submit --config=cloudbuild.yaml .\n``` **Note:** This command takes several minutes to complete.\n- You'll see logs like the following example. The last line in the log shows that the build succeeded:```\nCreating temporary tarball archive of 2 file(s) totalling 492 bytes before compression.\nUploading tarball of [.] to [gs://PROJECT_ID_cloudbuild/source/1600082502.509759-b949721a922d462c94a75da9be9f1181.tgz]\nCreated [https://cloudbuild.googleapis.com/v1/projects/PROJECT_ID/builds/ec333452-1301-47e8-90e2-716aeb2f5650].\nLogs are available at [https://console.cloud.google.com/cloud-build/builds/ec333452-1301-47e8-90e2-716aeb2f5650?project=840737568665].\n------------------------ REMOTE BUILD OUTPUT--------------------------------------...\n...\nCreated manifest list REGISTRY_REGION-docker.pkg.dev/PROJECT_ID/REPOSITORY/multiarch-helloworld:latest\nsha256:3ecbbc9f5144f358f81f7c7f1a7e28f069c98423d59c40eaff72bf184af0be02\n2020/09/14 11:34:25 Instance: 35.184.178.49 shut down successfully\nPUSH\nDONE\n----------------------------------------------------------------------------------\nID         CREATE_TIME    DURATION SOURCE                      IMAGES STATUS\nec333452-1301-47e8-90e2-716aeb2f5650 2020-09-14T11:21:43+00:00 12M43S gs://PROJECT_ID_cloudbuild/source/1600082502.509759-b949721a922d462c94a75da9be9f1181.tgz -     SUCCESS\n```\nYou've just built the image using the build config file and pushed the image to Artifact Registry at `` `-docker.pkg.dev/` `` `/` `` `/multiarch-helloworld:latest` .\n### Deploying the imageTo deploy the multi-arch Windows image onto a cluster, see [Deploying a Windows Server application](/kubernetes-engine/docs/how-to/deploying-windows-app) to learn how to deploy the image.\n### Advanced gke-windows-builder usageYou can customize the behavior of the gke-windows-builder by adding flags to the `args` section of the `cloudbuild.yaml` build config file. Some flags for common behaviors are described in this section, but this is not an exhaustive list; to see the full list of flags that gke-windows-builder supports, run the following command on a Linux server or in [CloudShell](https://ssh.cloud.google.com/cloudshell/editor?shellonly=true) :\n```\ndocker run -it us-docker.pkg.dev/gke-windows-tools/docker-repo/gke-windows-builder:latest --help\n```\nTo speed up your builds you can use a larger machine type for the Windows instances:\n```\n\u00a0 - --machineType\u00a0 - 'n1-standard-8'\n```\nInstead of building the image for all Windows versions that GKE supports, you can choose specific Windows Server versions to build for by using the `--versions` flag:\n```\n\u00a0 - --versions\u00a0 - '20H2,ltsc2019'\n```\nIf your workspace has many files, your image build will be more reliable if you configure the builder to copy the workspace via Cloud Storage rather than WinRM. [Create a bucket](/storage/docs/creating-buckets) in your project, such as `gs://{your project}_builder` , then set the `--workspace-bucket` flag:\n```\n\u00a0 - --workspace-bucket\u00a0 - '{your project}_builder'\n```\nTo run the Windows builder instances in a [Shared VPC](/vpc/docs/shared-vpc) service project, use these flags that control the instance's network setup:\n```\n\u00a0 - --subnetwork-project\u00a0 - 'shared-vpc-host-project'\u00a0 - --subnetwork\u00a0 - 'host-project-subnet-shared-with-service-project'\n```## Clean up\nAfter you finish the tutorial, you can clean up the resources that you created so that they stop using quota and incurring charges. The following sections describe how to delete or turn off these resources.\n### Deleting the imageTo delete the `multiarch-helloworld` images on Artifact Registry, see [Deleting images](/artifact-registry/docs/docker/manage-images#deleting_images) .\n### Deleting the project\nThe easiest way to eliminate billing is to delete the project that you created for the tutorial.\nTo delete the project:\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n## What's next\n- Explore other [Kubernetes Engine tutorials](/kubernetes-engine/docs/tutorials) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Google Kubernetes Engine (GKE)"}