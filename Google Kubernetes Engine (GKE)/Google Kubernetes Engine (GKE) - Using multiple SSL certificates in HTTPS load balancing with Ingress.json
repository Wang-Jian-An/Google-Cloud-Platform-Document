{"title": "Google Kubernetes Engine (GKE) - Using multiple SSL certificates in HTTPS load balancing with Ingress", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-multi-ssl", "abstract": "# Google Kubernetes Engine (GKE) - Using multiple SSL certificates in HTTPS load balancing with Ingress\nThis page shows you how to configure multiple SSL certificates for Ingress resources in Google Kubernetes Engine (GKE) clusters.\n", "content": "## Overview\nIf you want to accept HTTPS requests from your clients, the Application Load Balancer must have a certificate so it can prove its identity to your clients. The load balancer must also have a private key to complete the HTTPS handshake.\nWhen the load balancer accepts an HTTPS request from a client, the traffic between the client and the load balancer is encrypted using TLS. However, the load balancer terminates the TLS encryption, and forwards the request without encryption to the application. When you configure an Application Load Balancer through [Ingress](/kubernetes-engine/docs/concepts/ingress) , you can configure the load balancer to present up to ten TLS certificates to the client.\nThe load balancer uses Server Name Indication (SNI) to determine which certificate to present to the client, based on the domain name in the TLS handshake. If the client does not use SNI, or if the client uses a domain name that does not match the Common Name (CN) in one of the certificates, the load balancer uses the first certificate listed in the Ingress.\nThe following diagram shows the load balancer sending traffic to different backends, depending on the domain name used in the request:\nYou can provide an Application Load Balancer with SSL certificates using the following methods:\n- [Google-managed SSL certificates](/kubernetes-engine/docs/how-to/managed-certs) . Refer to the managed certificates page for information on how to use them.\n- Google Cloud SSL certificate that you manage yourself. The SSL Certificate uses a pre-shared certificate you upload to your Google Cloud project.\n- Kubernetes [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/) . The Secret holds a certificate and key that you create yourself. You add the name of the Secret to the `tls` field of your Ingress manifest.\nYou can use more than one method in the same Ingress. This allows for no-downtime migrations between methods.\n## The big picture\nHere's an overview of the steps in this document:\n- Create a Deployment.\n- Create a Service.\n- Create two certificate files and two key files or two `ManagedCertificate` objects. You must configure these certificates in the same project and the same namespace as where the load balancer is deployed.\n- Create an Ingress that uses either Secrets or pre-shared certificates. When you create the Ingress, GKE creates and configures an Application Load Balancer.\n- Test the Application Load Balancer.## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.\n- You must own two domain names. The domain names must be no longer than 63 characters.\n### Limitations\n- Google-managed certificates are only supported with GKE Ingress using the external Application Load Balancer. Google-managed certificates don't support third-party Ingress controllers.\n- For internal Application Load Balancers, you must [disable HTTP in the Ingress manifest](/kubernetes-engine/docs/concepts/ingress-xlb#disabling_http) . This is not required for the external load balancer.\n- You must not manually change or update the configuration of the Application Load Balancer. This means that you must not edit any of the load balancer's components, including target proxies, URL maps, and backend services. Any changes that you make are overwritten by GKE.## Create a Deployment\n- Save the following manifest as `my-mc-deployment.yaml` :```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: my-mc-deploymentspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: products\u00a0 \u00a0 \u00a0 department: sales\u00a0 replicas: 3\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: products\u00a0 \u00a0 \u00a0 \u00a0 department: sales\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: hello\u00a0 \u00a0 \u00a0 \u00a0 image: \"us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0\"\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: \"PORT\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"50001\"\u00a0 \u00a0 \u00a0 - name: hello-again\u00a0 \u00a0 \u00a0 \u00a0 image: \"us-docker.pkg.dev/google-samples/containers/gke/hello-app:2.0\"\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: \"PORT\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"50002\"\n```This manifest describes a Deployment with three Pods. Each Pod has two containers. One container runs `hello-app:1.0` and listens on TCP port 50001. The other container runs `hello-app:2.0` and listens on TCP port 50002.\n- Apply the manifest to your cluster:```\nkubectl apply -f my-mc-deployment.yaml\n```## Create a Service\n- Save the following manifest as `my-mc-service.yaml` :```\napiVersion: v1kind: Servicemetadata:\u00a0 name: my-mc-servicespec:\u00a0 type: NodePort\u00a0 selector:\u00a0 \u00a0 app: products\u00a0 \u00a0 department: sales\u00a0 ports:\u00a0 - name: my-first-port\u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 port: 60001\u00a0 \u00a0 targetPort: 50001\u00a0 - name: my-second-port\u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 port: 60002\u00a0 \u00a0 targetPort: 50002\n```This manifest describes a Service with the following fields:- `selector`: specifies that any Pod that has the`app: products`label and the`department: sales`label is a member of this Service.\n- `ports`: specifies that when a client sends a request to the Service on`my-first-port`, GKE forwards the request to one of the member Pods on port 50001. When a client sends a request to the Service on`my-second-port`, GKE forwards the request to one of the member Pods on port 50002.\n- Apply the manifest to your cluster:```\nkubectl apply -f my-mc-service.yaml\n```## Create certificates and keys\nTo do the exercises on this page, you need two certificates, each with a corresponding key. Each certificate must have a Common Name (CN) that is equal to a domain name that you own.\nIf you already have two certificate files with the appropriate values for Common Name, you can skip ahead to the next section.\n- Create your first key:```\nopenssl genrsa -out test-ingress-1.key 2048\n```\n- Create your first certificate signing request:```\nopenssl req -new -key test-ingress-1.key -out test-ingress-1.csr \\\u00a0 \u00a0 -subj \"/CN=FIRST_DOMAIN\"\n```Replace `` with a domain name that you own, such as `example.com` .\n- Create your first certificate:```\nopenssl x509 -req -days 365 -in test-ingress-1.csr -signkey test-ingress-1.key \\\u00a0 \u00a0 -out test-ingress-1.crt\n```\n- Create your second key:```\nopenssl genrsa -out test-ingress-2.key 2048\n```\n- Create your second certificate signing request:```\nopenssl req -new -key test-ingress-2.key -out test-ingress-2.csr \\\u00a0 \u00a0 -subj \"/CN=SECOND_DOMAIN\"\n```Replace `` with another domain name that you own, such as `examplepetstore.com` .\n- Create your second certificate:```\nopenssl x509 -req -days 365 -in test-ingress-2.csr -signkey test-ingress-2.key \\\u00a0 \u00a0 -out test-ingress-2.crt\n```\nFor more information about certificates and keys, see the [SSL certificates overview](/load-balancing/docs/ssl-certificates) .\nYou now have two certificate files and two key files.\nThe remaining tasks use the following placeholders to refer to your domains, certificates, and keys:- ``: the path to your first certificate file.\n- ``: the path to the key file that goes with your first certificate.\n- ``: a domain name that you own.\n- ``: the name of the Secret containing your first certificate and key.\n- ``: the path to your second certificate file.\n- ``: the path to the key file that goes with your second certificate.\n- ``: a second domain name that you own.\n- ``: the name of the Secret containing your second certificate and key.\n **Note:** The words FIRST and SECOND don't designate an order. They help to keep track of your two domains, your two certificate files, and the corresponding key files.To create Google-managed certificates, you must add `ManagedCertificate` objects to the namespace of your Ingress. You can use the following template to define certificates for your domains:\n```\n\u00a0 apiVersion: networking.gke.io/v1\u00a0 kind: ManagedCertificate\u00a0 metadata:\u00a0 \u00a0 name: FIRST_CERT_NAME\u00a0 spec:\u00a0 \u00a0 domains:\u00a0 \u00a0 \u00a0 - FIRST_DOMAIN\u00a0 ---\u00a0 apiVersion: networking.gke.io/v1\u00a0 kind: ManagedCertificate\u00a0 metadata:\u00a0 \u00a0 name: SECOND_CERT_NAME\u00a0 spec:\u00a0 \u00a0 domains:\u00a0 \u00a0 \u00a0 - SECOND_DOMAIN\n```\nReplace the following:- ``: the name of your first`ManagedCertificate`object.\n- ``: the first domain that you own.\n- ``: the name of the second`ManagedCertificate`object.\n- ``: the second domain that you own.\nThe names of the `ManagedCertificate` objects are different from the names of the actual certificates that they create. You only need to know the names of the `ManagedCertificate` objects to use them in your Ingress.\n## Specify certificates for your Ingress\nThe next step is to create an Ingress object. In your Ingress manifest, you can use one of the following methods to provide certificates for the load balancer:\n- Secrets\n- Pre-shared certificates\n- Google-managed certificates\n- Create a Secret that holds your first certificate and key:```\nkubectl create secret tls FIRST_SECRET_NAME \\\u00a0 \u00a0 --cert=FIRST_CERT_FILE \\\u00a0 \u00a0 --key=FIRST_KEY_FILE\n```\n- Create a Secret that holds your second certificate and key:```\nkubectl create secret tls SECOND_SECRET_NAME \\\u00a0 \u00a0 --cert=SECOND_CERT_FILE \\\u00a0 \u00a0 --key=SECOND_KEY_FILE\n```\n### Create an Ingress\n- Save the following manifest as `my-mc-ingress.yaml` :```\napiVersion: networking.k8s.io/v1kind: Ingressmetadata:\u00a0 name: my-mc-ingressspec:\u00a0 tls:\u00a0 - secretName: FIRST_SECRET_NAME\u00a0 - secretName: SECOND_SECRET_NAME\u00a0 rules:\u00a0 - host: FIRST_DOMAIN\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: ImplementationSpecific\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: my-mc-service\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 60001\u00a0 - host: SECOND_DOMAIN\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: ImplementationSpecific\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: my-mc-service\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 60002\n```Replace `` and `` with domain names that you own, for example `example.com` and `examplepetstore.com` .\n- Apply the manifest to your cluster:```\nkubectl apply -f my-mc-ingress.yaml\n```\n- Describe your Ingress:```\nkubectl describe ingress my-mc-ingress\n```The output is similar to the following:```\nName: my-mc-ingress\nAddress: 203.0.113.1\n...\nTLS:\n FIRST_SECRET_NAME terminates\n SECOND_SECRET_NAME terminates\nRules:\n Host    Path Backends\n ----    ---- ------- FIRST_DOMAIN\n      my-mc-service:my-first-port (<none>)\n SECOND_DOMAIN\n      my-mc-service:my-second-port (<none>)\nAnnotations:\n...\nEvents:\n Type Reason Age From      Message\n ---- ------ ---- ----      ------ Normal ADD  3m loadbalancer-controller default/my-mc-ingress\n Normal CREATE 2m loadbalancer-controller ip: 203.0.113.1\n```The output shows that two Secrets are associated with the Ingress. The output also shows the external IP address of the load balancer. If the external IP address is not set, wait a few minutes and try the command again.\n- Create a certificate:```\ngcloud compute ssl-certificates create FIRST_CERT_NAME \\\u00a0 \u00a0 --certificate=FIRST_CERT_FILE \\\u00a0 \u00a0 --private-key=FIRST_KEY_FILE\n```Replace the following:- ``: the name of your first certificate.\n- ``: your [first certificate file](#creating_certificates_and_keys) .\n- ``: your first key file.\n- Create a second certificate:```\ngcloud compute ssl-certificates create SECOND_CERT_NAME \\\u00a0 \u00a0 --certificate=SECOND_CERT_FILE \\\u00a0 \u00a0 --private-key=SECOND_KEY_FILE\n```Replace the following:- ``: the name of your second certificate.\n- ``: your second certificate file.\n- ``: your second key file.\n- View your certificate resources:```\ngcloud compute ssl-certificates list\n```The output is similar to the following:```\nNAME     CREATION_TIMESTAMP\nFIRST_CERT_NAME  2018-11-03T12:08:47.751-07:00\nSECOND_CERT_NAME  2018-11-03T12:09:25.359-07:00\n```\n### Create an Ingress\n- Save the following manifest as `my-psc-ingress.yaml` :```\napiVersion: networking.k8s.io/v1kind: Ingressmetadata:\u00a0 name: my-psc-ingress\u00a0 annotations:\u00a0 \u00a0 ingress.gcp.kubernetes.io/pre-shared-cert: \"FIRST_CERT_NAME,SECOND_CERT_NAME\"spec:\u00a0 rules:\u00a0 - host: FIRST_DOMAIN\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: ImplementationSpecific\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: my-mc-service\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 60001\u00a0 - host: SECOND_DOMAIN\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: ImplementationSpecific\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: my-mc-service\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 60002\n```Replace `` and `` with your domain names.This manifest describes an Ingress that lists pre-shared certificate resources in an annotation.\n- Apply the manifest to your cluster:```\nkubectl apply -f my-psc-ingress.yaml\n```\n- Describe your Ingress:```\nkubectl describe ingress my-psc-ingress\n```The output is similar to the following:```\nName:    my-psc-ingress\nAddress:   203.0.113.2\n...\nRules:\n Host    Path Backends\n ----    ---- ------- FIRST_DOMAIN\n      my-mc-service:my-first-port (<none>)\n SECOND_DOMAIN\n      my-mc-service:my-second-port (<none>)\nAnnotations:\n ...\n ingress.gcp.kubernetes.io/pre-shared-cert: FIRST_CERT_NAME,SECOND_CERT_NAME\n ...\n ingress.kubernetes.io/ssl-cert:    FIRST_CERT_NAME,SECOND_CERT_NAME\nEvents:\n Type Reason Age From      Message\n ---- ------ ---- ----      ------ Normal ADD  2m loadbalancer-controller default/my-psc-ingress\n Normal CREATE 1m loadbalancer-controller ip: 203.0.113.2\n```The output shows that the Ingress is associated with pre-shared certificates named `` and `` . The output also shows the external IP address of the load balancer. If the external IP address is not set, wait a few minutes and try the command again.### Create an Ingress\n- Save the following manifest as `my-gmc-ingress.yaml` :```\napiVersion: networking.k8s.io/v1kind: Ingressmetadata:\u00a0 name: my-gmc-ingress\u00a0 annotations:\u00a0 \u00a0 networking.gke.io/managed-certificates: \"FIRST_CERT_NAME,SECOND_CERT_NAME\"spec:\u00a0 rules:\u00a0 - host: FIRST_DOMAIN\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: ImplementationSpecific\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: my-mc-service\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 60001\u00a0 - host: SECOND_DOMAIN\u00a0 \u00a0 http:\u00a0 \u00a0 \u00a0 paths:\u00a0 \u00a0 \u00a0 - pathType: ImplementationSpecific\u00a0 \u00a0 \u00a0 \u00a0 backend:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 service:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: my-mc-service\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 number: 60002\n```Replace `` and `` with your domain names.This manifest describes an Ingress that lists pre-shared certificate resources in an annotation.\n- Apply the manifest to your cluster:```\nkubectl apply -f my-gmc-ingress.yaml\n```\n- Describe your Ingress:```\nkubectl describe ingress my-gmc-ingress\n```The output is similar to the following:```\nName:    my-gmc-ingress\nAddress:   203.0.113.2\n...\nRules:\n Host    Path Backends\n ----    ---- ------- FIRST_DOMAIN\n      my-mc-service:my-first-port (<none>)\n SECOND_DOMAIN\n      my-mc-service:my-second-port (<none>)\nAnnotations:\n ...\n ingress.gcp.kubernetes.io/pre-shared-cert: mcrt-a6e41ce4-2b39-4334-84ce-867ff543c424,mcrt-bbff4116-f014-4800-a43a-4095bffeb4f4\n ...\n ingress.kubernetes.io/ssl-cert:    mcrt-a6e41ce4-2b39-4334-84ce-867ff543c424,mcrt-bbff4116-f014-4800-a43a-4095bffeb4f4\n networking.gke.io/managed-certificates:  FIRST_CERT_NAME,SECOND_CERT_NAME\nEvents:\n Type Reason Age From      Message\n ---- ------ ---- ----      ------ Normal ADD  2m loadbalancer-controller default/my-gmc-ingress\n Normal CREATE 1m loadbalancer-controller ip: 203.0.113.2\n```The output shows that the Ingress is associated with managed certificates named `` and `` . GKE automatically populates the `ingress.gcp.kubernetes.io/pre-shared-cert` and `ingress.kubernetes.io/ssl-cert` annotations with the Google-managed certificates that you created using the `ManagedCertificate` objects. The output also shows the external IP address of the load balancer. If the external IP address is not set, wait a few minutes and try the command again.\n## Test the load balancer\nWait about five minutes for GKE to finish configuring the load balancer.\nTo test the load balancer, you must own two domain names, and both of your domain names must resolve the external IP address of the external Application Load Balancer.\n- Send a request to the load balancer by using your first domain name:```\ncurl -v https://FIRST_DOMAIN\n```You might need to use the `curl -k` option to perform an insecure SSL transfer, so that `curl` will accept self-signed certificates.The output is similar to the following:```\n...\n* Trying 203.0.113.1...\n...\n* Connected to FIRST_DOMAIN (203.0.113.1) port 443 (#0)\n...\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n...\n* Server certificate:\n* subject: CN=FIRST_DOMAIN\n...\n> Host: FIRST_DOMAIN.com\n...\nHello, world!\nVersion: 1.0.0\n...\n```This output shows that your first certificate was used in the TLS handshake.\n- Send a request to the load balancer by using your second domain name:```\ncurl -v https://SECOND_DOMAIN\n```The output is similar to the following:```\n...\n* Trying 203.0.113.1...\n...\n* Connected to SECOND_DOMAIN (203.0.113.1) port 443 (#0)\n...\n* Server certificate:\n* subject: CN=SECOND_DOMAIN\n...\n> Host: SECOND_DOMAIN\n...\nHello, world!\nVersion: 2.0.0\n```This output shows that your second certificate was used in the TLS handshake.## The hosts field of an Ingress object\nAn [IngressSpec](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#ingressspec-v1beta1-extensions) has a `tls` field that is an array of [IngressTLS](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#ingresstls-v1beta1-extensions) objects. Each `IngressTLS` object has a `hosts` field and `SecretName` field. In GKE, the `hosts` field is not used. GKE reads the Common Name (CN) from the certificate in the Secret. If the Common Name matches the domain name in a client request, then the load balancer presents the matching certificate to the client.\n## Which certificate is presented?\nThe load balancer [chooses a certificate](/load-balancing/docs/ssl-certificates#multiplessl) according to these rules:\n- If both Secrets and pre-shared certificates are listed in the Ingress, the pre-shared certificates take priority over Secrets. In other words, Secrets are still included but pre-shared certificates are presented first.\n- If no certificate has a Common Name (CN) that matches the domain name in the client request, the load balancer presents the primary certificate.\n- For Secrets listed in the `tls` block, the primary certificate is in the first Secret in the list.\n- For pre-shared certificates listed in the annotation, the primary certificate is the first certificate in the list.## Certificate rotation best practices\nIf you want to rotate the contents of your Secret or pre-shared certificate, here are some best practices:\n- Create a new Secret or pre-shared certificate with a different name that contains the new certificate data. Attach this resource (along with the existing one) to your Ingress using instructions provided earlier. Once satisfied with the changes, you can remove the old cert from the Ingress.\n- If you don't mind disrupting traffic, you can remove the old resource from the Ingress, provision a new resource with the same name but different contents and then reattach it to the Ingress.\n[Use Google-managed SSL certificates](/load-balancing/docs/ssl-certificates/google-managed-certs)\n## Troubleshooting\nSpecifying invalid or non-existent Secrets results in a Kubernetes event error. You can check Kubernetes events for an Ingress as follows:\n```\nkubectl describe ingress\n```\nThe output is similar to the following:\n```\nName:    my-ingress\nNamespace:  default\nAddress:   203.0.113.3\nDefault backend: hello-server:8080 (10.8.0.3:8080)\nTLS:\n my-faulty-Secret terminates\nRules:\n Host Path Backends\n ---- ---- ------- *  *  my-service:443 (10.8.0.3:443)\nEvents:\n Error during sync: cannot get certs for Ingress default/my-ingress:\n Secret \"my-faulty-ingress\" has no 'tls.crt'\n```\n## What's next\n- Read the [GKE network overview](/kubernetes-engine/docs/concepts/network-overview) .\n- Learn how to [configure domain names with static IP addresses](/kubernetes-engine/docs/tutorials/configuring-domain-name-static-ip) .\n- If you have an application running on multiple GKE clusters in different regions, configure a [Multi Cluster Ingress](/kubernetes-engine/docs/how-to/multi-cluster-ingress) to route traffic to a cluster in the region closest to the user.", "guide": "Google Kubernetes Engine (GKE)"}