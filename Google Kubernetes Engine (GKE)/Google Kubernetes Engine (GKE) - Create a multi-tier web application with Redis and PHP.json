{"title": "Google Kubernetes Engine (GKE) - Create a multi-tier web application with Redis and PHP", "url": "https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook", "abstract": "# Google Kubernetes Engine (GKE) - Create a multi-tier web application with Redis and PHP\nThis tutorial demonstrates how to build a multi-tier web application using Google Kubernetes Engine (GKE).\nIn this tutorial, you do the following:- Set up a web application with an external IP address and a load balancer.\n- Create a [Redis](http://redis.io/) cluster with a single master (leader) and multiple [replicas (followers)](https://redis.io/topics/replication) .\nThe example describes the following Kubernetes concepts:- [Declarative configuration](https://kubernetes.io/docs/tutorials/object-management-kubectl/declarative-object-management-configuration/) using YAML manifest files\n- [Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) , which are Kubernetes resources that determine the configuration for a set of replicated [Pods](https://kubernetes.io/docs/concepts/workloads/pods/pod/) \n- [Services](https://kubernetes.io/docs/concepts/services-networking/service/) to create internal and external load balancers for a set of Pods\n", "content": "## Objectives\nTo deploy and run the application on GKE:\n- Set up the Redis leader\n- Set up two Redis followers\n- Set up the web frontend\n- Visit the website\n- Scale up the web frontend\nThe following diagram shows you an overview of the cluster architecture you create by completing these objectives:## CostsIn this document, you use the following billable components of Google Cloud:- [GKE](/kubernetes-engine/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .## Before you beginCloud Shell is preinstalled with the software you need for this tutorial, including [kubectl](https://kubernetes.io/docs/reference/kubectl/) and [gcloud CLI](/sdk/gcloud) . If you don't use Cloud Shell, you must install the gcloud CLI.## Prepare the environmentTo set up your environment, follow these steps:- Set environment variables:```\nexport PROJECT_ID=PROJECT_ID\nexport COMPUTE_LOCATION=COMPUTE_LOCATION\n```Replace the following:- ``: your Google Cloud [project ID](/resource-manager/docs/creating-managing-projects#identifying_projects) \n- ``: a [Compute Engine location](/compute/docs/regions-zones#available) , such as`us-central1`.\n- Clone the GitHub repository:```\ngit clone https://github.com/GoogleCloudPlatform/kubernetes-engine-samples\n```\n- Change to the working directory:```\ncd kubernetes-engine-samples/quickstarts/guestbook/\n```\n### Create a GKE clusterCreate an Autopilot or Standard GKE cluster:\n **Autopilot** \n```\ngcloud container clusters create-auto guestbook \\\u00a0 \u00a0 --location=${COMPUTE_LOCATION} \\\n```\n **Standard** \n```\ngcloud container clusters create guestbook \\\u00a0 \u00a0 --location=${COMPUTE_LOCATION} \\\u00a0 \u00a0 --num-nodes=4\n```\n### Connect to the clusterConfigure `kubectl` to communicate with the cluster:\n```\ngcloud container clusters get-credentials guestbook \\\u00a0 \u00a0 --location=${COMPUTE_LOCATION}\n```## Set up the Redis leaderThe application uses Redis to store its data. The application writes its data to a Redis leader instance and reads data from multiple Redis follower instances.- The following manifest describes a Kubernetes Deployment that runs a single replica Redis leader Pod: [  quickstarts/guestbook/redis-leader-deployment.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-leader-deployment.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-leader-deployment.yaml) ```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: redis-leader\u00a0 labels:\u00a0 \u00a0 app: redis\u00a0 \u00a0 role: leader\u00a0 \u00a0 tier: backendspec:\u00a0 replicas: 1\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: redis\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: redis\u00a0 \u00a0 \u00a0 \u00a0 role: leader\u00a0 \u00a0 \u00a0 \u00a0 tier: backend\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: leader\u00a0 \u00a0 \u00a0 \u00a0 image: \"docker.io/redis:6.0.5\"\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: 100m\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: 100Mi\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 6379\n```Apply the manifest to your cluster:```\nkubectl apply -f redis-leader-deployment.yaml\n```\n- Verify that the Redis leader Pod is running:```\nkubectl get pods\n```The output is similar to the following:```\nNAME       READY  STATUS RESTARTS AGE\nredis-leader-343230949-qfvrq 1/1  Running 0   43s\n```It might take several minutes for `STATUS` to change from `Pending` to `Running` .\n## Create the Redis leader ServiceThe web application needs to communicate with the Redis leader to write its data. You can create a [Service](/kubernetes-engine/docs/services) to proxy the traffic to the Redis leader Pod.\nA Service is a Kubernetes abstraction that defines a logical set of Pods and a policy to enable access to the Pods. When you create a Service, you describe which Pods to proxy based on Pod labels.- The following manifest describes a Service for the Redis leader: [  quickstarts/guestbook/redis-leader-service.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-leader-service.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-leader-service.yaml) ```\napiVersion: v1kind: Servicemetadata:\u00a0 name: redis-leader\u00a0 labels:\u00a0 \u00a0 app: redis\u00a0 \u00a0 role: leader\u00a0 \u00a0 tier: backendspec:\u00a0 ports:\u00a0 - port: 6379\u00a0 \u00a0 targetPort: 6379\u00a0 selector:\u00a0 \u00a0 app: redis\u00a0 \u00a0 role: leader\u00a0 \u00a0 tier: backend\n```This manifest includes a set of label selectors. These labels match the set of labels that are deployed in the previous step. Therefore, this Service routes the network traffic to the Redis leader Pod created in a previous step.The `ports` section of the manifest declares a single port mapping. The Service routes the traffic on `port: 6379` to the `targetPort: 6379` of the containers that match the specified `selector` labels. The `containerPort` used in the Deployment must match the `targetPort` to route traffic to the Deployment.Apply the manifest to your cluster:```\nkubectl apply -f redis-leader-service.yaml\n```\n- Verify that GKE created the Service:```\nkubectl get service\n```The output is similar to the following:```\nNAME   CLUSTER-IP  EXTERNAL-IP PORT(S) AGE\nkubernetes  10.51.240.1  <none>  443/TCP 42s\nredis-leader 10.51.242.233 <none>  6379/TCP 12s\n```\n## Set up Redis followersAlthough the Redis leader is a single Pod, you can make it highly available and meet traffic demands by adding a few Redis followers, or replicas.- The following manifest describes a Deployment for the Redis follower Pods: [  quickstarts/guestbook/redis-follower-deployment.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-follower-deployment.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-follower-deployment.yaml) ```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: redis-follower\u00a0 labels:\u00a0 \u00a0 app: redis\u00a0 \u00a0 role: follower\u00a0 \u00a0 tier: backendspec:\u00a0 replicas: 2\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: redis\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: redis\u00a0 \u00a0 \u00a0 \u00a0 role: follower\u00a0 \u00a0 \u00a0 \u00a0 tier: backend\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: follower\u00a0 \u00a0 \u00a0 \u00a0 image: us-docker.pkg.dev/google-samples/containers/gke/gb-redis-follower:v2\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: 100m\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: 100Mi\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 6379\n```\n- Apply the manifest to your cluster:```\nkubectl apply -f redis-follower-deployment.yaml\n```\n- Verify that the two Redis follower replicas are running:```\nkubectl get pods\n```The output is similar to the following:```\nNAME        READY STATUS RESTARTS AGE\nredis-follower-76588f55b7-bnsq6 1/1  Running 0   27s\nredis-follower-76588f55b7-qvtws 1/1  Running 0   27s\nredis-leader-dd446dc55-kl7nl  1/1  Running 0   119s\n```It might take several minutes for `STATUS` to change from `Pending` to `Running` .\n## Create the Redis follower ServiceThe web application must communicate with the Redis followers to read data. To make the Redis followers discoverable, you must set up a Service.- The following manifest describes a Service for the Redis followers: [  quickstarts/guestbook/redis-follower-service.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-follower-service.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/redis-follower-service.yaml) ```\napiVersion: v1kind: Servicemetadata:\u00a0 name: redis-follower\u00a0 labels:\u00a0 \u00a0 app: redis\u00a0 \u00a0 role: follower\u00a0 \u00a0 tier: backendspec:\u00a0 ports:\u00a0 \u00a0 # the port that this service should serve on\u00a0 - port: 6379\u00a0 selector:\u00a0 \u00a0 app: redis\u00a0 \u00a0 role: follower\u00a0 \u00a0 tier: backend\n```This manifest specifies the Service runs on port 6379. The `selector` field of the Service matches the Redis follower Pods created in the previous step.Apply the manifest to your cluster:```\nkubectl apply -f redis-follower-service.yaml\n```\n- Verify GKE created the Service:```\nkubectl get service\n```The output is similar to the following:```\nNAME   CLUSTER-IP  EXTERNAL-IP PORT(S) AGE\nkubernetes  10.51.240.1  <none>  443/TCP 1m\nredis-leader 10.51.242.233 <none>  6379/TCP 49s\nredis-follower 10.51.247.238 <none>  6379/TCP 3s\n```\n## Set up the application web frontendNow that you have Redis storage for your application, start the web servers. Like the Redis followers, the frontend is deployed using a Kubernetes Deployment.\nThe web application uses a [PHP](https://www.php.net/) frontend, which is configured to communicate with either the Redis follower or leader Services, depending on whether the request is a read or a write. The frontend exposes a JSON interface, and serves a [jQuery Ajax-based](https://learn.jquery.com/ajax/) UI.- The following manifest describes a Deployment for the web server: [  quickstarts/guestbook/frontend-deployment.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/frontend-deployment.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/frontend-deployment.yaml) ```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: frontendspec:\u00a0 replicas: 3\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 \u00a0 app: guestbook\u00a0 \u00a0 \u00a0 \u00a0 tier: frontend\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: guestbook\u00a0 \u00a0 \u00a0 \u00a0 tier: frontend\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: php-redis\u00a0 \u00a0 \u00a0 \u00a0 image: us-docker.pkg.dev/google-samples/containers/gke/gb-frontend:v5\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: GET_HOSTS_FROM\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"dns\"\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: 100m\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: 100Mi\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 80\n```The manifest file specifies the environment variable `GET_HOSTS_FROM=dns` . When you provide the configuration to the web frontend application, the frontend application uses the hostnames `redis-follower` and `redis-leader` to performs a DNS lookup. The DNS lookup finds the IP addresses of the Services you created in the previous steps. This concept is called DNS service discovery.Apply the manifest to your cluster:```\nkubectl apply -f frontend-deployment.yaml\n```\n- Verify that the replicas are running:```\nkubectl get pods -l app=guestbook -l tier=frontend\n```The output is similar to the following:```\nNAME      READY STATUS RESTARTS AGE\nfrontend-7b78458576-8kp8s 1/1  Running 0   37s\nfrontend-7b78458576-gg86q 1/1  Running 0   37s\nfrontend-7b78458576-hz87g 1/1  Running 0   37s\n```\n## Expose the frontend on an external IP addressWith the current configuration, the `redis-follower` and `redis-leader` Services that you created in the previous steps are only accessible within the GKE cluster because the default type for a Service is [ClusterIP](https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types) .\nA `ClusterIP` Service provides a single IP address for the set of Pods where the Service is pointing. This IP address is accessible only within the cluster.\nTo make the web frontend Service externally accessible, you can [specify type: LoadBalancer or type: NodePort](/kubernetes-engine/docs/how-to/exposing-apps#creating_a_service_of_type_loadbalancer) in the Service configuration depending on your requirements.\nThe following manifest describes a Service of type LoadBalancer:\n [  quickstarts/guestbook/frontend-service.yaml ](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/frontend-service.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/kubernetes-engine-samples/blob/HEAD/quickstarts/guestbook/frontend-service.yaml) \n```\napiVersion: v1kind: Servicemetadata:\u00a0 name: frontend\u00a0 labels:\u00a0 \u00a0 app: guestbook\u00a0 \u00a0 tier: frontendspec:\u00a0 type: LoadBalancer\u00a0 ports:\u00a0 \u00a0 # the port that this service should serve on\u00a0 - port: 80\u00a0 selector:\u00a0 \u00a0 app: guestbook\u00a0 \u00a0 tier: frontend\n```\nThe port declaration under the `ports` section specifies `port: 80` and the `targetPort` is not specified. When you omit the `targetPort` property, it defaults to the value of the `port` field. In this case, this Service routes external traffic on port 80 to the port 80 of the containers in the `frontend` Deployment.\nApply the manifest to your cluster:\n```\nkubectl apply -f frontend-service.yaml\n```\nWhen the `frontend` Service is created, GKE creates a [load balancer](/load-balancing) and an external IP address. These resources are [subject to billing](/compute/pricing#lb) .## Visit the application websiteTo access the application website, get the external IP address of the `frontend` Service:\n```\nkubectl get service frontend\n```\nThe output is similar to the following:\n```\nNAME  CLUSTER-IP  EXTERNAL-IP  PORT(S)  AGE\nfrontend 10.51.242.136 109.197.92.229  80:32372/TCP 1m\n```\nThe `EXTERNAL-IP` column might show `<pending>` while the load balancer is being created. This might take several minutes. If you see errors such as `Does not have minimum availability` , wait a few minutes. This temporary error occurs because GKE re-creates the nodes to make the changes.\nCopy the IP address and open the page in your browser:Try adding some entries by typing in a message, and clicking **Submit** . The message you typed appears in the frontend. This message indicates that data is successfully added to Redis through the Services that you created.## Scale up the web frontendSuppose your application has been running for a while, and it gets a sudden burst of publicity. You decide it would be a good idea to add more web servers to your frontend. You can do this by increasing the number of Pods.- Scale up the number of `frontend` Pods:```\nkubectl scale deployment frontend --replicas=5\n```The output is similar to the following:```\ndeployment.extensions/frontend scaled\n```\n- Verify the number of replicas that are running:```\nkubectl get pods\n```The output is similar to the following:```\nNAME        READY  STATUS RESTARTS AGE\nfrontend-88237173-3s3sc   1/1  Running 0   1s\nfrontend-88237173-twgvn   1/1  Running 0   1s\nfrontend-88237173-5p257   1/1  Running 0   23m\nfrontend-88237173-84036   1/1  Running 0   23m\nfrontend-88237173-j3rvr   1/1  Running 0   23m\nredis-leader-343230949-qfvrq  1/1  Running 0   54m\nredis-follower-132015689-dp23k 1/1  Running 0   37m\nredis-follower-132015689-xq9v0 1/1  Running 0   37m\n```You can scale down the number of `frontend` Pods by using the same command, replacing `5` with `1` .\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- Delete a Google Cloud project:\n- ```\ngcloud projects delete PROJECT_ID\n```\n### Delete the individual resourcesIf you used an existing project and you don't want to delete it, delete the individual resources.- Delete the `frontend` Service:```\nkubectl delete service frontend\n```\n- Delete the GKE cluster:```\ngcloud container clusters delete guestbook\n```\n## What's next\n- Learn how to [configure horizontal Pod autoscaling](/kubernetes-engine/docs/how-to/horizontal-pod-autoscaling) .\n- Learn how to [deploy WordPress on GKE with Persistent Disk and Cloud SQL](/kubernetes-engine/docs/tutorials/persistent-disk) .\n- Learn how to [Configure domain names with static IP addresses](/kubernetes-engine/docs/tutorials/configuring-domain-name-static-ip) .\n- Explore other [Kubernetes Engine tutorials](/kubernetes-engine/docs/tutorials) .", "guide": "Google Kubernetes Engine (GKE)"}