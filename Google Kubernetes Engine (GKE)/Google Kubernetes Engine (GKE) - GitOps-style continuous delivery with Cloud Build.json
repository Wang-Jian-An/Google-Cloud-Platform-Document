{"title": "Google Kubernetes Engine (GKE) - GitOps-style continuous delivery with Cloud Build", "url": "https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build", "abstract": "# Google Kubernetes Engine (GKE) - GitOps-style continuous delivery with Cloud Build\nThis page explains how to create a continuous integration and delivery (CI/CD) pipeline on Google Cloud using only hosted products and the popular GitOps methodology.\nGoogle engineers have been storing configuration and deployment files in our primary source code repository for a long time. This methodology is described in the book [Site Reliability Engineering, Chapter 8](https://landing.google.com/sre/sre-book/chapters/release-engineering/#configuration-management-vJsYUr) ( ), and was demonstrated by Kelsey Hightower during his [Google Cloud Next '17 keynote](https://www.youtube.com/watch?v=XL9CQobFB8I) .\nA key part of GitOps is the idea of \"environments-as-code\": describing your deployments declaratively using files (for example, Kubernetes manifests) stored in a Git repository.\nIn this tutorial, you create a CI/CD pipeline that automatically builds a container image from committed code, stores the image in [Artifact Registry](/artifact-registry) , updates a Kubernetes manifest in a Git repository, and deploys the application to Google Kubernetes Engine (GKE) using that manifest.This tutorial uses two Git repositories:- **app repository** : contains the source code of the application itself\n- **env repository** : contains the manifests for the Kubernetes Deployment\nWhen you push a change to the repository, the [Cloud Build](/build) pipeline runs tests, builds a container image, and pushes it to Artifact Registry. After pushing the image, Cloud Build updates the Deployment manifest and pushes it to the repository. This triggers another Cloud Build pipeline that applies the manifest to the GKE cluster and, if successful, stores the manifest in another branch of the repository.\nWe keep the and repositories separate because they have different lifecycles and uses. The main users of the repository are actual humans and this repository is dedicated to a specific application. The main users of the repository are automated systems (such as Cloud Build), and this repository might be shared by several applications. The repository can have several branches that each map to a specific environment (you only use production in this tutorial) and reference a specific container image, whereas the repository does not.\nWhen you finish this tutorial, you have a system where you can easily:- Distinguish between failed and successful deployments by looking at the Cloud Build history,\n- Access the manifest currently used by looking at thebranch of therepository,\n- Rollback to any previous version by re-executing the corresponding Cloud Build build.\n", "content": "## About this tutorialThis tutorial uses [Cloud Source Repositories](/source-repositories) to host Git repositories, but you can achieve the same results with other third-party products such as GitHub, Bitbucket, or GitLab.\nThis pipeline does not implement a validation mechanism before the deployment. If you use GitHub, Bitbucket, or GitLab, you can modify the pipeline to use a Pull Request for this purpose.\nWhile we recommend [Spinnaker](http://spinnaker.io) to the teams who want to implement advanced deployment patterns (blue/green, canary analysis, multi-cloud, etc.), its feature set might not be needed for a successful CI/CD strategy for smaller organizations and projects. In this tutorial, you learn how to create a CI/CD pipeline fit for applications hosted on GKE with tooling.\nFor simplicity, this tutorial uses a single environment \u2014production\u2014 in the repository, but you can extend it to deploy to multiple environments if needed.## Objectives\n- Create Git repositories in Cloud Source Repositories.\n- Create a container image with Cloud Build and store it in Artifact Registry.\n- Create a CI pipeline.\n- Create a CD pipeline.\n- Test the CI/CD pipeline.\n## CostsIn this document, you use the following billable components of Google Cloud:- [GKE](/kubernetes-engine/pricing) \n- [Cloud Source Repositories](/source-repositories/pricing) \n- [Artifact Registry](/artifact-registry/pricing) \n- [Cloud Build](/build/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .## Before you begin\n- Select or create a Google Cloud project. [Go to Manage Resources](https://console.cloud.google.com/cloud-resource-manager) \n- Enable billing for your project. [Enable Billing](/billing/docs/how-to/modify-project) \n- Open [Cloud Shell](/shell/docs) to execute the commands listed in this tutorial. Cloud Shell is an interactive shell environment for Google Cloud that lets you manage your projects and resources from your web browser. [Go to Cloud Shell](https://console.cloud.google.com/?cloudshell=true) \n- If the `gcloud config get-value project` command does not return the ID of the project you selected, configure Cloud Shell to use your project.```\ngcloud config set project [PROJECT_ID]\n```\n- In Cloud Shell, enable the required APIs.```\ngcloud services enable container.googleapis.com \\\n cloudbuild.googleapis.com \\\n sourcerepo.googleapis.com \\\n artifactregistry.googleapis.com\n```\n- Create an Artifact Registry Docker repository named `my-repository` in the `us-central1` region to store your container images.```\ngcloud artifacts repositories create my-repository \\\u00a0 --repository-format=docker \\\u00a0 --location=us-central1\n```\n- In Cloud Shell, create a GKE cluster that you will use to deploy the sample application of this tutorial.\nCreate an Autopilot cluster named `hello-cloudbuild` :\n```\ngcloud container clusters create-auto hello-cloudbuild \\\u00a0 \u00a0 --region us-central1\n```\nCreate a one-node Standard cluster named `hello-cloudbuild` :\n```\ngcloud container clusters create hello-cloudbuild \\\u00a0 \u00a0 --num-nodes 1 --region us-central1\n```\n- If you have never used Git in Cloud Shell, configure it with your name and email address. Git will use those to identify you as the author of the commits you will create in Cloud Shell.```\ngit config --global user.email \"YOUR_EMAIL_ADDRESS\"\ngit config --global user.name \"YOUR_NAME\"\n```\nWhen you finish this tutorial, you can avoid continued billing by deleting the resources you created. See [Cleaning up](#clean-up) for more detail.## Creating the Git repositories in Cloud Source RepositoriesIn this section, you create the two Git repositories ( and ) used in this tutorial, and initialize the one with some sample code.- In Cloud Shell, create the two Git repositories.```\ngcloud source repos create hello-cloudbuild-app\ngcloud source repos create hello-cloudbuild-env\n```\n- Clone the sample code from GitHub.```\ncd ~\ngit clone https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild \\\n hello-cloudbuild-app\n```\n- Configure Cloud Source Repositories as a remote.```\ncd ~/hello-cloudbuild-app\nPROJECT_ID=$(gcloud config get-value project)\ngit remote add google \\\n \"https://source.developers.google.com/p/${PROJECT_ID}/r/hello-cloudbuild-app\"\n```\nThe code you cloned contains a \"Hello World\" application.\n [  app.py ](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/app.py) [View on GitHub](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/app.py) \n```\nfrom flask import Flaskapp = Flask('hello-cloudbuild')@app.route('/')def hello():\u00a0 return \"Hello World!\\n\"if __name__ == '__main__':\u00a0 app.run(host = '0.0.0.0', port = 8080)\n```## Creating a container image with Cloud BuildThe code you cloned contains the following Dockerfile.\n [  Dockerfile ](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/Dockerfile) [View on GitHub](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/Dockerfile) \n```\nFROM python:3.7-slimRUN pip install flaskWORKDIR /appCOPY app.py /app/app.pyENTRYPOINT [\"python\"]CMD [\"/app/app.py\"]\n```\nWith this Dockerfile, you can create a container image with Cloud Build and store it in Artifact Registry.- In Cloud Shell, create a Cloud Build build based on the latest commit with the following command.```\ncd ~/hello-cloudbuild-app\nCOMMIT_ID=\"$(git rev-parse --short=7 HEAD)\"\ngcloud builds submit --tag=\"us-central1-docker.pkg.dev/${PROJECT_ID}/my-repository/hello-cloudbuild:${COMMIT_ID}\" .\n```Cloud Build streams the logs generated by the creation of the container image to your terminal when you execute this command.\n- After the build finishes, verify that your new container image is available in Artifact Registry. [Go to Artifact Registry](https://console.cloud.google.com/artifacts) \n## Creating the continuous integration pipelineIn this section, you configure Cloud Build to automatically run a small unit test, build the container image, and then push it to Artifact Registry. Pushing a new commit to Cloud Source Repositories automatically triggers this pipeline. The `cloudbuild.yaml` file included in the code is the pipeline's configuration.\n [  cloudbuild.yaml ](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/cloudbuild.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/cloudbuild.yaml) \n```\nsteps:# This step runs the unit tests on the app- name: 'python:3.7-slim'\u00a0 id: Test\u00a0 entrypoint: /bin/sh\u00a0 args:\u00a0 - -c\u00a0 - 'pip install flask && python test_app.py -v'# This step builds the container image.- name: 'gcr.io/cloud-builders/docker'\u00a0 id: Build\u00a0 args:\u00a0 - 'build'\u00a0 - '-t'\u00a0 - 'us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/hello-cloudbuild:$SHORT_SHA'\u00a0 - '.'# This step pushes the image to Artifact Registry# The PROJECT_ID and SHORT_SHA variables are automatically# replaced by Cloud Build.- name: 'gcr.io/cloud-builders/docker'\u00a0 id: Push\u00a0 args:\u00a0 - 'push'\u00a0 - 'us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/hello-cloudbuild:$SHORT_SHA'\n```- Open the Cloud Build **Triggers** page. [Go to Triggers](https://console.cloud.google.com/cloud-build/triggers) \n- Click **Create trigger** .\n- Fill out the following options:- In the **Name** field, type`hello-cloudbuild`.\n- Under **Event** , select **Push to a branch** .\n- Under **Source** , select`hello-cloudbuild-app`as your **Repository** and`^master$`as your **Branch** .\n- Under **Build configuration** , select **Cloud Build\nconfiguration file** .\n- In the **Cloud Build configuration file location** field, type`cloudbuild.yaml`after the`/`.\n- Click **Create** to save your build trigger. **Tip** : If you need to create Build Triggers for many projects, you can use the [Build Triggers API](/build/docs/api/reference/rest/v1/projects.triggers) .\n- In Cloud Shell, push the application code to Cloud Source Repositories to trigger the CI pipeline in Cloud Build.```\ncd ~/hello-cloudbuild-app\ngit push google master\n```\n- Open the Cloud Build console. [Go to Cloud Build](https://console.cloud.google.com/cloud-build/builds?query=source.repo_source.repo_name%20%3D%20%22hello-cloudbuild-app%22) Your recently run and finished builds appear. You can click on a build to follow its execution and examine its logs.\n## Creating the continuous delivery pipelineCloud Build is also used for the continuous delivery pipeline. The pipeline runs each time a commit is pushed to the branch of the repository. The pipeline applies the new version of the manifest to the Kubernetes cluster and, if successful, copies the manifest over to the branch. This process has the following properties:- Thebranch is a history of the deployment attempts.\n- Thebranch is a history of the successful deployments.\n- You have a view of successful and failed deployments in Cloud Build.\n- You can rollback to any previous deployment by re-executing the corresponding build in Cloud Build. A rollback also updates thebranch to truthfully reflect the history of deployments.\nYou will modify the continuous integration pipeline to update the branch of the repository, triggering the continuous delivery pipeline.\n **Note:** You can extend the system described in this tutorial to manage several environments. The easiest way to achieve this is to have a pair of branches for each environment : a branch and an branch.\n### Granting Cloud Build access to GKETo deploy the application in your Kubernetes cluster, Cloud Build needs the Kubernetes Engine Developer [Identity and Access Management Role](/iam/docs/understanding-roles) .\nIn Cloud Shell, execute the following command:\n```\nPROJECT_NUMBER=\"$(gcloud projects describe ${PROJECT_ID} --format='get(projectNumber)')\"\ngcloud projects add-iam-policy-binding ${PROJECT_NUMBER} \\\n --member=serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com \\\n --role=roles/container.developer\n```- In the Google Cloud console, open the **Cloud Build Settings** page: [   Open Cloud Build Settings](https://console.cloud.google.com/cloud-build/settings) The **Service account permissions** page appears: \n- Set the status of the **Kubernetes Engine Developer** role to **Enable** .### Initializing the hello-cloudbuild-env repositoryYou need to initialize the repository with two branches ( and ) and a Cloud Build configuration file describing the deployment process.- In Cloud Shell, clone the repository and create the branch.```\ncd ~\ngcloud source repos clone hello-cloudbuild-env\ncd ~/hello-cloudbuild-env\ngit checkout -b production\n```\n- Copy the `cloudbuild-delivery.yaml` file available in the repository and commit the change.```\ncd ~/hello-cloudbuild-env\ncp ~/hello-cloudbuild-app/cloudbuild-delivery.yaml ~/hello-cloudbuild-env/cloudbuild.yaml\ngit add .\ngit commit -m \"Create cloudbuild.yaml for deployment\"\n```The `cloudbuild-delivery.yaml` file describes the deployment process to be run in Cloud Build. It has two steps:- Cloud Build applies the manifest on the GKE cluster.\n- If successful, Cloud Build copies the manifest on the branch.\n [  cloudbuild-delivery.yaml ](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/cloudbuild-delivery.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/cloudbuild-delivery.yaml) ```\nsteps:# This step deploys the new version of our container image# in the hello-cloudbuild Kubernetes Engine cluster.- name: 'gcr.io/cloud-builders/kubectl'\u00a0 id: Deploy\u00a0 args:\u00a0 - 'apply'\u00a0 - '-f'\u00a0 - 'kubernetes.yaml'\u00a0 env:\u00a0 - 'CLOUDSDK_COMPUTE_REGION=us-central1'\u00a0 - 'CLOUDSDK_CONTAINER_CLUSTER=hello-cloudbuild'# This step copies the applied manifest to the production branch# The COMMIT_SHA variable is automatically# replaced by Cloud Build.- name: 'gcr.io/cloud-builders/git'\u00a0 id: Copy to production branch\u00a0 entrypoint: /bin/sh\u00a0 args:\u00a0 - '-c'\u00a0 - |\u00a0 \u00a0 set -x && \\\u00a0 \u00a0 # Configure Git to create commits with Cloud Build's service account\u00a0 \u00a0 git config user.email $(gcloud auth list --filter=status:ACTIVE --format='value(account)') && \\\u00a0 \u00a0 # Switch to the production branch and copy the kubernetes.yaml file from the candidate branch\u00a0 \u00a0 git fetch origin production && git checkout production && \\\u00a0 \u00a0 git checkout $COMMIT_SHA kubernetes.yaml && \\\u00a0 \u00a0 # Commit the kubernetes.yaml file with a descriptive commit message\u00a0 \u00a0 git commit -m \"Manifest from commit $COMMIT_SHA\u00a0 \u00a0 $(git log --format=%B -n 1 $COMMIT_SHA)\" && \\\u00a0 \u00a0 # Push the changes back to Cloud Source Repository\u00a0 \u00a0 git push origin production\n```\n- Create a branch and push both branches for them to be available in Cloud Source Repositories.```\ngit checkout -b candidate\ngit push origin production\ngit push origin candidate\n```\n- Grant the Source Repository Writer IAM role to the Cloud Build service account for the repository.```\nPROJECT_NUMBER=\"$(gcloud projects describe ${PROJECT_ID} \\\u00a0 \u00a0 --format='get(projectNumber)')\"cat >/tmp/hello-cloudbuild-env-policy.yaml <<EOFbindings:- members:\u00a0 - serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com\u00a0 role: roles/source.writerEOFgcloud source repos set-iam-policy \\\u00a0 \u00a0 hello-cloudbuild-env /tmp/hello-cloudbuild-env-policy.yaml\n```\n### Creating the trigger for the continuous delivery pipelineIn this section, you configure Cloud Build to be triggered by a push to the branch of the repository.- Open the **Triggers** page of Cloud Build. [Go to Triggers](https://console.cloud.google.com/cloud-build/triggers) \n- Click **Create trigger** .\n- Fill out the following options:- In the **Name** field, type`hello-cloudbuild-deploy`.\n- Under **Event** , select **Push to a branch** .\n- Under **Source** , select`hello-cloudbuild-env`as your **Repository** and`^candidate$`as your **Branch** .\n- Under **Configuration** , select **Cloud Build\nconfiguration file (yaml or json)** .\n- In the **Cloud Build configuration file location** field, type`cloudbuild.yaml`after the`/`.\n- Click **Create** .\n### Modifying the continuous integration pipeline to trigger the continuous delivery pipelineIn this section, you add some steps to the continuous integration pipeline that generates a new version of the Kubernetes manifest and push it to the repository to trigger the continuous delivery pipeline.- Replace the `cloudbuild.yaml` file with the extended example in the `cloudbuild-trigger-cd.yaml` file.```\ncd ~/hello-cloudbuild-app\ncp cloudbuild-trigger-cd.yaml cloudbuild.yaml\n```The `cloudbuild-trigger-cd.yaml` is an extended version of the `cloudbuild.yaml` file. It adds steps to generate the new Kubernetes manifest and trigger the continuous delivery pipeline. **Note:** This pipeline uses a to render the manifest template. In reality, you might benefit from using a dedicated tool such as [kustomize](https://github.com/kubernetes-sigs/kustomize) or [skaffold](https://github.com/GoogleContainerTools/skaffold) . These tools give you more control over the rendering of the manifest templates. [  cloudbuild-trigger-cd.yaml ](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/cloudbuild-trigger-cd.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/gke-gitops-tutorial-cloudbuild/blob/HEAD/cloudbuild-trigger-cd.yaml) ```\n# This step clones the hello-cloudbuild-env repository- name: 'gcr.io/cloud-builders/gcloud'\u00a0 id: Clone env repository\u00a0 entrypoint: /bin/sh\u00a0 args:\u00a0 - '-c'\u00a0 - |\u00a0 \u00a0 gcloud source repos clone hello-cloudbuild-env && \\\u00a0 \u00a0 cd hello-cloudbuild-env && \\\u00a0 \u00a0 git checkout candidate && \\\u00a0 \u00a0 git config user.email $(gcloud auth list --filter=status:ACTIVE --format='value(account)')# This step generates the new manifest- name: 'gcr.io/cloud-builders/gcloud'\u00a0 id: Generate manifest\u00a0 entrypoint: /bin/sh\u00a0 args:\u00a0 - '-c'\u00a0 - |\u00a0 \u00a0 \u00a0sed \"s/GOOGLE_CLOUD_PROJECT/${PROJECT_ID}/g\" kubernetes.yaml.tpl | \\\u00a0 \u00a0 \u00a0sed \"s/COMMIT_SHA/${SHORT_SHA}/g\" > hello-cloudbuild-env/kubernetes.yaml# This step pushes the manifest back to hello-cloudbuild-env- name: 'gcr.io/cloud-builders/gcloud'\u00a0 id: Push manifest\u00a0 entrypoint: /bin/sh\u00a0 args:\u00a0 - '-c'\u00a0 - |\u00a0 \u00a0 set -x && \\\u00a0 \u00a0 cd hello-cloudbuild-env && \\\u00a0 \u00a0 git add kubernetes.yaml && \\\u00a0 \u00a0 git commit -m \"Deploying image us-central1-docker.pkg.dev/$PROJECT_ID/my-repository/hello-cloudbuild:${SHORT_SHA}\u00a0 \u00a0 Built from commit ${COMMIT_SHA} of repository hello-cloudbuild-app\u00a0 \u00a0 Author: $(git log --format='%an <%ae>' -n 1 HEAD)\" && \\\u00a0 \u00a0 git push origin candidate\n```\n- Commit the modifications and push them to Cloud Source Repositories.```\ncd ~/hello-cloudbuild-app\ngit add cloudbuild.yaml\ngit commit -m \"Trigger CD pipeline\"\ngit push google master\n```This triggers the continuous integration pipeline in Cloud Build.\n- Examine the continuous integration build. [Go to Cloud Build](https://console.cloud.google.com/cloud-build/builds?query=source.repo_source.repo_name%20%3D%20%22hello-cloudbuild-app%22%20OR%20source.repo_source.repo_name%20%3D%20%22hello-cloudbuild-env%22) Your recently run and finished builds for the repository appear. You can click on a build to follow its execution and examine its logs. The last step of this pipeline pushes the new manifest to the repository, which triggers the continuous delivery pipeline.\n- Examine the continuous delivery build. [Go to Cloud Build](https://console.cloud.google.com/cloud-build/builds?query=source.repo_source.repo_name%20%3D%20%22hello-cloudbuild-app%22%20OR%20source.repo_source.repo_name%20%3D%20%22hello-cloudbuild-env%22) Your recently run and finished builds for the repository appear. You can click on a build to follow its execution and examine its logs.\n### Testing the complete pipelineThe complete CI/CD pipeline is now configured. In this section, you test it from end to end.- Go to the GKE Services page. [Go to Google Kubernetes Engine Services](https://console.cloud.google.com/kubernetes/discovery) The list contains a single service called created by the recently completed continuous delivery build.\n- Click on the endpoint for the service. \"Hello World!\" appears. If there is no endpoint, or if you see a load balancer error, you might have to wait a few minutes for the load balancer to be completely initialized. Click **Refresh** to update the page if needed.\n- In Cloud Shell, replace \"Hello World\" by \"Hello Cloud Build\", both in the application and in the unit test.```\ncd ~/hello-cloudbuild-app\nsed -i 's/Hello World/Hello Cloud Build/g' app.py\nsed -i 's/Hello World/Hello Cloud Build/g' test_app.py\n```\n- Commit and push the change to Cloud Source Repositories.```\ngit add app.py test_app.py\ngit commit -m \"Hello Cloud Build\"\ngit push google master\n```This triggers the full CI/CD pipeline.\n- After a few minutes, reload the application in your browser. \"Hello Cloud Build!\" appears.\n### Testing the rollbackIn this section, you rollback to the version of the application that said \"Hello World!\".- Open the Cloud Build console for the repository. [Go to Cloud Build](https://console.cloud.google.com/cloud-build/builds?query=source.repo_source.repo_name%20%3D%20%22hello-cloudbuild-env%22) \n- Click on the second most recent build available.\n- Click **Rebuild** .\n- When the build is finished, reload the application in your browser. \"Hello World!\" appears again.\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Deleting the resourcesIf you want to keep the Google Cloud project you used in this tutorial, delete the individual resources:- Delete the local Git repositories.```\ncd ~\nrm -rf ~/hello-cloudbuild-app\nrm -rf ~/hello-cloudbuild-env\n```\n- Delete the Git repositories in Cloud Source Repositories.```\ngcloud source repos delete hello-cloudbuild-app --quiet\ngcloud source repos delete hello-cloudbuild-env --quiet\n```\n- Delete the Cloud Build Triggers.- Open the **Triggers** page of Cloud Build. [Go to Triggers](https://console.cloud.google.com/cloud-build/triggers) \n- For each trigger, click **More** , then **Delete** .\n- Delete the Docker repository in Artifact Registry.```\ngcloud artifacts repositories delete my-repository \\\n --location=us-central1\n```\n- Remove the permission granted to Cloud Build to connect to GKE.```\nPROJECT_NUMBER=\"$(gcloud projects describe ${PROJECT_ID} \\\n --format='get(projectNumber)')\"\ngcloud projects remove-iam-policy-binding ${PROJECT_NUMBER} \\\n --member=serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com \\\n --role=roles/container.developer\n```\n- Delete the GKE cluster.```\ngcloud container clusters delete hello-cloudbuild \\\u00a0 \u00a0--region us-central1\n```\n## What's next\n- Take a look at more advanced Cloud Build features: [Configuring the order of build steps](/build/docs/configuring-builds/configure-build-step-order) , [Building, Testing, and Deploying Artifacts](/build/docs/configuring-builds/build-test-deploy-artifacts) , [Creating Custom Build Steps](/build/docs/create-custom-build-steps) \n- [Learn how to mirror a GitHub or Bitbucket repository to Cloud Source Repositories](/source-repositories/docs/connecting-hosted-repositories) \n- [Connect directly Cloud Build to your GitHub repository](/build/docs/run-builds-on-github)", "guide": "Google Kubernetes Engine (GKE)"}