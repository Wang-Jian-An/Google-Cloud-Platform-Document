{"title": "Google Kubernetes Engine (GKE) - Deploying Gateways", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/deploying-gateways", "abstract": "# Google Kubernetes Engine (GKE) - Deploying Gateways\nThis page describes how to deploy Kubernetes [Gatewayresources](/kubernetes-engine/docs/concepts/gateway-api) for load balancing ingress traffic to a single Google Kubernetes Engine (GKE) cluster.\n[Deploying Multi-Cluster Gateways](/kubernetes-engine/docs/how-to/deploying-multi-cluster-gateways)\n", "content": "## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.\n### GKE Gateway controller requirements\n- For Standard, GKE version 1.24 or later.\n- For Autopilot, GKE version 1.26 or later.\n- Google Cloud CLI version 407.0.0 or later.\n- The Gateway API is supported on [VPC-native](/kubernetes-engine/docs/concepts/alias-ips) clusters only.\n- If you are using the internal GatewayClasses, you must enable a [proxy-only subnet](/load-balancing/docs/proxy-only-subnets) .\n- Your cluster must have the`HttpLoadBalancing`add-on enabled.\n- If you are using Istio, you must upgrade Istio to one of the following versions:- 1.15.2 or later\n- 1.14.5 or later\n- 1.13.9 or later.\n- If you are using Shared VPC, then in the host project, you need to assign the`Compute Network User`role to the GKE Service account for the service project.\n### Restrictions and Limitations\n- GKE GatewayClasses support different capabilities depending on the load balancer they use. To learn more about the different features supported with each GatewayClass, see [GatewayClass capabilities](/kubernetes-engine/docs/how-to/gatewayclass-capabilities) .\n- You cannot use a [FrontendConfig](/kubernetes-engine/docs/how-to/ingress-configuration#configuring_ingress_features_through_frontendconfig_parameters) or a [BackendConfig](/kubernetes-engine/docs/how-to/ingress-configuration#configuring_ingress_features_through_backendconfig_parameters) to configure a Gateway. You must use a [Policy](/kubernetes-engine/docs/how-to/configure-gateway-resources) .\n- GKE Gateway behaves differently than Ingress, in that Gateway does not infer health check parameters. If your Service does not return 200 for requests to `GET /` , or you have other tuned pod readiness checks, you need to [configure a HealthCheckPolicy](/kubernetes-engine/docs/how-to/configure-gateway-resources#configure_health_check) for your service.\n- You can view the load balancer resources that GKE creates for Gateways in the Google Cloud console, but these resources do not reference the Gateway or GKE cluster they are attached to.\n- You cannot see Gateway, HTTPRoute, and Policy resources in the Google Cloud console. You can discover and manage Gateway resources using the Kubernetes API.\n[Secure a Gateway](/kubernetes-engine/docs/how-to/secure-gateway)\n- HTTPRoute is the only Route type supported. TCPRoutes, UDPRoutes, and TLSRoutes are not supported. To see a list of fields the GKE Gateway controller supports, see [GatewayClass capabilities](/kubernetes-engine/docs/how-to/gatewayclass-capabilities) .\n- Custom request and response headers with Gateway or path redirects and URL rewrites with Gateway is only available on GKE version 1.27 or later.\n- For custom request and response headers with Gateway and path redirects and URL rewrites with Gateway, the GatewayClass`gke-l7-gxlb`is not supported.\n- The following Google Cloud header variables are not supported:- `cdn_cache_id`(Cloud CDN is not supported with GKE Gateway)\n- `cdn_cache_status`(Cloud CDN is not supported with GKE Gateway)\n- `origin_request_header`(CORS is not supported with GKE Gateway)\n- GKE Gateway does not support the Cloud CDN load balancing feature.\n- Mutual TLS custom headers are not supported (mTLS with GKE Gateway is not supported)\n- Google Cloud classic Application Load Balancer limitations apply to the GKE Gateway with one additional limitation:- You can't configure a custom Host response header in the backend service.\n- Path redirects and URL rewrites are mutually exclusive, you can't use both filters at the same time in the same rules.\n- Redirecting traffic to a different port is not supported with Cloud Load Balancing. To see the list of fields the GKE Gateway controller supports, see [GatewayClass capabilities](/kubernetes-engine/docs/how-to/gatewayclass-capabilities) .\n- GKE Gateway does not support [Wildcards, regular expressions, and dynamic URLs](/load-balancing/docs/url-map-concepts#wildcards-regx-dynamic) .\n- If you specify a Gateway with a regional external gateway class, the controller provisions an internal IP address instead of the external address. To learn how to use a named address with the regional external Application Load Balancer, see [deploy a regional external Gateway](#deploy_a_regional_external_gateway) .\n- Gateway utilizes [Standalone NEGs](/kubernetes-engine/docs/how-to/standalone-neg#standalone_negs) for provisioning Network Endpoint Groups. To ensure that the Gateway controller properly reconciles the load balancer configuration, you cannot modify the `cloud.google.com/neg` annotation for a Service that is part of the Gateway.\n- GKE Gateway does not support referencing a Service that is also referenced by a GKE Ingress.\n- When a `Gateway` is configured to provision an IP address, changing the `Gateway.spec.gatewayClass` is not supported. To ensure that the Gateway controller properly reconciles the load balancer, delete the existing Gateway and re-deploy the manifest with the updated `gatewayClass` value.\n- The `networking.gke.io/app-protocols` annotation is not supported. Use the [appProtocol field](/kubernetes-engine/docs/how-to/secure-gateway#load-balancer-tls) instead to achieve the same result.## Enable the Gateway API in your cluster\nBefore using Gateway resources in GKE, your cluster must have the Gateway API enabled.\n### Create a new cluster with the Gateway API enabled\nGKE supports the Gateway API on Autopilot clusters starting with GKE version 1.26. If you create new Autopilot clusters on GKE 1.26 and later, Gateway API is enabled by default. For existing clusters on GKE version 1.25 and lower, Gateway API is disabled by default.\n**Autopilot**\nCreate a new GKE Autopilot cluster with the Gateway API enabled:\n```\n\u00a0 gcloud container clusters create-auto CLUSTER_NAME \\\u00a0 \u00a0 \u00a0 --location=CLUSTER_LOCATION \\\u00a0 \u00a0 \u00a0 --release-channel=RELEASE_CHANNEL \\\u00a0 \u00a0 \u00a0 --cluster-version=VERSION\n```\nReplace the following:\n- ``: the name of the cluster.\n- ``: the [Compute Engine region or zone](/compute/docs/regions-zones#available) for the new cluster.\n- ``: the name of the release channel.\n- ``: the GKE version, which must be 1.26 or later. You can also use the`--release-channel`flag to select a [release channel](/kubernetes-engine/docs/concepts/release-channels) . The release channel must have a default version of 1.26 or later.\n**Note:** You need not use the `gcloud flag --gateway-api=standard` at cluster creation.\n**Standard**\nWith GKE Standard, the Gateway API is controlled by the `--gateway-api` flag. You can use the value standard when enabling and disabled when disabling.\nCreate a new VPC-native GKE cluster with the Gateway API enabled:\n```\n\u00a0 gcloud container clusters create CLUSTER_NAME \\\u00a0 \u00a0 --gateway-api=standard \\\u00a0 \u00a0 --cluster-version=VERSION \\\u00a0 \u00a0 --location=CLUSTER_LOCATION\n```\nReplace the following:\n- ``: the name of the release channel.\n- ``: the name of the cluster.\n- ``: the GKE version, which must be 1.24 or later. You can also use the`--release-channel`flag to select a [release channel](/kubernetes-engine/docs/concepts/release-channels) . The release channel must have a default version of 1.24 or later.\n- ``: the [Compute Engine region or zone](/compute/docs/regions-zones#available) for the new cluster.\nThe `--gateway-api=standard` flag instructs GKE to install the `v1beta1` CRDs with the cluster.\n### Enable the Gateway API on an existing cluster\n**Note:** When enabling Gateway on an existing cluster, it may take up to 45 minutes for the cluster to reconcile and install the CRDs.\nEnsure that your Autopilot cluster version is 1.26 or later and your Standard cluster version is 1.24 or later.\nTo enable the Gateway API on an existing GKE cluster (Autopilot or Standard), use the following:\n```\ngcloud container clusters update CLUSTER_NAME \\\u00a0 \u00a0 --location=CLUSTER_LOCATION\\\u00a0 \u00a0 --gateway-api=standard\n```\nReplace the following:\n- `` : the name of the existing cluster.\n- `` : the [Compute Engine region or zone](/compute/docs/regions-zones#available) of the cluster.\nThe `--gateway-api=standard` flag instructs GKE to install the `v1beta1` CRDs with the cluster.\n**Note:** If you update an existing GKE Standard cluster to enable the Gateway API, make sure that the [minimum requirements](#requirements) are met before proceeding with the update. To learn more about upgrading your Standard cluster version, see [Standard cluster upgrades](/kubernetes-engine/docs/concepts/cluster-upgrades) . To learn more about upgrading your Autopilot cluster version, see [Autopilot cluster upgrades](/kubernetes-engine/docs/concepts/cluster-upgrades-autopilot) .\n## Verify your cluster\nAfter creating or upgrading your cluster, the [GKE Gateway controller](/kubernetes-engine/docs/concepts/gateway-api#gateway_controller) automatically installs GatewayClasses. It might take a few minutes for the controller to recognize the CRDs and install the GatewayClasses.\n- Confirm the Gateway API is enabled in the GKE control plane:```\ngcloud container clusters describe CLUSTER_NAME \\\u00a0 --location=CLUSTER_LOCATION \\\u00a0 --format json\n```The output is similar to the following. If this output is empty, re-run the [cluster update command](#enable-gateway-existing-cluster) .```\n\"networkConfig\": {\n ...\n \"gatewayApiConfig\": {\n \"channel\": \"CHANNEL_STANDARD\"\n },\n ...\n},\n```\n- Confirm the GatewayClasses are installed in your cluster:```\nkubectl get gatewayclass\n```The output is similar to the following:\n```\n```none {:.devsite-disable-click-to-copy}NAME \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 CONTROLLER \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ACCEPTED \u00a0 AGEgke-l7-global-external-managed \u00a0 networking.gke.io/gateway \u00a0 True \u00a0 \u00a0 \u00a0 16hgke-l7-regional-external-managed networking.gke.io/gateway \u00a0 True \u00a0 \u00a0 \u00a0 16hgke-l7-gxlb \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0networking.gke.io/gateway \u00a0 True \u00a0 \u00a0 \u00a0 16hgke-l7-rilb \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0networking.gke.io/gateway \u00a0 True \u00a0 \u00a0 \u00a0 16h```\n```\nTo understand the capabilities of each GatewayClass, see [GatewayClass capabilities](/kubernetes-engine/docs/how-to/gatewayclass-capabilities) .\n[Enabling multi-cluster Gateways](/kubernetes-engine/docs/how-to/deploying-multi-cluster-gateways)\n## Deploy an internal Gateway\nAn internal Gateway exposes applications that are only reachable from within the VPC or networks connected to the VPC.\n### Deploy a regional internal Gateway\nThe following example shows you how to deploy a regional internal Gateway that enables efficient and secure communication between services within a specific geographic region.\nYou must [configure a proxy-only subnet](/load-balancing/docs/proxy-only-subnets#proxy_only_subnet_create) before you create a Gateway that uses an internal Application Load Balancer. Each region of a VPC in which you use internal Application Load Balancers must have a proxy-only subnet. This subnet provides internal IP addresses to the load balancer proxies.\n- Create a proxy-only subnet:```\ngcloud compute networks subnets create SUBNET_NAME \\\u00a0 \u00a0 --purpose=REGIONAL_MANAGED_PROXY \\\u00a0 \u00a0 --role=ACTIVE \\\u00a0 \u00a0 --region=COMPUTE_REGION \\\u00a0 \u00a0 --network=VPC_NETWORK_NAME \\\u00a0 \u00a0 --range=CIDR_RANGE\n```Replace the following:- ``: the name of the proxy-only subnet.\n- ``: the region of the proxy-only subnet.\n- ``: the name of the VPC network that contains the subnet.\n- ``: the primary IP address range of the subnet. You must use a subnet mask no longer than`/26`so that at least 64 IP addresses are available for proxies in the region. The recommended subnet mask is`/23`.\n- Verify your proxy-only subnet:```\ngcloud compute networks subnets describe SUBNET_NAME \\\u00a0 \u00a0 --region=COMPUTE_REGION\n```The output is similar to the following:```\n...\ngatewayAddress: 10.1.1.1\nipCidrRange: 10.1.1.0/24\nkind: compute#subnetwork\nname: proxy-subnet\nnetwork: https://www.googleapis.com/compute/v1/projects/PROJECT_NAME/global/networks/default\nprivateIpGoogleAccess: false\nprivateIpv6GoogleAccess: DISABLE_GOOGLE_ACCESS\npurpose: REGIONAL_MANAGED_PROXY\nregion: https://www.googleapis.com/compute/v1/projects/PROJECT_NAME/regions/REGION\nrole: ACTIVE\nselfLink: https://www.googleapis.com/compute/v1/projects/PROJECT_NAME/regions/REGION/subnetworks/proxy-subnet\nstate: READY\n```A Gateway resource represents a data plane that routes traffic in Kubernetes. A Gateway can represent many different kinds of load balancing and routing depending on the GatewayClass it is derived from. To learn more about the Gateway resource, see the [Gateway resource](https://gateway-api.sigs.k8s.io/api-types/gateway/) description or the [API specification](https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.Gateway) .\nIn this case, the administrator of the GKE cluster wants to create a Gateway that can be used by different teams to expose their applications internally. The administrator deploys the Gateway, and application teams deploy their Routes independently and attach them to this Gateway.\n- Save the following Gateway manifest to a file named `gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: internal-httpspec:\u00a0 gatewayClassName: gke-l7-rilb\u00a0 listeners:\u00a0 - name: http\u00a0 \u00a0 protocol: HTTP\u00a0 \u00a0 port: 80\n```This manifest includes the following fields:- `gatewayClassName: gke-l7-rilb`: specifies the GatewayClass that this Gateway is derived from.`gke-l7-rilb`corresponds to the internal Application Load Balancer.\n- `port: 80`: specifies that the Gateway exposes only port 80 for listening for HTTP traffic.\n- Deploy the Gateway in your cluster:```\nkubectl apply -f gateway.yaml\n```\n- Validate that the Gateway has deployed correctly. It might take a few minutes for it to deploy all of its resources.```\nkubectl describe gateways.gateway.networking.k8s.io internal-http\n```The output is similar to the following:```\nName:   internal-http\nNamespace: default\nSpec:\n Gateway Class Name: gke-l7-rilb\n Listeners:\n Allowed Routes:\n  Kinds:\n  Group: gateway.networking.k8s.io\n  Kind: HTTPRoute\n  Namespaces:\n  From: Same\n Name:  http\n Port:  80\n Protocol: HTTP\nStatus:\n Addresses:\n Type: IPAddress\n Value: 192.168.1.14\n Conditions:\n Last Transition Time: 1970-01-01T00:00:00Z\n Message:    Waiting for controller\n Reason:    NotReconciled\n Status:    False\n Type:     Scheduled\nEvents:\n Type Reason Age    From      Message\n ---- ------ ----    ----      ------ Normal ADD  92s    networking.gke.io/gateway test/internal-http\n Normal UPDATE 45s (x3 over 91s) networking.gke.io/gateway test/internal-http\n Normal SYNC 45s    networking.gke.io/gateway SYNC on test/internal-http was a success\n```At this point, there is a Gateway deployed in your cluster that has provisioned a load balancer and an IP address. The Gateway has no Routes, however, and so it doesn't know how it should send traffic to backends. Without Routes, all traffic goes to a default backend, which returns an HTTP 404. Next, you deploy an application and Routes, which tell the Gateway how to get to application backends.Application teams can deploy their applications and Routes independently from the deployment of Gateways. In some cases the application team might want to own the Gateway as well and deploy it themselves as a resource dedicated to their applications. See [Routebinding](https://gateway-api.sigs.k8s.io/concepts/api-overview/#route-binding) for different ownership models of Gateways and Routes. In this example however, the store team deploys their application and an accompanying HTTPRoute to expose their app through the `internal-http` Gateway created in the previous section.\nThe HTTPRoute resource has many configurable fields for traffic matching. For an explanation of HTTPRoute's fields, see the [API specification](https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.HTTPRoute) .\n- Deploy the store application (store-v1, store-v2, and store-german deployments) to your cluster:```\nkubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/gke-networking-recipes/main/gateway/gke-gateway-controller/app/store.yaml\n```This creates three Deployments and three Services which are named store-v1, store-v2, and store-german.\n- Validate that the application has deployed successfully:```\nkubectl get pod\n```The output is similar to the following after the application is running:```\nNAME      READY STATUS RESTARTS AGE\nstore-german-66dcb75977-5gr2n 1/1  Running 0   38s\nstore-v1-65b47557df-jkjbm  1/1  Running 0   14m\nstore-v2-6856f59f7f-sq889  1/1  Running 0   14m\n```\n- Validate that the Services have been deployed:```\nkubectl get service\n```The output shows a Service for each store Deployment:```\nNAME   TYPE  CLUSTER-IP EXTERNAL-IP PORT(S) AGE\nstore-german ClusterIP 10.48.3.183 <none>  8080/TCP 4s\nstore-v1  ClusterIP 10.48.2.224 <none>  8080/TCP 5s\nstore-v2  ClusterIP 10.48.4.48 <none>  8080/TCP 5s\n```Route resources define protocol-specific rules for mapping traffic from a Gateway to Kubernetes backends. The [HTTPRouteresource](/kubernetes-engine/docs/concepts/gateway-api#httproute) does HTTP and HTTPS traffic matching and filtering and is supported by all of the `gke-l7` GatewayClasses.\nIn this section, you deploy an HTTPRoute, which programs the Gateway with the routing rules needed to reach your store application.\n- Save the following HTTPRoute manifest to a file named `store-route.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: storespec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: internal-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 port: 8080\u00a0 - matches:\u00a0 \u00a0 - headers:\u00a0 \u00a0 \u00a0 - name: env\u00a0 \u00a0 \u00a0 \u00a0 value: canary\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: store-v2\u00a0 \u00a0 \u00a0 port: 8080\u00a0 - matches:\u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 value: /de\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: store-german\u00a0 \u00a0 \u00a0 port: 8080\n```\n- Deploy the HTTProute in your cluster:```\nkubectl apply -f store-route.yaml\n```The `store` HTTPRoute is bound to the `internal-http` Gateway by using the `parentRefs` property. These routing rules are configured on the underlying load balancer as in this diagram:These routing rules process HTTP traffic in the following manner:- Traffic to`store.example.com/de`goes to the Service`store-german`.\n- Traffic to`store.example.com`with the HTTP header`\"env: canary\"`goes to the Service`store-v2`.\n- The remaining traffic to`store.example.com`goes to the Service`store-v1`.\n- Verify that the HTTPRoute has been deployed:```\nkubectl describe httproute store\n```The output is similar to the following:```\nName:   store\nNamespace: default\nLabels:  <none>\nAnnotations: <none>\nAPI Version: gateway.networking.k8s.io/v1beta1\nKind:   HTTPRoute\n<...>\nSpec:\n Hostnames:\n store.example.com\n Parent Refs:\n Group: gateway.networking.k8s.io\n Kind: Gateway\n Name: internal-http\n Rules:\n Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-v1\n  Port: 8080\n  Weight: 1\n Matches:\n  Path:\n  Type: PathPrefix\n  Value: /\n Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-v2\n  Port: 8080\n  Weight: 1\n Matches:\n  Headers:\n  Name: env\n  Type: Exact\n  Value: canary\n  Path:\n  Type: PathPrefix\n  Value: /\n Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-german\n  Port: 8080\n  Weight: 1\n Matches:\n  Path:\n  Type: PathPrefix\n  Value: /de\nStatus:\n Parents:\n Conditions:\n  Last Transition Time: 2022-11-01T04:18:52Z\n  Message:\n  Reason:    Accepted\n  Status:    True\n  Type:     Accepted\n  Last Transition Time: 2022-11-01T04:18:52Z\n  Message:\n  Reason:    ReconciliationSucceeded\n  Status:    True\n  Type:     Reconciled\n Controller Name:   networking.gke.io/gateway\n Parent Ref:\n  Group: gateway.networking.k8s.io\n  Kind: Gateway\n  Name: internal-http\nEvents:\n Type Reason Age    From     Message\n ---- ------ ----    ----     ------ Normal ADD  24m    sc-gateway-controller default/store\n Normal SYNC 16m (x4 over 23m) sc-gateway-controller Bind of HTTPRoute \"default/store\" to ParentRef {Group:  gateway.networking.k8s.io\",\n <...>\n```\n- Verify that the HTTPRoute is bound to the Gateway:```\nkubectl describe gateway\n```The output is similar to the following:```\nName:   internal-http\nNamespace: default\nLabels:  <none>\n<...>\nStatus:\n Addresses:\n Type: IPAddress\n Value: 10.128.15.203\n Conditions:\n Last Transition Time: 2022-11-01T03:47:01Z\n Message:\n Reason:    Scheduled\n Status:    True\n Type:     Scheduled\n Last Transition Time: 2022-11-01T03:47:01Z\n Message:\n Reason:    Ready\n Status:    True\n Type:     Ready\n Listeners:\n Attached Routes: 1\n Conditions:\n  Last Transition Time: 2022-11-01T03:47:01Z\n  Message:\n  Reason:    Ready\n  Status:    True\n  Type:     Ready\n Name:     http\n Supported Kinds:\n  Group: gateway.networking.k8s.io\n  Kind: HTTPRoute\n  <...>\n```Now that your Gateway, Route, and application are deployed in your cluster, you can pass traffic to your application.\n- Retrieve the IP address from the Gateway so that you can send traffic to your application:```\nkubectl get gateways.gateway.networking.k8s.io internal-http -o=jsonpath=\"{.status.addresses[0].value}\"\n```The output is an IP address.\n- Send traffic to this IP address from shell on a virtual machine (VM) instance with connectivity to the cluster. You can [create a VM](/compute/docs/create-linux-vm-instance) for this purpose. This is necessary because the Gateway has an internal IP address and is only accessible from within your VPC network. Because the `internal-http` is a regional load balancer, the client shell must be within the same region as the GKE cluster.Because you don't own the example.com hostname, set the host header manually so that the traffic routing can be observed. First try requesting store.example.com:```\ncurl -H \"host: store.example.com\" VIP\n```Replace `` with the IP address from the previous step.The output from the demo app shows information about the location where the app is running:```\n{\u00a0 \"cluster_name\": \"gke1\",\u00a0 \"host_header\": \"store.example.com\",\u00a0 \"metadata\": \"store-v1\",\u00a0 \"node_name\": \"gke-gke1-pool-2-bd121936-5pfc.c.gateway-demo-243723.internal\",\u00a0 \"pod_name\": \"store-v1-84b47c7f58-pmgmk\",\u00a0 \"pod_name_emoji\": \"\ud83d\udc87\ud83c\udffc\u200d\u2640\ufe0f\",\u00a0 \"project_id\": \"gateway-demo-243723\",\u00a0 \"timestamp\": \"2022-10-25T13:31:17\",\u00a0 \"zone\": \"ZONE_NAME\"}\n```\n- Test the path match by going to the German version of the store service at `store.example.com/de` :```\ncurl -H \"host: store.example.com\" VIP/de\n```The output confirms that the request was served by a `store-german` Pod:```\n{\u00a0 \"cluster_name\": \"gke1\",\u00a0 \"host_header\": \"store.example.com\",\u00a0 \"metadata\": \"Gutentag!\", \u00a0 \"node_name\": \"gke-gke1-pool-2-bd121936-n3xn.c.gateway-demo-243723.internal\",\u00a0 \"pod_name\": \"store-german-5cb6474c55-lq5pl\", \u00a0 \"pod_name_emoji\": \"\ud83e\uddde\u200d\u2640\",\u00a0 \"project_id\": \"gateway-demo-243723\",\u00a0 \"timestamp\": \"2022-10-25T13:35:37\",\u00a0 \"zone\": \"ZONE_NAME\"}\n```\n- Finally, use the `env: canary` HTTP header to send traffic to the canary version of the store Service:```\ncurl -H \"host: store.example.com\" -H \"env: canary \" VIP\n```The output confirms that the request was served by a `store-v2` Pod:```\n{\u00a0 \"cluster_name\": \"gke1\",\u00a0 \"host_header\": \"store.example.com\",\u00a0 \"metadata\": \"store-v2\", \u00a0 \"node_name\": \"gke-gke1-pool-2-bd121936-5pfc.c.gateway-demo-243723.internal\",\u00a0 \"pod_name\": \"store-v2-5788476cbd-s9thb\", \u00a0 \"pod_name_emoji\": \"\ud83e\uddb0\",\u00a0 \"project_id\": \"gateway-demo-243723\",\u00a0 \"timestamp\": \"2022-10-25T13:38:26\",\u00a0 \"zone\": \"ZONE_NAME\"}\n```## Deploy an external Gateway\nAn external Gateway exposes applications that are reachable from the internet or networks outside of your VPC. The deployment is similar to an [internal Gateway deployment](#internal-gateway) except you must secure your applications because the Gateway is accessible to the public internet.\nYou have two options to create an external Gateway: a global external Gateway or a regional external Gateway.\nA global external Gateway uses a Global IP address (or Anycast IP address) as the frontend of the Gateway advertised in all Google Cloud Compute regions. Clients sending traffic to this Anycast IP address are routed to the closest Google location where the IP is advertised. The global external Gateway is only available in the [Premium Network Service tier](/network-tiers/docs/overview#premium_tier) .\nA regional external Gateway uses a Regional IP as the frontend of the Gateway advertised only in the local Google Cloud Compute region where the regional external Gateway is deployed. Clients sending traffic to this regional IP address are routed by their local ISP and over the Internet before reaching the Google region where the IP is advertised. The regional external Gateway is only available in the [Standard Network Service tier](/network-tiers/docs/overview#standard_tier) .\n### Deploy a global external Gateway\nThe following example shows you how to expose a store application with multiple certificates attached to the global external Gateway and grouped in a certificate map using Certificate Manager and an HTTPRoute.\nGoogle recommends that you use [Certificate Manager](/certificate-manager/docs/overview) to manage certificates when you need 15 or more certificates per Gateway or you need to use wildcard certificates.\nYou can also secure your external Gateway using Kubernetes Secrets or Google-managed SSL certificates. For more information, see [Gateway security](/kubernetes-engine/docs/concepts/gateway-security) .\nIn this section, you create certificates using Certificate Manager to secure the applications running on the cluster.\n- Enable the Certificate Manager API:```\ngcloud services enable certificatemanager.googleapis.com\n```\n- Create a certificate map:```\ngcloud beta certificate-manager maps create store-example-com-map\n```\n- Load your Google-managed certificate and keys into a Certificate:```\ngcloud beta certificate-manager certificates create store-example-com-cert \\\u00a0 \u00a0 --certificate-file=\"CERTIFICATE_FILE\" \\\u00a0 \u00a0 --private-key-file=\"PRIVATE_KEY_FILE\"\n```Replace the following:- ``: the name of the new file that you choose. The file must have the extension`.pem`. For example,`cert.pem`.\n- ``: the name of your private key file.\nFor more information, see [Create a private key and certificate](/load-balancing/docs/ssl-certificates/self-managed-certs#create-key-and-cert) .\n- Create a `CertificateMapEntry` which assigns the certificate to the certificate map:```\ngcloud beta certificate-manager maps entries create store-example-com-map-entry \\\u00a0 \u00a0 --map=store-example-com-map \\\u00a0 \u00a0 --hostname=store.example.com \\\u00a0 \u00a0 --certificates=store-example-com-cert\n```\nTo learn how to secure a Gateway using other sources for certificates, such as Kubernetes Secrets or SSL certificates, see [Secure a Gateway](/kubernetes-engine/docs/how-to/secure-gateway) .\nA Gateway resource represents a data plane that routes traffic in Kubernetes. A Gateway can represent many different kinds of load balancing and routing depending on the GatewayClass it uses.\nTo learn more about the Gateway resource, see the [Gateway resource](https://gateway-api.sigs.k8s.io/api-types/gateway/) description or the [API specification](https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.Gateway) .\nIn this section, you create a Gateway. Application teams can use the Gateway to expose their applications to the internet by deploying Routes independently and attaching them securely to the Gateway.\n- Save the following manifest to a file named `gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: external-http\u00a0 annotations:\u00a0 \u00a0 networking.gke.io/certmap: store-example-com-mapspec:\u00a0 gatewayClassName: gke-l7-global-external-managed\u00a0 listeners:\u00a0 - name: https\u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 port: 443\n```This manifest describes a Gateway with the following fields:- `gatewayClassName: gke-l7-global-external-managed`: specifies the GatewayClass for this Gateway. This gateway class uses a global external Application Load Balancer.\n- `protocol: HTTPS`and`port: 443`: specify that the Gateway exposes port 443 for HTTPS traffic. These fields enables TLS.\n- `networking.gke.io/certmap: store-example-com-map`: specifies the name of the certificate map in Certificate Manager.\nThere is no TLS section because TLS is [configured with Certificate Manager](#create_a_certificate_map) using the annotation `networking.gke.io/certmap` .\n- Apply the manifest to your cluster:```\nkubectl apply -f gateway.yaml\n```It might take a few minutes for GKE to deploy the resources.\n- Verify that the Gateway has deployed successfully:```\nkubectl describe gateway\n```The output is similar to the following:```\nName:   external-http\nNamespace: default\nLabels:  <none>\n...\nSpec:\n Gateway Class Name: gke-l7-global-external-managed\n Listeners:\n Allowed Routes:\n  Namespaces:\n  From: Same\n Name:  https\n Port:  443\n Protocol: HTTPS\n Tls:\n  Certificate Refs:\n  Group:\n  Kind: Secret\n  Name: store-example-com\n  Mode:  Terminate\n ...\n```This output shows that the Gateway deployed in your cluster has a load balancer and a public IP address. The Gateway has no Routes, which means it can't send traffic to backends. Without Routes, all traffic goes to a default backend, which returns an HTTP 404 response. In the next section, you deploy Routes, which instruct the Gateway to send traffic to backends.Application teams can deploy their applications and Routes independently from the deployment of Gateways. In some cases the application team might want to own the Gateway as well and deploy it themselves as a resource dedicated to their applications. See [Route binding](https://gateway-api.sigs.k8s.io/concepts/security-model/#1-route-binding) for different ownership models of Gateways and Routes. In this example, the store team deploys their application and an accompanying HTTPRoute to expose their app through the `external-http` Gateway created in the previous section.\nFor more information about HTTPRoute fields, see the [API specification](https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.HTTPRoute) .\n- Deploy the sample application to your cluster:```\nkubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/gke-networking-recipes/main/gateway/gke-gateway-controller/app/store.yaml\n```This sample application creates three Deployments and three Services which are named `store-v1` , `store-v2` , and `store-german` .\n- Verify that the application has deployed successfully:```\nkubectl get pod\n```The output is similar to the following:```\nNAME       READY STATUS RESTARTS AGE\nstore-german-66dcb75977-5gr2n 1/1  Running 0   38s\nstore-v1-65b47557df-jkjbm  1/1  Running 0   14m\nstore-v2-6856f59f7f-sq889  1/1  Running 0   14m\n```\n- Verify that the Services have deployed successfully:```\nkubectl get service\n```The output is similar to the following:```\nNAME   TYPE  CLUSTER-IP EXTERNAL-IP PORT(S) AGE\nstore-german ClusterIP 10.48.3.183 <none>  8080/TCP 4s\nstore-v1  ClusterIP 10.48.2.224 <none>  8080/TCP 5s\nstore-v2  ClusterIP 10.48.4.48 <none>  8080/TCP 5s\n```Route resources define protocol-specific rules for mapping traffic from a Gateway to Kubernetes backends. The [HTTPRoute resource](/kubernetes-engine/docs/concepts/gateway-api#httproute) does HTTP and HTTPS traffic matching and filtering and is supported by all of the `gke-l7-*` GatewayClasses.\nIn this section, you deploy an HTTPRoute, which configures the Gateway with routing rules required to reach the sample application.\n- Save the following manifest to a file named `store-route-external.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-externalspec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: external-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 port: 8080\u00a0 - matches:\u00a0 \u00a0 - headers:\u00a0 \u00a0 \u00a0 - name: env\u00a0 \u00a0 \u00a0 \u00a0 value: canary\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: store-v2\u00a0 \u00a0 \u00a0 port: 8080\u00a0 - matches:\u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 value: /de\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - name: store-german\u00a0 \u00a0 \u00a0 port: 8080\n```This manifest describes an HTTPRoute that references the `external-http` Gateway.\n- Apply the manifest to your cluster:```\nkubectl apply -f store-route-external.yaml\n```The `store` HTTPRoute is bound to the `external-http` Gateway by using the `parentRefs` property. These following diagram shows the routing rules configured on the underlying load balancer:The routing rules process HTTP traffic as follows:- Traffic to`store.example.com/de`routes to Service`store-german`.\n- Traffic to`store.example.com`with the HTTP header`\"env: canary\"`routes to Service`store-v2`.\n- The remaining traffic to`store.example.com`routes to Service`store-v1`.\n- Verify that the HTTPRoute has been deployed:```\nkubectl describe httproute store-external\n```The output is similar to the following:```\nName:   store-external\nNamespace: default\nLabels:  <none>\nAnnotations: <none>\nAPI Version: gateway.networking.k8s.io/v1beta1\nKind:   HTTPRoute\n<...>\nSpec:\n Hostnames:\n store.example.com\n Parent Refs:\n Group: gateway.networking.k8s.io\n Kind: Gateway\n Name: external-http\n Rules:\n Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-v1\n  Port: 8080\n  Weight: 1\n Matches:\n  Path:\n  Type: PathPrefix\n  Value: /\n Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-v2\n  Port: 8080\n  Weight: 1\n Matches:\n  Headers:\n  Name: env\n  Type: Exact\n  Value: canary\n  Path:\n  Type: PathPrefix\n  Value: /\n Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-german\n  Port: 8080\n  Weight: 1\n Matches:\n  Path:\n  Type: PathPrefix\n  Value: /de\nStatus:\n Parents:\n Conditions:\n  Last Transition Time: 2022-11-01T05:42:31Z\n  Message:\n  Reason:    Accepted\n  Status:    True\n  Type:     Accepted\n  Last Transition Time: 2022-11-01T05:43:18Z\n  Message:\n  Reason:    ReconciliationSucceeded\n  Status:    True\n  Type:     Reconciled\n Controller Name:   networking.gke.io/gateway\n Parent Ref:\n  Group: gateway.networking.k8s.io\n  Kind: Gateway\n  Name: external-http\nEvents:\n Type  Reason Age From     Message\n ----  ------ ---- ----     ------ Normal ADD  2m48s sc-gateway-controller default/store-external\n Normal SYNC 61s (x3 over 2m27s) sc-gateway-controller Bind of HTTPRoute \"default/store-external\" to ParentRef Group:  \"gateway.networking.k8s.io\",\n ...\n```\n- Verify that the HTTPRoute is bound to the Gateway:```\nkubectl describe gateway external-http\n```The output is similar to the following:```\nName:   external-http\nNamespace: default\nLabels:  <none>\n<...>\nStatus:\n Addresses:\n Type: IPAddress\n Value: 34.149.207.45\n Conditions:\n Last Transition Time: 2022-11-01T05:37:21Z\n Message:\n Reason:    Scheduled\n Status:    True\n Type:     Scheduled\n Last Transition Time: 2022-11-01T05:43:18Z\n Message:\n Reason:    Ready\n Status:    True\n Type:     Ready\n Listeners:\n Attached Routes: 1\n Conditions:\n  Last Transition Time: 2022-11-01T05:43:18Z\n  Message:\n  Reason:    Ready\n  Status:    True\n  Type:     Ready\n Name:     https\n Supported Kinds:\n  Group: gateway.networking.k8s.io\n  Kind: HTTPRoute\n  <...>\n```Now that your Gateway, Route, and application are deployed in your cluster, you can pass traffic to your application.\n- Get the IP address of the Gateway:```\nkubectl get gateways.gateway.networking.k8s.io external-http -o=jsonpath=\"{.status.addresses[0].value}\"\n```The output is an IP address.\n- Create a VM:```\ngcloud cloud-shell ssh\n```\n- Send traffic to the Gateway IP address from the VM. You must set the host header manually because you do not own the `example.com` hostname.```\ncurl -H \"host: store.example.com\" https://GATEWAY_IP_ADDRESS --resolve store.example.com:443:GATEWAY_IP_ADDRESS --cacert cacert.pem -v\n```Replace `` with the IP address of the Gateway from the previous step.The output shows information from the demo app about the location where the app is running:```\n{\n \"cluster_name\": \"gke1\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"store-v1\",\n \"node_name\": \"gke-gke1-pool-2-bd121936-5pfc.c.gateway-demo-243723.internal\",\n \"pod_name\": \"store-v1-84b47c7f58-pmgmk\",\n \"pod_name_emoji\": \"\ud83d\udc87\ud83c\udffc\u200d\u2640\ufe0f\",\n \"project_id\": \"gateway-demo-243723\",\n \"timestamp\": \"2022-09-25T13:31:17\",\n \"zone\": \"us-central1-a\"\n}\n```\n- Test the path match by going to the German version of the `store` service at `store.example.com/de` :```\ncurl -H \"host: store.example.com\" https://GATEWAY_IP_ADDRESS/de --resolve store.example.com:443:GATEWAY_IP_ADDRESS --cacert cacert.pem -v\n```The output confirms that the request was served by a `store-german` Pod:```\n{\n \"cluster_name\": \"gke1\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"Gutentag!\",\n \"node_name\": \"gke-gke1-pool-2-bd121936-n3xn.c.gateway-demo-243723.internal\",\n \"pod_name\": \"store-german-5cb6474c55-lq5pl\",\n \"pod_name_emoji\": \"\ud83e\uddde\u200d\u2640\",\n \"project_id\": \"gateway-demo-243723\",\n \"timestamp\": \"2022-09-25T13:35:37\",\n \"zone\": \"us-central1-a\"\n}\n```\n- Send traffic to the canary version of the `store` Service using the `env: canary` HTTP header:```\ncurl -H \"host: store.example.com\" -H \"env: canary \" https://GATEWAY_IP_ADDRESS/de --resolve store.example.com:443:GATEWAY_IP_ADDRESS --cacert cacert.pem -v\n```The output confirms that the request was served by a `store-v2` Pod:```\n{\n \"cluster_name\": \"gke1\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"store-v2\",\n \"node_name\": \"gke-gke1-pool-2-bd121936-5pfc.c.gateway-demo-243723.internal\",\n \"pod_name\": \"store-v2-5788476cbd-s9thb\",\n \"pod_name_emoji\": \"\ud83d\udc69\ud83c\udfff\",\n \"project_id\": \"gateway-demo-243723\",\n \"timestamp\": \"2022-09-25T13:38:26\",\n \"zone\": \"us-central1-a\"\n}\n```\n### Deploy a regional external Gateway\nThe following example shows you how to expose a store application with multiple certificates attached to the regional external Gateway using self-managed certificates and an HTTPRoute.\nYou must [configure a proxy-only subnet](#configure_a_proxy-only_subnet) before you create a Gateway that uses a [regional external Application Load Balancer](#deploy_a_regional_internal_gateway) . Each region of a VPC in which you use regional external Application Load Balancer must have an `external_managed_proxy` subnet. This subnet provides internal IP addresses to the load balancer proxies.\nYou can use a certificate issued and validated by your certificate authority (CA) or create a self-signed certificate. For more information on how to create a certificate, see [Store a certificate in a Kubernetes Secret](/kubernetes-engine/docs/how-to/secure-gateway#store-certificate-secret) .\n**Note:** CertificateMap or Google-managed SSL certificates are not supported with regional Gateways. Use self-managed regional SSL certificates or secrets to secure traffic between your clients and your regional Gateway. For more information about Certificate and Google Cloud load balancers, see [Certificates and Google Cloud load balancers](/load-balancing/docs/ssl-certificates#certificate-summary)- Create a regional static IP address for the external load balancer.```\ngcloud compute addresses create IP_ADDRESS_NAME \\\u00a0 --region=COMPUTE_REGION \\\u00a0 --network-tier=STANDARD\n```Replace the following:- ``: the name of the new static IP address.\n- ``: The Compute Engine region where your cluster is running.\n- Create a regional external Application Load Balancer Gateway using a self-managed certificate as follows and save the manifest as `regional-gateway.yaml` :```\n\u00a0 kind: Gateway\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 metadata:\u00a0 \u00a0 name: external-regional-http\u00a0 spec:\u00a0 \u00a0 gatewayClassName: gke-l7-regional-external-managed\u00a0 \u00a0 listeners:\u00a0 \u00a0 - name: https\u00a0 \u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 \u00a0 port: 443\u00a0 \u00a0 \u00a0 tls:\u00a0 \u00a0 \u00a0 \u00a0 mode: Terminate\u00a0 \u00a0 \u00a0 \u00a0 certificateRefs:\u00a0 \u00a0 \u00a0 \u00a0 - name: store-example-com\u00a0 \u00a0 addresses:\u00a0 \u00a0 - type: NamedAddress\u00a0 \u00a0 \u00a0 value: IP_ADDRESS_NAME\n```\n- Apply the `regional-gateway` manifest:```\n\u00a0 kubectl apply -f regional-gateway.yaml\n```\n- Verify your configuration.```\n\u00a0 kubectl get gateway\n```The output is similar to the following:```\nNAME   CLASS        ADDRESS   READY AGE\nexternal-http gke-l7-regional-external-managed 35.118.32.224 True 49s\n```To get more details, use a describe command:```\nkubectl describe gateway\n```The output is similar to the following:```\nName:   external-regional-http\nNamespace: default\nLabels:  <none>\n...\nSpec:\n Gateway Class Name: gke-l7-regional-external-managed\n Listeners:\n Allowed Routes:\n  Namespaces:\n  From: Same\n Name:  https\n Port:  443\n Protocol: HTTPS\n Tls:\n  Certificate Refs:\n  Group:\n  Kind: Secret\n  Name: store-example-com\n  Mode:  Terminate\n ...\n```You can deploy your applications and routes independently from the deployment of Gateways.\n[Deploy the demo applications](#deploy_the_demo_applications_2)\nYou must [create an HTTPRoute](#create_an_httproute) to do HTTP and HTTPS traffic matching and filtering.\nAfter you have deployed your application and created HTTPRoutes, you can pass traffic to your application.\n[Send traffic to your application](#send_traffic_to_your_application_2)\n## Use shared Gateways\nThe Gateway APIs use separate resources, Gateways and Route resources, to deploy load balancers and routing rules. This differs from Ingress, which combines everything in one resource. By splitting responsibility among resources, Gateway enables the load balancer and its routing rules to be deployed separately and to be deployed by different users or teams. This enables Gateways to become shared Gateways that attach with many different Routes that can be fully owned and managed by independent teams, even across different namespaces.\n### Deploy routes against a shared Gateway\nThis example builds on the `internal-http` Gateway deployed in [Deploy an internal Gateway](#internal-gateway) .\nIn this example, the site team deploys their application, Services, and an HTTPRoute to match traffic from the Gateway to those Services.\n- Deploy the example application:```\nkubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/gke-networking-recipes/main/gateway/gke-gateway-controller/app/site.yaml\n```\n- Save the following manifest to a file named `site-route-internal.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: site-internalspec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: internal-http\u00a0 hostnames:\u00a0 - \"site.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: site-v1\u00a0 \u00a0 \u00a0 port: 8080\n```This manifest describes an HTTPRoute that matches all traffic for `site.example.com` and routes it to the `site-v1` Service.\n- Apply the manifest to your cluster:```\nkubectl apply -f site-route-internal.yaml\n```\n- Verify that the HTTPRoute is attached to the Gateway:```\nkubectl describe httproute.gateway.networking.k8s.io site-internal\n```The output is similar to the following:```\nStatus:\n Parents:\n Conditions:\n  Last Transition Time: 2023-01-09T15:05:43Z\n  Message:\n  Reason:    Accepted\n  Status:    True\n  Type:     Accepted\n  Last Transition Time: 2023-01-09T15:05:43Z\n  Message:\n  Reason:    ReconciliationSucceeded\n  Status:    True\n  Type:     Reconciled\n Controller Name:   networking.gke.io/gateway\n Parent Ref:\n  Group: gateway.networking.k8s.io\n  Kind: Gateway\n  Name: internal-http\n  ...\n```If the `Accepted` condition for the Gateway is `True` , the HTTPRoute has successfully bound to the Gateway. To learn more about the Status field, see [route status](#route-status) .\n- Verify that traffic to the Gateway is routed correctly:```\ncurl -H \"host: site.example.com\" GATEWAY_IP_ADDRESScurl -H \"host: store.example.com\" GATEWAY_IP_ADDRESS\n```Replace `` with the IP address of the Gateway.You must use a virtual machine (VM) in the same VPC as the Gateway.The output is similar to the following:```\n{\n \"cluster_name\": \"CLUSTER_NAME\",\n \"host_header\": \"site.example.com\",\n \"metadata\": \"site-v1\",\n \"pod_name\": \"site-v1-5d64fc4d7d-fz6f6\",\n \"pod_name_emoji\": \"\ud83d\udc69\ud83c\udffc\u200d\ud83c\udf73\",\n \"project_id\": \"PROJECT_ID\",\n \"timestamp\": \"2022-11-02T19:07:01\",\n \"zone\": \"ZONE_NAME\"\n}\n...\n{\n \"cluster_name\": \"CLUSTER_NAME\",\n \"host_header\": \"store.example.com\",\n \"metadata\": \"store-v1\",\n \"pod_name\": \"store-v1-6d8d58d78-vz8pn\",\n \"pod_name_emoji\": \"\ud83e\udddd\ud83c\udffb\u200d\u2642\ufe0f\",\n \"project_id\": \"PROJECT_ID\",\n \"timestamp\": \"2022-11-02T19:07:01\",\n \"zone\": \"ZONE_NAME\"\n}\n```## Configure the Gateway default backend\nAll of the `gke-l7-*` GatewayClasses return HTTP 404 to unmatched traffic. You can configure the default backend using an explicit default Route that sends unmatched traffic to a user-provided Service.\n**Note:** Gateways are configured to handle error codes like 404 (Not Found) and 500 (Server Error) even without explicit backend definitions. The default behavior may vary between Gateway implementations. For greater control over error handling, consider configuring custom backends.\nThe following HTTPRoute is an example of how to customize the default backend. If you apply an HTTPRoute similar to the following, it takes precedence over the implicit default backend:\n```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: custom-default-backendspec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: my-internal-gateway\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: my-custom-default-backend-service\u00a0 \u00a0 \u00a0 port: 8080\n```\nThis HTTPRoute matches all traffic from a particular Gateway. You can only have one such rule for each Gateway or else the rules conflict and [precedence ordering](#route-merging) applies.\nYou can use a default backend to prevent someone from creating a default route Backend that routes all Gateway traffic. An explicit HTTPRoute always takes precedence over new HTTPRoutes with conflicting routing rules.\n## Configure a static IP address for a Gateway\nEvery Gateway has an IP address it uses to listen for traffic. If you do not specify an IP address on the Gateway, then the Gateway controller automatically provides an IP address. You can also create a static IP address so that the IP address exists independent of the Gateway lifecycle.\nAfter a Gateway is deployed, its IP address shows in the status field:\n```\nkind: Gateway...status:\u00a0 addresses:\u00a0 \u00a0 - value: 10.15.32.3\n```\nDepending on the GatewayClass, the IP address is allocated from the following subnets:\n| GatewayClasses                    | Default IP Address Pool              |\n|:--------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------|\n| gke-l7-rilb gke-l7-rilb-mc                 | Regional private IP addresses from the primary node IPv4/IPv6 address range |\n| gke-l7-regional-external-managed gke-l7-regional-external-managed-mc      | Regional public IP addresses from Google's regional external IPv4/IPv6 ranges |\n| gke-l7-global-external-managed gke-l7-global-external-managed-mc gke-l7-gxlb gke-l7-gxlb-mc | Global public IP addresses from Google's global external IPv4/IPv6 ranges  |\nThe field `addresses.NamedAddress` lets you specify an IP address independently of the Gateway. You can create a static IP address resource prior to Gateway deployment and the resource is referenced by the `NamedAddress` . You can reuse the static IP address even if the Gateway is deleted.\n### Use a named IP address\nYou can configure an IP address by specifying a `NamedAddress` . You must provision a static IP address before you create a Gateway.\n- Create a static IP address resource:```\ngcloud compute addresses create IP_ADDRESS_NAME \\\u00a0 \u00a0 --purpose=SHARED_LOADBALANCER_VIP \\\u00a0 \u00a0 --region=COMPUTE_REGION \\\u00a0 \u00a0 --subnet=SUBNET \\\u00a0 \u00a0 --project=PROJECT_ID\n```Replace the following:- ``: the name of the new static IP address\n- ``: for regional Gateways, the Compute Engine region where your cluster is running. This flag is not needed for global, external Gateways.\n- ``: the subnet for the IP address. This flag is not needed for global, external Gateways.\n- ``: the project where your GKE cluster is running.\n- Save the following manifest to a file named `named-ip-gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: internal-httpspec:\u00a0 gatewayClassName: gke-l7-rilb\u00a0 listeners:\u00a0 - name: http\u00a0 \u00a0 protocol: HTTP\u00a0 \u00a0 port: 80\u00a0 addresses:\u00a0 - type: NamedAddress\u00a0 \u00a0 value: IP_ADDRESS_NAME\n```This manifest describes a Gateway that references the named IP address.\n- Apply the manifest to your cluster:```\nkubectl apply -f named-ip-gateway.yaml\n```\n- Verify your Gateway IP address:```\nkubectl describe gateway internal-http\n```The output is similar to the following:```\nName:   internal-http\nNamespace: default\nLabels:  <none>\n...\nSpec:\n Addresses:\n Type:    NamedAddress\n Value:    IP_ADDRESS_NAME\n Gateway Class Name: gke-l7-rilb\n Listeners:\n Allowed Routes:\n  Namespaces:\n  From: Same\n Name:  http\n Port:  80\n Protocol: HTTP\nStatus:\n Addresses:\n Type: IPAddress\n Value: 10.15.32.103\n```## Configure HTTP-to-HTTPS redirects\nCloud Load Balancing offers HTTP to HTTPS redirect functionality. An external Application Load Balancer redirects unencrypted HTTP requests to an HTTPS load balancer that uses the same IP address. When you create a Gateway with HTTP-to-HTTPS redirects enabled, both of these load balancers are created automatically. Requests to the external IP address of the Gateway on port 80 are automatically redirected to the same external IP address on port 443.\nBy default, HTTP to HTTPS redirects are not defined on the Gateway.\nTo redirect HTTP traffic to HTTPS, configure a Gateway to handle both HTTP and HTTPS traffic. If you disable either HTTP or HTTPS, the Gateway does not redirect traffic.\nThe following examples show you how you can use HTTP-to-HTTPS redirect as a mean to ensure that traffic from your clients going to your web applications is always being redirected to a secure page.\n**Note:** HTTP-to-HTTPS redirects is not supported with the `gke-l7-gxlb` and `gke-l7-gxlb-mc` GatewayClasses. To learn more about the different features supported with each GatewayClass, see [GatewayClass capabilities](/kubernetes-engine/docs/how-to/gatewayclass-capabilities)\n### Redirect HTTP traffic from the Gateway namespace\nIn the following example, the Gateway is configured to allow `Same` (Attachment from Same namespace) on the HTTP listener, while the HTTPS listener is opened to all namespaces. When using this configuration, only the redirect `HTTPRoute` should exist in the same namespace as the Gateway.\nThis configuration ensures that no additional HTTPRoutes can bind to the Gateway's HTTP listener. This requires that the HTTPRoutes of the application team are not allowed in the `gateway-infra` namespace.\n- Create the Gateway's namespace `gateway-infra` . Save the manifest as `gateway-namespace.yaml` :```\napiVersion: v1kind: Namespacemetadata:\u00a0 name: gateway-infra\n```\n- Apply the manifest:```\nkubectl apply -f gateway-namespace.yaml\n```\n- Create a Gateway using the following manifest and save the manifest as `external-gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: external-http\u00a0 namespace: gateway-infraspec:\u00a0 gatewayClassName: gke-l7-global-external-managed\u00a0 listeners:\u00a0 - name: http\u00a0 \u00a0 protocol: HTTP\u00a0 \u00a0 port: 80\u00a0 \u00a0 allowedRoutes:\u00a0 \u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - kind: HTTPRoute\u00a0 \u00a0 \u00a0 namespaces:\u00a0 \u00a0 \u00a0 \u00a0 from: Same\u00a0 - name: https\u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 port: 443\u00a0 \u00a0 allowedRoutes:\u00a0 \u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - kind: HTTPRoute\u00a0 \u00a0 \u00a0 namespaces:\u00a0 \u00a0 \u00a0 \u00a0 from: All\u00a0 \u00a0 tls:\u00a0 \u00a0 \u00a0 mode: Terminate\u00a0 \u00a0 \u00a0 options:\u00a0 \u00a0 \u00a0 \u00a0 networking.gke.io/pre-shared-certs: store-example-com\n```- The `namespaces` field in the `allowedRoutes` section restricts the http listener to the namespace `gateway-infra` of the Gateway only.\n- The https listener doesn't include a restriction on the allowed namespaces, so all namespaces use the https listener with an HTTPRoute.\n- Apply the manifest:```\nkubectl apply -f external-gateway.yaml\n```\n- To force the HTTPS redirect, create a default HTTPRoute using the following manifest and save the manifest as `redirect-httproute.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: redirect\u00a0 namespace: gateway-infraspec:\u00a0 parentRefs:\u00a0 - namespace: gateway-infra\u00a0 \u00a0 name: external-http\u00a0 \u00a0 sectionName: http\u00a0 rules:\u00a0 - filters:\u00a0 \u00a0 - type: RequestRedirect\u00a0 \u00a0 \u00a0 requestRedirect:\u00a0 \u00a0 \u00a0 \u00a0 scheme: https\n```- The`sectionName`field instructs the Gateway to match only on the http listener. The`RequestRedirect`filter forces the redirection to the https listener.\nThis configuration redirects any traffic received on port 80 of the Gateway to the listener on port 443 enforcing a secure communication between the client and the load balancer.\n- Apply the manifest:```\nkubectl apply -f redirect-httproute.yaml\n```\n- Create a Service for an application using the following manifest. Save the manifest as `service-deployment.yaml` :```\napiVersion: v1kind: Servicemetadata:\u00a0 name: store-v1spec:\u00a0 selector:\u00a0 \u00a0 app: store\u00a0 \u00a0 version: v1\u00a0 ports:\u00a0 - port: 8080\u00a0 \u00a0 targetPort: 8080---apiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: store-v1spec:\u00a0 replicas: 2\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: store\u00a0 \u00a0 \u00a0 version: v1\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: store\u00a0 \u00a0 \u00a0 \u00a0 version: v1\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: whereami\u00a0 \u00a0 \u00a0 \u00a0 image: us-docker.pkg.dev/google-samples/containers/gke/whereami:v1.2.20\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 8080\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: METADATA\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"store-v1\"\n```\n- Apply the manifest:```\nkubectl apply -f service-deployment.yaml\n```\n- Create an HTTPRoute for an application that only allows HTTPS. Save the manifest as `httproute.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-external\u00a0 labels:\u00a0 \u00a0 gateway: external-httpspec:\u00a0 parentRefs:\u00a0 - name: external-http\u00a0 \u00a0 namespace: gateway-infra\u00a0 \u00a0 sectionName: https\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 port: 8080\n```\n- Apply the manifest:```\nkubectl apply -f httproute.yaml\n```\n### Redirect HTTP traffic from an infrastructure namespace\nIn some cases, there isn't a clear distinction between the infrastructure or platform admin team and the application teams and preventing misuse of the Gateway can become a challenge.\nThe following example further restricts the use of the HTTP listener to prevent unintentional use of non-secure protocol from the application teams. This example configures the Gateway to allow an HTTPRoute to use the HTTP listener only if the route is in a given namespace (http-redirect) while it opens the HTTPS listener to all namespaces. You can restrict the http-redirect namespace using Kubernetes RBAC so that application teams cannot create an HTTPRoute in this namespace by mistake.\n- Create the namespace of a Gateway. Save the manifest as `gateway-namespace.yaml` :```\napiVersion: v1kind: Namespacemetadata:\u00a0 name: gateway-infra\n```\n- Apply the manifest:```\nkubectl apply -f gateway-namespace.yaml\n```\n- Create the namespace of a Gateway and save the manifest as `redirect-namespace.yaml` :```\napiVersion: v1kind: Namespacemetadata:\u00a0 name: http-redirect\u00a0 labels:\u00a0 \u00a0 otherInfra: httpToHttps\n```- Specific labels are set for this namespace.\n- Apply the manifest:```\nkubectl apply -f redirect-namespace.yaml\n```\n- To restrict the http listener usage, create a Gateway using the following manifest. Save the manifest as `external-gateway.yaml` :```\nkind: GatewayapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: external-http\u00a0 namespace: gateway-infraspec:\u00a0 gatewayClassName: gke-l7-global-external-managed\u00a0 listeners:\u00a0 - name: http\u00a0 \u00a0 protocol: HTTP\u00a0 \u00a0 port: 80\u00a0 \u00a0 allowedRoutes:\u00a0 \u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - kind: HTTPRoute\u00a0 \u00a0 \u00a0 namespaces:\u00a0 \u00a0 \u00a0 \u00a0 from: selector\u00a0 \u00a0 \u00a0 \u00a0 selector:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 otherInfra: httpToHttps\u00a0 - name: https\u00a0 \u00a0 protocol: HTTPS\u00a0 \u00a0 port: 443\u00a0 \u00a0 allowedRoutes:\u00a0 \u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - kind: HTTPRoute\u00a0 \u00a0 \u00a0 namespaces:\u00a0 \u00a0 \u00a0 \u00a0 from: All\u00a0 \u00a0 tls:\u00a0 \u00a0 \u00a0 mode: Terminate\u00a0 \u00a0 \u00a0 options:\u00a0 \u00a0 \u00a0 \u00a0 networking.gke.io/pre-shared-certs: store-example-com\u00a0 ```\n```- The `namespace` field specifies that the Gateway is created in the `gateway-infra` namespace.\n- The `namespaces` field in the `allowedRoutes` section restricts the http listener to the namespace matching the label `otherInfra: httpToHttps` .\n- Apply the manifest:```\nkubectl apply -f external-gateway.yaml\n```\n- To force the HTTPS redirect, create a default HTTPRoute using the following manifest. Save the manifest as `http-redirect.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: redirect\u00a0 namespace: http-redirectspec:\u00a0 parentRefs:\u00a0 - namespace: gateway-infra\u00a0 \u00a0 name: external-http\u00a0 \u00a0 sectionName: http\u00a0 rules:\u00a0 - filters:\u00a0 \u00a0 - type: RequestRedirect\u00a0 \u00a0 \u00a0 requestRedirect:\u00a0 \u00a0 \u00a0 \u00a0 scheme: https\n```- The`sectionName`field instructs the Gateway to match only on the http listener. The`RequestRedirect`filter forces the redirection to the https listener.\n- Apply the manifest:```\nkubectl apply -f http-redirect.yaml\n```\n- Create a Service for an application using the following manifest. Save the manifest as `service-deployment.yaml` :```\napiVersion: v1kind: Servicemetadata:\u00a0 name: store-v1spec:\u00a0 selector:\u00a0 \u00a0 app: store\u00a0 \u00a0 version: v1\u00a0 ports:\u00a0 - port: 8080\u00a0 \u00a0 targetPort: 8080---apiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: store-v1spec:\u00a0 replicas: 2\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: store\u00a0 \u00a0 \u00a0 version: v1\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: store\u00a0 \u00a0 \u00a0 \u00a0 version: v1\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: whereami\u00a0 \u00a0 \u00a0 \u00a0 image: us-docker.pkg.dev/google-samples/containers/gke/whereami:v1.2.20\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 8080\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: METADATA\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"store-v1\"\n```\n- Apply the manifest:```\nkubectl apply -f service-deployment.yaml\n```\n- Create an HTTPRoute for an application that only allows HTTPS using the following manifest. Save the manifest as `http-route.yaml` :```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-external\u00a0 labels:\u00a0 \u00a0 gateway: external-httpspec:\u00a0 parentRefs:\u00a0 - name: external-http\u00a0 \u00a0 namespace: gateway-infra\u00a0 \u00a0 sectionName: https\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 port: 8080\n```\n- Apply the manifest:```\nkubectl apply -f http-route.yaml\n```## Configure path redirects and URL rewrites\n[Path redirects](https://gateway-api.sigs.k8s.io/guides/http-redirect-rewrite/#redirects) involve redirecting an incoming request from one URL path to another. Path redirects let you change the structure of the URL when you need to handle outdated or deprecated URLs.\n[URL rewrites](https://gateway-api.sigs.k8s.io/guides/http-redirect-rewrite/#rewrites) help modify the incoming URL before processing it on the server. It allows you to change the structure or format of the URL without actually changing the underlying content or file structure. URL rewriting is beneficial for creating user-friendly and SEO-friendly URLs that are easy to remember and understand. By default, path redirects and URL rewrites are not configured, you need to explicitly configure those redirects or rewrites using a filter in your HTTPRoute.\nGKE Gateway supports path redirects and URL rewrites. For more information, see [HTTP path redirects and rewrites](https://gateway-api.sigs.k8s.io/guides/http-redirect-rewrite/) .\n### Configure path redirects\nYou can configure path redirects to either replace the entire path or only a prefix in the URL.- To replace an entire path, configure a filter in an HTTPRoute that replaces any URL that contains the prefix `/any-path` in the URL path by the strict value `/new-path` .\n- Create an `HTTPRoute` manifest as follows and name it as `store.yaml` :```\n\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 kind: HTTPRoute\u00a0 metadata:\u00a0 \u00a0 name: store\u00a0 spec:\u00a0 \u00a0 parentRefs:\u00a0 \u00a0 \u00a0 - kind: Gateway\u00a0 \u00a0 \u00a0 \u00a0 name: external-http\u00a0 \u00a0 hostnames:\u00a0 \u00a0 - store.example.com\u00a0 \u00a0 rules:\u00a0 \u00a0 - matches:\u00a0 \u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: PathPrefix\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: /any-path\u00a0 \u00a0 \u00a0 filters:\u00a0 \u00a0 \u00a0 - type: RequestRedirect\u00a0 \u00a0 \u00a0 \u00a0 requestRedirect:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: ReplaceFullPath\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 replaceFullPath: /new-path\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 statusCode: 302\n```For example, this manifest sets a routing rule for an HTTPRoute as follows: Any route to the URL [https://store.example.com/any-path/...](https://store.example.com/v2/%E2%80%A6) should be redirected to a new location, [https://store.example.com/new-path/](https://store.example.com) (strict).\n- Apply the manifest:```\nkubectl apply -f store.yaml\n```\nThis routing rule follows a strict redirection rule, which means that the browser does not attempt to cache the redirect, instead, redirects to the latest version.- To replace a prefix only, configure a filter in an HTTPRoute that replaces any URL that contains the prefix `/any-prefix` in the URL path by the strict value `/new-prefix` .\n- Create an `HTTPRoute` manifest as follows and name it as `store.yaml` :```\napiVersion: gateway.networking.k8s.io/v1beta1kind: HTTPRoutemetadata:\u00a0 name: storespec:\u00a0 parentRefs:\u00a0 \u00a0 - kind: Gateway\u00a0 \u00a0 \u00a0 name: external-http\u00a0 hostnames:\u00a0 - store.example.com\u00a0 rules:\u00a0 - matches:\u00a0 \u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: PathPrefix\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: /any-prefix\u00a0 \u00a0 filters:\u00a0 \u00a0 - type: RequestRedirect\u00a0 \u00a0 \u00a0 requestRedirect:\u00a0 \u00a0 \u00a0 \u00a0 path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: ReplacePrefixMatch\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 replacePrefixMatch: /new-prefix\u00a0 \u00a0 \u00a0 \u00a0 statusCode: 302\n```For example, this manifest sets a routing rule for an HTTPRoute as follows: Any route to the URL [https://store.example.com/any-path/v1/...](https://store.example.com/v2/%E2%80%A6) should be redirected to a new location, [https://store.example.com/new-path/v1/...](https://store.example.com) (only).\n- Apply the manifest:```\n\u00a0 kubectl apply -f store.yaml\n```\nThis routing rule follows the only redirection rule, which ensures that the browser always redirects you to the same intended page.\n### Configure URL rewrites\nSet URL rewrites to change the way a URL appears to users. You can use URL rewrites to make URLs more user-friendly, to improve SEO, or to redirect users to a new page.\nTo rewrite the entire hostname:\n- Configure a filter in an HTTPRoute that instructs the Gateway to replace the `Host` information in the request header from [www.example.com](https://www.example.com) to [store.example.com](/kubernetes-engine/docs/how-to/store.example.com) before forwarding the request to the backend service.\n- Create an `HTTPRoute` manifest as follows and name it as `www.yaml` :```\n\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 kind: HTTPRoute\u00a0 metadata:\u00a0 \u00a0 name: www\u00a0 spec:\u00a0 \u00a0 parentRefs:\u00a0 \u00a0 \u00a0 - kind: Gateway\u00a0 \u00a0 \u00a0 \u00a0 name: external-http\u00a0 \u00a0 hostnames:\u00a0 \u00a0 - www.example.com\u00a0 \u00a0 rules:\u00a0 \u00a0 - filters:\u00a0 \u00a0 \u00a0 - type: URLRewrite\u00a0 \u00a0 \u00a0 \u00a0 urlRewrite:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hostname: store.example.com\u00a0 \u00a0 \u00a0 backendRefs:\u00a0 \u00a0 \u00a0 - name: store-v1\u00a0 \u00a0 \u00a0 \u00a0 port: 8080\n```For example, with the above configuration, any request to [https://www.example.com](https://store.example.com/v2/...) is forwarded to the backend service with the `Host: store.example.com` header, instead of `Host: www.example.com` .\n- Apply the manifest:```\n\u00a0 kubectl apply -f www.yaml\n```You can combine rewrites with path modifiers to provide advanced URL and path modifications before relaying the request to the backend service.\nTo rewrite using path modifiers:\n- Configure a filter in an HTTPRoute that instructs the Gateway to replace the 'Host' information in the request header from [www.example.com](http://www.example.com) to [store.example.com](http://store.example.com) and replace the value `/store` by `/` before forwarding the request to the backend service.\n- Create an `HTTPRoute` manifest as follows and name it as `www.yaml` :```\n\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 kind: HTTPRoute\u00a0 metadata:\u00a0 \u00a0 name: www\u00a0 spec:\u00a0 \u00a0 parentRefs:\u00a0 \u00a0 \u00a0 - kind: Gateway\u00a0 \u00a0 \u00a0 \u00a0 name: external-http\u00a0 \u00a0 hostnames:\u00a0 \u00a0 - www.example.com\u00a0 \u00a0 rules:\u00a0 \u00a0 - matches:\u00a0 \u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: PathPrefix\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: /store\u00a0 \u00a0 \u00a0 filters:\u00a0 \u00a0 \u00a0 - type: URLRewrite\u00a0 \u00a0 \u00a0 \u00a0 urlRewrite:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hostname: store.example.com\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: ReplacePrefixMatch\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 replacePrefixMatch: /de\u00a0 \u00a0 \u00a0 backendRefs:\u00a0 \u00a0 \u00a0 - name: store-german\u00a0 \u00a0 \u00a0 \u00a0 port: 8080\n```For example, with the above configuration, any request to [https://www.example.com/store/...](https://store.example.com/v2/...) is forwarded to the backend service with `Host: store.example.com` in the request header (instead of `Host: www.example.com` ) and the `/store` is rewritten to `/de` .\n- Apply the manifest:```\nkubectl apply -f www.yaml\n```\n### Verify your configuration\nTo verify that the filter was applied after creating your HTTPRoute with URL rewrite or path redirects filters, do the following:\n```\nkubectl get httproute www -o yaml\n```\nThe output is similar to the following:\n```\n apiVersion: gateway.networking.k8s.io/v1beta1\n kind: HTTPRoute\n metadata:\n annotations:\n  kubectl.kubernetes.io/last-applied-configuration: |\n  {\"apiVersion\":\"gateway.networking.k8s.io/v1beta1\",\"kind\":\"HTTPRoute\",\"metadata\":{\"annotations\":{},\"name\":\"www\",\"namespace\":\"default\"},\"spec\":{\"hostnames\":[\"www.example.com\"],\"parentRefs\":[{\"kind\":\"Gateway\",\"name\":\"external-http\"}],\"rules\":[{\"backendRefs\":[{\"name\":\"store-german\",\"port\":8080}],\"filters\":[{\"type\":\"URLRewrite\",\"urlRewrite\":{\"hostname\":\"store.example.com\",\"path\":{\"replacePrefixMatch\":\"/de\",\"type\":\"ReplacePrefixMatch\"}}}],\"matches\":[{\"path\":{\"type\":\"PathPrefix\",\"value\":\"/store\"}}]}]}}\n creationTimestamp: \"2023-06-22T01:00:42Z\"\n generation: 3\n name: www\n namespace: default\n resourceVersion: \"51268631\"\n uid: e516493e-806d-44d6-ae0d-1c9ff25682cf\n spec:\n hostnames:\n - www.example.com\n parentRefs:\n - group: gateway.networking.k8s.io\n  kind: Gateway\n  name: external-http\n rules:\n - backendRefs:\n  - group: \"\"\n  kind: Service\n  name: store-german\n  port: 8080\n  weight: 1\n  filters:\n  - type: URLRewrite\n  urlRewrite:\n   hostname: store.example.com\n   path:\n   replacePrefixMatch: /de\n   type: ReplacePrefixMatch\n  matches:\n  - path:\n   type: PathPrefix\n   value: /store\n status:\n parents:\n - conditions:\n  - lastTransitionTime: \"2023-06-22T01:11:26Z\"\n  message: \"\"\n  observedGeneration: 2\n  reason: Accepted\n  status: \"True\"\n  type: Accepted\n  - lastTransitionTime: \"2023-06-22T01:11:26Z\"\n  message: \"\"\n  observedGeneration: 2\n  reason: ReconciliationSucceeded\n  status: \"True\"\n  type: Reconciled\n  controllerName: networking.gke.io/gateway\n  parentRef:\n  group: gateway.networking.k8s.io\n  kind: Gateway\n  name: external-http\n```\nTo get more details, use the describe command:\n```\nkubectl describe httproute\n```\n## Configure custom request and response headers\nCustom request and response headers let you specify additional headers to HTTP(S) requests and responses. Depending on the information detected by the load balancer, these headers can include the following information:\n- Latency to the client\n- Geographic location of the client's IP address\n- Parameters of the TLS connection\nBy default, there are no custom headers added to the request sent/received to/from your backend services, you need to explicitly configure custom headers using a filter in your HTTPRoute.\nYou can configure custom headers by adding a filter section in your HTTPRoute's rules as follows:\n### Configure custom request headers\nCreate a HTTPRoute manifest with a RequestHeaderModifier filter and save it as `http-route-request.yaml:`\n```\n\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 kind: HTTPRoute\u00a0 metadata:\u00a0 \u00a0 name: store\u00a0 spec:\u00a0 \u00a0 <...>\u00a0 \u00a0 rules:\u00a0 \u00a0 \u00a0 \u00a0 filters:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - type: RequestHeaderModifier\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requestHeaderModifier:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 <...>\n```\nApply the manifest:\n```\n\u00a0 kubectl apply -f http-route-request.yaml\n```\n### Configure custom response headers\nCreate a HTTPRoute manifest with a ResponseHeaderModifier filter and save it as `http-route-response.yaml:`\n```\napiVersion: gateway.networking.k8s.io/v1beta1kind: HTTPRoutemetadata:\u00a0 name: storespec:\u00a0 <...>\u00a0 rules:\u00a0 \u00a0 \u00a0 filters:\u00a0 \u00a0 \u00a0 \u00a0 - type: ResponseHeaderModifier\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 responseHeaderModifier:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 <...>\n```\nApply the manifest:\n```\n\u00a0 kubectl apply -f http-route-response.yaml\n```\n**Note:** GKE Gateway controller implements custom headers in the URL map and not in the backend service.\nYou can add, set, and remove headers as described in the [Gateway API implementation](https://gateway-api.sigs.k8s.io/guides/http-header-modifier/) . You can configure your HTTPRoute with a custom header using [Google Cloud supported variables](/load-balancing/docs/https/custom-headers-global#variables) .\n**Example 1:**\nTo configure an HTTPRoute that adds client location information to the HTTP request before sending it to the backend service, create a HTTPRoute manifest and name it as `external-http-request.yaml` :\n```\n\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 kind: HTTPRoute\u00a0 metadata:\u00a0 \u00a0 name: store\u00a0 spec:\u00a0 \u00a0 parentRefs:\u00a0 \u00a0 \u00a0 - kind: Gateway\u00a0 \u00a0 \u00a0 \u00a0 name: external-http\u00a0 \u00a0 hostnames:\u00a0 \u00a0 - store.example.com\u00a0 \u00a0 rules:\u00a0 \u00a0 \u00a0 - matches:\u00a0 \u00a0 \u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: PathPrefix\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: /fr\u00a0 \u00a0 \u00a0 \u00a0 filters:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - type: RequestHeaderModifier\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requestHeaderModifier:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: X-Client-Geo-Location\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: \"{client_region},{client_city}\"\u00a0 \u00a0 \u00a0 \u00a0 backendRefs:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: store-french\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port: 8080\n```\nFor example, for clients located in Strasbourg, France, the Gateway adds a header as `X-Client-Geo-Location:FR,Strasbourg` .\n**Example 2:**\nTo configure an HTTPRoute that adds a custom response header to support HTTP Strict Transport Security, create a HTTPRoute manifest and name it as `external-http-response.yaml` :\n```\n\u00a0 apiVersion: gateway.networking.k8s.io/v1beta1\u00a0 kind: HTTPRoute\u00a0 metadata:\u00a0 \u00a0 name: store\u00a0 spec:\u00a0 \u00a0 parentRefs:\u00a0 \u00a0 \u00a0 - kind: Gateway\u00a0 \u00a0 \u00a0 \u00a0 name: external-http\u00a0 \u00a0 hostnames:\u00a0 \u00a0 - store.example.com\u00a0 \u00a0 rules:\u00a0 \u00a0 \u00a0 - matches:\u00a0 \u00a0 \u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: PathPrefix\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: /de\u00a0 \u00a0 \u00a0 \u00a0 filters:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - type: ResponseHeaderModifier\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 responseHeaderModifier:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 add:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: Strict-Transport-Security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: max-age=63072000\u00a0 \u00a0 \u00a0 \u00a0 backendRefs:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: store-german\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port: 8080\n```\n### Verify your configuration\n- To verify your configuration after configuring custom request and response headers, do the following:```\n\u00a0 kubectl get httproute\n```The output is similar to the following:```\n NAME HOSTNAMES    AGE\n store [\"store.example.com\"] 4d23h\n```\n- To get more details, use the describe command:```\n\u00a0 kubectl describe httproute\n```The output is similar to the following:```\n Name:   store\n Namespace: default\n Labels:  <none>\n Annotations: <none>\n API Version: gateway.networking.k8s.io/v1beta1\n Kind:   HTTPRoute\n Metadata:\n Creation Timestamp: 2023-05-27T00:51:01Z\n Generation:   5\n Resource Version: 25418887\n UID:     2e07a1b8-420b-41b4-acd1-cecbfcd39f42\n Spec:\n Hostnames:\n  store.example.com\n Parent Refs:\n  Group: gateway.networking.k8s.io\n  Kind: Gateway\n  Name: external-http\n Rules:\n  Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-v1\n  Port: 8080\n  Weight: 1\n  Matches:\n  Path:\n   Type: PathPrefix\n   Value: /\n  Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-v2\n  Port: 8080\n  Weight: 1\n  Matches:\n  Headers:\n   Name: env\n   Type: Exact\n   Value: canary\n  Path:\n   Type: PathPrefix\n   Value: /\n  Backend Refs:\n  Group:\n  Kind: Service\n  Name: store-german\n  Port: 8080\n  Weight: 1\n  Filters:\n  Request Header Modifier:\n   Add:\n   Name: X-Client-Geo-Location\n   Value: {client_region},{client_city}\n  Type:  RequestHeaderModifier\n  Matches:\n  Path:\n   Type: PathPrefix\n   Value: /de\n Status:\n <...>\n```## Route status\nHTTPRoute resources emit conditions and events to help users understand if a HTTPRoute has successfully bound with one or more Gateways or if it was rejected.\n### HTTPRoute conditions\nHTTPRoute conditions indicate the status of the Route and the Gateways it is bound to. Because a Route can be bound to multiple Gateways, this is a list of Gateways and the individual conditions between the Route and each Gateway.\n- `Accepted=True`indicates that the HTTPRoute is successfully bound to a Gateway.\n- `Accepted=False`indicates that the HTTPRoute has been rejected from binding with this Gateway.\nIf there are no Gateways listed under the `Gateway bindings` heading, then your HTTPRoute labels and Gateway label selectors might not match. This can occur if your Route is not being selected by any Gateways.\n### HTTPRoute events\nHTTPRoute events provide details about the status of the HTTPRoute. Events are grouped by the following reasons:\n- `ADD`events are triggered by a resource being added.\n- `UPDATE`events are triggered by a resource being updated.\n- `SYNC`events are triggered by periodic reconciliation.## Route merging, precedence, and validation\n### Route precedence\nThe Gateway API defines strict [precedence rules](https://gateway-api.sigs.k8s.io/references/spec/#gateway.networking.k8s.io/v1beta1.HTTPRoute) for how traffic is matched by Routes that have overlapping routing rules. The precedence between two overlapping HTTPRoutes is as follows:\n- **Hostname merge** : The longest/most specific hostname match.\n- **Path merge** : The longest/most specific path match.\n- **Header merge** : The largest number of HTTP headers that match.\n- **Conflict** : If the previous three rules don't establish precedence, then precedence goes to the HTTPRoute resource with the oldest timestamp.\n### Route merging\nFor `gke-l7` GatewayClasses, all HTTPRoutes for a given Gateway are merged into the same [URL map resource](/load-balancing/docs/url-map) . How the HTTPRoutes are merged together depends on the type of overlap between HTTPRoutes. The HTTPRoute from [the earlier example](#store-route) can be split into three separate HTTPRoutes to illustrate route merging and precedence:\n- Route merge: All three HTTPRoutes attach with the same`internal-http`Gateway, so they are merged together.\n- Hostname merge: All three Routes match for`store.example.com`, so their hostname rules are merged.\n- Path merge: store-german-route has a more specific path`/de`, so this is not merged further. store-v1-route and store-v2-route both match on the same`/*`path as well, so they are merged on the path.\n- Header merge: store-v2-route has a more specific set of HTTP header matches than store-v1-route, so they are not merged further.\n- Conflict: Because the Routes are able to be merged on hostname, path, and headers, there are no conflicts, and all of the routing rules are applied to traffic.\nThe single HTTPRoute used in [the earlier example](#store-route) are equivalent to these three separate routes:\n```\nkind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-v1-routespec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: internal-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - backendRefs:\u00a0 \u00a0 - kind: Service\u00a0 \u00a0 \u00a0 name: store-v1\u00a0 \u00a0 \u00a0 port: 8080---kind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-v2-routespec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: internal-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - matches:\u00a0 \u00a0 - headers:\u00a0 \u00a0 \u00a0 - type: Exact\u00a0 \u00a0 \u00a0 \u00a0 name: env\u00a0 \u00a0 \u00a0 \u00a0 value: canary\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - kind: Service\u00a0 \u00a0 \u00a0 name: store-v2\u00a0 \u00a0 \u00a0 port: 8080---kind: HTTPRouteapiVersion: gateway.networking.k8s.io/v1beta1metadata:\u00a0 name: store-german-routespec:\u00a0 parentRefs:\u00a0 - kind: Gateway\u00a0 \u00a0 name: internal-http\u00a0 hostnames:\u00a0 - \"store.example.com\"\u00a0 rules:\u00a0 - matches:\u00a0 \u00a0 - path:\u00a0 \u00a0 \u00a0 \u00a0 type: PathPrefix\u00a0 \u00a0 \u00a0 \u00a0 value: /de\u00a0 \u00a0 backendRefs:\u00a0 \u00a0 - kind: Service\u00a0 \u00a0 \u00a0 name: store-german\u00a0 \u00a0 \u00a0 port: 8080\n```\n## Kubernetes Gateways and Istio Gateways\nNote that the Kubernetes Gateway API and the Istio API both have a resource named `Gateway` . While they perform similar functions, they are not the same resource. If you are using Istio and the Gateway API in the same Kubernetes cluster, these names overlap when using kubectl on the command line. `kubectl get gateway` might return the Kubernetes Gateway resources and not the Istio Gateway resources or vice versa.\n```\n$ kubectl api-resourcesNAME \u00a0 \u00a0 \u00a0 SHORTNAMES \u00a0 APIGROUP \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 NAMESPACED \u00a0 KINDgateways \u00a0 gw \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 networking.istio.io/v1beta1 \u00a0 \u00a0true \u00a0 \u00a0 \u00a0 \u00a0 Gatewaygateways \u00a0 gtw \u00a0 \u00a0 \u00a0 \u00a0 \u00a0networking.k8s.io/v1beta1 \u00a0 \u00a0 \u00a0true \u00a0 \u00a0 \u00a0 \u00a0 Gateway\n```\nIf you are using Istio and upgrade to GKE 1.20 and later it is recommended to start using the Gateway resource shortname or specify the API group. The shortname for a Kubernetes Gateway is `gtw` and the shortname for an Istio Gateway is `gw` . The following commands return the Kubernetes Gateway and Istio Gateway resources respectively.\n```\n# Kubernetes Gateway$ kubectl get gtwNAME \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0CLASSmulti-cluster-gateway \u00a0 \u00a0 \u00a0 gke-l7-global-external-managed-mc$ kubectl get gateway.networking.x-k8s.ioNAME \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0CLASSmulti-cluster-gateway \u00a0 \u00a0 \u00a0 gke-l7-global-external-managed-mc# Istio Gateway$ kubectl get gwNAME \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AGEbookinfo-gateway \u00a0 64m$ kubectl get gateway.networking.istio.ioNAME \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AGEbookinfo-gateway \u00a0 64m\n```\n## Troubleshooting\n### Proxy-only subnet missing in the region\n**Symptom:**\nThe following issue might occur when you create a regional Gateway (internal or external):\n```\ngeneric::invalid_argument: error ensuring load balancer: Insert: Invalid value for field 'resource.target': 'regions/[REGION_NAME]/targetHttpProxies/gkegw-x5vt-default-internal-http-[ID]'. A reserved managed proxy subnetwork with purpose REGIONAL_MANAGED_PROXY is required.\n```\n**Reason:**\nThis error message indicates that no proxy-only subnet exists in the region for your Gateway.\n**Workaround:**\nTo resolve this issue, configure a [proxy-only subnet](#configure_a_proxy-only_subnet) .\n### Proxy-only subnet already exists in the region with the wrong purpose\n**Symptom:**\nThe following issue might occur when you create a proxy-only subnet for your regional Gateway (internal or external):\n```\nERROR: (gcloud.compute.networks.subnets.create) Could not fetch resource:\n - The resource 'projects/[PROJECT_NAME]/regions/[REGION_NAME]/subnetworks/[PROXY_ONLY_SUBNET_NAME]' already exists\n```\n**Reason:**\nThis error message indicates that you attempted to create a regional proxy-only subnet in a region that already has a proxy-only subnet.\n**Workaround:**\nTo resolve this issue, use the following steps:\n- Check that a proxy-only subnet already exists in the region and verify that it has the correct purpose:- List your subnets to find which one is the proxy-only subnet in the region:```\ngcloud compute networks subnets list --regions=COMPUTE_REGION\n```Replace `` with the Compute Engine region where you want to create your regional Gateway.\n- Describe your proxy-only subnet in the region to find its purpose:```\ngcloud compute networks subnets describe PROXY_ONLY_SUBNET \\\u00a0 \u00a0 --region COMPUTE_REGION | grep -E 'name|purpose'\n```Replace `` with the proxy-only subnet.\nGKE Gateway only supports `REGIONAL_MANAGED_PROXY` proxy-only subnets for regional Gateways (internal or regional).\n- If the existing proxy-only subnet in the region was created with an `INTERNAL_HTTPS_LOAD_BALANCER` purpose, [migrate its purpose toREGIONAL_MANAGED_PROXY](/load-balancing/docs/proxy-only-subnets#migrate-purpose) .## What's next\n- Learn more about the [Gateway controller](/kubernetes-engine/docs/concepts/gateway-api) .\n- Learn how to [Configure Gateway resources using Policies](/kubernetes-engine/docs/how-to/configure-gateway-resources) .", "guide": "Google Kubernetes Engine (GKE)"}