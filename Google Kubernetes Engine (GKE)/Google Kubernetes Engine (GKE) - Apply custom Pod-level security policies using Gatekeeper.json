{"title": "Google Kubernetes Engine (GKE) - Apply custom Pod-level security policies using Gatekeeper", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies-with-gatekeeper", "abstract": "# Google Kubernetes Engine (GKE) - Apply custom Pod-level security policies using Gatekeeper\nThis page shows you how to use the Gatekeeper admission controller to apply Pod-level security controls to your Google Kubernetes Engine (GKE) clusters.\n", "content": "## Overview\n[Gatekeeper](https://github.com/open-policy-agent/gatekeeper) is an admission controller that validates requests to create and update Pods on Kubernetes clusters, using the [Open Policy Agent (OPA)](https://www.openpolicyagent.org/) .\nUsing Gatekeeper allows administrators to define policies with a , which is a set of conditions that permit or deny deployment behaviors in Kubernetes. You can then enforce these policies on a cluster using a `ConstraintTemplate` . This document provides examples for restricting the security capabilities of workloads to ensure enforce, test, and audit security policies using Gatekeeper.\nGatekeeper can also:\n- **Roll out policies:** Enforce policy in a gradual, scoped manner to limit the risk of disrupting workloads.\n- **Dry-run policy changes:** Provide mechanisms for testing policy impact and range prior to enforcement.\n- **Audit existing policies:** Ensure the application of security controls to new and existing workloads (audit controls).## Concepts\nGatekeeper introduces two concepts in order to provide administrators with a powerful and flexible means of controlling their cluster: **constraints** , and **constraint templates** , both of which are concepts inherited from the Open Policy Agent [Constraint Framework](https://github.com/open-policy-agent/frameworks/tree/master/constraint) .\n**Constraints** are the representation of your security policy\u2014they define the requirements and range of enforcement. **Constraint templates** are reusable statements (written in [Rego](https://www.openpolicyagent.org/docs/latest/#rego) ) that apply logic to evaluate specific fields in Kubernetes objects, based on requirements defined in constraints.\nFor example, you might have a constraint that declares allowable seccomp profiles that can be applied to Pods in a specific namespace, and a comparable constraint template that provides the logic for extracting these values and handling enforcement.\nThe following constraint template, from the [Gatekeeper repository](https://github.com/open-policy-agent/gatekeeper-library/tree/master/library/pod-security-policy) , checks for the existence of `securityContext.privileged` in a Pod specification:\n```\napiVersion: templates.gatekeeper.sh/v1beta1kind: ConstraintTemplatemetadata:\u00a0 name: k8spspprivilegedcontainerspec:\u00a0 crd:\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 names:\u00a0 \u00a0 \u00a0 \u00a0 kind: K8sPSPPrivilegedContainer\u00a0 targets:\u00a0 \u00a0 - target: admission.k8s.gatekeeper.sh\u00a0 \u00a0 \u00a0 rego: |\u00a0 \u00a0 \u00a0 \u00a0 package k8spspprivileged\u00a0 \u00a0 \u00a0 \u00a0 violation[{\"msg\": msg, \"details\": {}}] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input_containers[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c.securityContext.privileged\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 msg := sprintf(\"Privileged container is not allowed: %v, securityContext: %v\", [c.name, c.securityContext])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 input_containers[c] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input.review.object.spec.containers[_]\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 input_containers[c] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input.review.object.spec.initContainers[_]\u00a0 \u00a0 \u00a0 \u00a0 }\n```\nTo extend the above constraint template, the following constraint defines the scope ( `kinds` ) for the specific enforcement of this constraint template in a `dryrun` mode:\n```\napiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPPrivilegedContainermetadata:\u00a0 name: psp-privileged-containerspec:\u00a0 enforcementAction: dryrun\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\n```\nWith Gatekeeper, you can create your own constraints and constraint templates to meet your specific needs. You can also use a [standard set of constraints and constraint templates](https://github.com/open-policy-agent/gatekeeper-library/tree/master/library/pod-security-policy) in the [Gatekeeper repository](https://github.com/open-policy-agent/gatekeeper/tree/master/library) that have been defined to enable quick adoption and security enforcement. Each constraint is also accompanied with example Pod configurations.\nGoogle Cloud provides a managed, officially supported version of open source Gatekeeper named [Policy Controller](/anthos-config-management/docs/concepts/policy-controller) . Google doesn't officially support the open source Gatekeeper project.\n## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.## Enable Gatekeeper on a cluster with Policy Controller\n[Policy Controller](/anthos-config-management/docs/concepts/policy-controller) is a policy engine built on the [Gatekeeper](https://github.com/open-policy-agent/gatekeeper) open source project. Google recommends the use of Policy Controller because it includes additional features to help enforce policy at scale, including policy-as-code, multi-cluster support, integration with Cloud Logging, and ability to view policy status in the Google Cloud console. Policy Controller is available with a Google Kubernetes Engine (GKE) Enterprise edition license but you can [install Gatekeeper](https://open-policy-agent.github.io/gatekeeper/website/docs/install/) on your cluster instead.\nTo enable Policy Controller on a cluster, follow the [Policy Controller installation guide](/anthos-config-management/docs/how-to/installing-policy-controller) .\n## Enable constraints and constraint templates\nGatekeeper and its constraint templates can be installed and enabled without adversely impacting existing or new workloads. For this reason, it's recommended that all applicable Pod security constraint templates be applied to the cluster.\nAdditionally, Gatekeeper constraints can be implemented to enforce controls for specific objects, such as namespaces and Pods.\nObserve the example below that limits the scope to **Pods** located in the **production** namespace by defining them in the constraint match statement:\n```\n...\nspec:\n match:\n kinds:\n  - apiGroups: [\"\"]\n  kinds: [\"Pod\"]\n namespaces:\n  - \"production\"\n```\nFor more information about the available options for `Constraint` and `ConstraintTemplate` objects, see [How to use Gatekeeper](https://open-policy-agent.github.io/gatekeeper/website/docs/howto) .\n### Testing policies\nIntroducing new policies to existing clusters can have adverse behavior, for example by restricting existing workloads. One of the benefits of using Gatekeeper for Pod security is the ability to test the effectiveness and impact a policy will have without making actual changes, using a dry-run mode. This allows for policy configuration to be tested against running clusters without enforcement. Policy violations are logged and identified without interference.\nThe following steps demonstrate how a developer, operator, or administrator can apply constraint templates and constraints to determine their effectiveness or potential impact:\n- Apply the Gatekeeper config for replicating data for audit and dry-run functionality:```\nkubectl create -f- <<EOFapiVersion: config.gatekeeper.sh/v1alpha1kind: Configmetadata:\u00a0 name: config\u00a0 namespace: \"gatekeeper-system\"spec:\u00a0 sync:\u00a0 \u00a0 syncOnly:\u00a0 \u00a0 \u00a0 - group: \"\"\u00a0 \u00a0 \u00a0 \u00a0 version: \"v1\"\u00a0 \u00a0 \u00a0 \u00a0 kind: \"Namespace\"\u00a0 \u00a0 \u00a0 - group: \"\"\u00a0 \u00a0 \u00a0 \u00a0 version: \"v1\"\u00a0 \u00a0 \u00a0 \u00a0 kind: \"Pod\"EOF\n```\n- With no constraints applied, let's run a workload with elevated privileges:```\nkubectl create -f- <<EOFapiVersion: v1kind: Podmetadata:\u00a0 name: nginx\u00a0 labels:\u00a0 \u00a0 app: nginxspec:\u00a0 containers:\u00a0 - name: nginx\u00a0 \u00a0 image: nginx\u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 privileged: trueEOF\n```\n- Load the `k8spspprivilegedcontainer` constraint template mentioned above:```\nkubectl create -f- <<EOFapiVersion: templates.gatekeeper.sh/v1beta1kind: ConstraintTemplatemetadata:\u00a0 name: k8spspprivilegedcontainerspec:\u00a0 crd:\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 names:\u00a0 \u00a0 \u00a0 \u00a0 kind: K8sPSPPrivilegedContainer\u00a0 targets:\u00a0 \u00a0 - target: admission.k8s.gatekeeper.sh\u00a0 \u00a0 \u00a0 rego: |\u00a0 \u00a0 \u00a0 \u00a0 package k8spspprivileged\u00a0 \u00a0 \u00a0 \u00a0 violation[{\"msg\": msg, \"details\": {}}] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input_containers[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c.securityContext.privileged\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 msg := sprintf(\"Privileged container is not allowed: %v, securityContext: %v\", [c.name, c.securityContext])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 input_containers[c] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input.review.object.spec.containers[_]\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 input_containers[c] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input.review.object.spec.initContainers[_]\u00a0 \u00a0 \u00a0 \u00a0 }EOF\n```\n- Now let's create a new constraint to extend this constraint template. This time, we will set the `enforcementAction` to `dryrun` :```\nkubectl create -f- <<EOFapiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPPrivilegedContainermetadata:\u00a0 name: psp-privileged-containerspec:\u00a0 enforcementAction: dryrun\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]EOF\n```\n- With Gatekeeper synchronizing running object data, and passively checking for violations, we can confirm if any violations were found by checking the `status` of the constraint:```\nkubectl get k8spspprivilegedcontainer.constraints.gatekeeper.sh/psp-privileged-container -o yaml\n``````\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sPSPPrivilegedContainer\nmetadata:\n...\n name: psp-privileged-container\n...\nspec:\n enforcementAction: dryrun\n match:\n kinds:\n - apiGroups:\n  - \"\"\n  kinds:\n  - Pod\nstatus:\n auditTimestamp: \"2019-12-15T22:19:54Z\"\n byPod:\n - enforced: true\n id: gatekeeper-controller-manager-0\n violations:\n - enforcementAction: dryrun\n kind: Pod\n message: 'Privileged container is not allowed: nginx, securityContext: {\"privileged\":\n  true}'\n name: nginx\n namespace: default\n```\n- Let's run another privileged Pod, to confirm that the policy does not interfere with deployments:```\nkubectl create -f- <<EOFapiVersion: v1kind: Podmetadata:\u00a0 name: privpod\u00a0 labels:\u00a0 \u00a0 app: privpodspec:\u00a0 containers:\u00a0 - name: nginx\u00a0 \u00a0 image: nginx\u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 privileged: trueEOF\n```This new Pod will be successfully deployed.\n- To clean up the resources created in this section, run the following commands:```\nkubectl delete k8spspprivilegedcontainer.constraints.gatekeeper.sh/psp-privileged-containerkubectl delete constrainttemplate k8spspprivilegedcontainerkubectl delete pod/nginxkubectl delete pod/privpod\n```\n### Enforcing policies\nNow that we can confirm the validity and impact of a policy without impacting existing or new workloads, let's implement a policy with full enforcement.\nBuilding on the examples used to validate the policy above, the following steps demonstrate how a developer, operator, or administrator can apply constraint templates and constraints to enforce a policy:\n- Load the `k8spspprivilegedcontainer` constraint template mentioned earlier:```\nkubectl create -f- <<EOFapiVersion: templates.gatekeeper.sh/v1beta1kind: ConstraintTemplatemetadata:\u00a0 name: k8spspprivilegedcontainerspec:\u00a0 crd:\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 names:\u00a0 \u00a0 \u00a0 \u00a0 kind: K8sPSPPrivilegedContainer\u00a0 targets:\u00a0 \u00a0 - target: admission.k8s.gatekeeper.sh\u00a0 \u00a0 \u00a0 rego: |\u00a0 \u00a0 \u00a0 \u00a0 package k8spspprivileged\u00a0 \u00a0 \u00a0 \u00a0 violation[{\"msg\": msg, \"details\": {}}] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input_containers[_]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c.securityContext.privileged\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 msg := sprintf(\"Privileged container is not allowed: %v, securityContext: %v\", [c.name, c.securityContext])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 input_containers[c] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input.review.object.spec.containers[_]\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 input_containers[c] {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 c := input.review.object.spec.initContainers[_]\u00a0 \u00a0 \u00a0 \u00a0 }EOF\n```\n- Now let's create a new constraint to extend this constraint template. This time, we won't set the `enforcementAction` key. By default, the `enforcementAction` key is set to `deny` :```\nkubectl create -f- <<EOFapiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPPrivilegedContainermetadata:\u00a0 name: psp-privileged-containerspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]EOF\n```\n- Attempt to deploy a container that declares privileged permissions:```\nkubectl create -f- <<EOFapiVersion: v1kind: Podmetadata:\u00a0 name: nginx\u00a0 labels:\u00a0 \u00a0 app: nginxspec:\u00a0 containers:\u00a0 - name: nginx\u00a0 \u00a0 image: nginx\u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 privileged: trueEOF\n```The following error message should be received:```\nError from server ([denied by psp-privileged-container] Privileged container is not allowed:\nnginx, securityContext: {\"privileged\": true}): error when creating \"STDIN\": admission webhook \"validation.gatekeeper.sh\" denied the request: [denied by psp-privileged-container]\nPrivileged container is not allowed: nginx, securityContext: {\"privileged\": true}\n```\n- To clean up, run the following commands:```\nkubectl delete k8spspprivilegedcontainer.constraints.gatekeeper.sh/psp-privileged-containerkubectl delete constrainttemplate k8spspprivilegedcontainer\n```## Alternatives to Gatekeeper\nGatekeeper lets you declare and apply custom Pod-level security policies. You can also use Kubernetes' built-in [PodSecurity admission controller](/kubernetes-engine/docs/how-to/podsecurityadmission) to apply predefined Pod-level security policies. These predefined policies are aligned with the levels defined by the [Pod Security Standards](https://kubernetes.io/docs/concepts/security/pod-security-standards/) .\n## What's next\nGatekeeper provides an incredibly powerful means to enforce and validate security on GKE clusters using declarative policies. Gatekeeper's use extends beyond security however, and can be used in other aspects of administration and operations.\n- [How to use Gatekeeper](https://github.com/open-policy-agent/gatekeeper#how-to-use-gatekeeper) \n- [Gatekeeper demonstrations](https://github.com/open-policy-agent/gatekeeper/tree/master/demo) \n- [Gatekeeper examples](https://github.com/open-policy-agent/gatekeeper-library)", "guide": "Google Kubernetes Engine (GKE)"}