{"title": "Google Kubernetes Engine (GKE) - Deploying a stateful application", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/stateful-apps", "abstract": "# Google Kubernetes Engine (GKE) - Deploying a stateful application\nThis page explains how to deploy a stateful application using Google Kubernetes Engine (GKE).\n", "content": "## Overview\nStateful applications save data to [persistent disk storage](/kubernetes-engine/docs/concepts/persistent-volumes) for use by the server, by clients, and by other applications. An example of a stateful application is a database or key-value store to which data is saved and retrieved by other applications.\nPersistent storage can be [dynamically provisioned](https://kubernetes.io/docs/tutorials/object-management-kubectl/imperative-object-management-configuration/) , so that the underlying volumes are created on demand. In Kubernetes, you configure dynamic provisioning by creating a [StorageClass](https://kubernetes.io/docs/tutorials/object-management-kubectl/imperative-object-management-configuration/) . In GKE, a default StorageClass allows you to dynamically provision [Compute Engine](/compute) persistent disks.\nKubernetes uses the [StatefulSet](/kubernetes-engine/docs/concepts/statefulset) controller to deploy stateful applications as StatefulSet objects. Pods in StatefulSets are not interchangeable: each Pod has a unique identifier that is maintained no matter where it is scheduled.\nStateful applications are different from [stateless applications](/kubernetes-engine/docs/how-to/stateless-apps) , in which client data is not saved to the server between sessions.\nYou can learn more about [persistent storage in multi-zonal and regional clusters](/kubernetes-engine/docs/concepts/regional-clusters#pd) .\n## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.\n- Ensure your containerized application is stored in an image registry, such as [Artifact Registry](/artifact-registry/docs/overview) .\nYou can follow the [quickstart](/kubernetes-engine/docs/deploy-app-cluster) , to enable the GKE API, create a cluster, and learn more about GKE.\n## Requesting persistent storage in a StatefulSet\nApplications can request persistent storage with a [PersistentVolumeClaim](/kubernetes-engine/docs/concepts/persistent-volumes) .\nTypically, you must create PersistentVolumeClaim objects in addition to creating the Pod. However, StatefulSet objects include a `volumeClaimTemplates` array, which automatically generates the PersistentVolumeClaim objects. Each StatefulSet replica gets its own PersistentVolumeClaim object.\nYou can also [use a preexisting disk in a StatefulSet](/kubernetes-engine/docs/how-to/persistent-volumes/preexisting-pd#using_a_preexisting_disk_in_a_statefulset) .\n## Creating a StatefulSet\nTo create a StatefulSet resource, use the [kubectl apply](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply) command.\nThe `kubectl apply` command uses manifest files to create, update, and delete resources in your cluster. This is a [declarativemethod](https://kubernetes.io/docs/tutorials/object-management-kubectl/imperative-object-management-configuration/) of object configuration. This method retains writes made to live objects without merging the changes back into the object configuration files.\nThe following manifest file is a simple example of a StatefulSet governed by a Service that has been created separately:\n```\napiVersion: apps/v1kind: StatefulSetmetadata:\u00a0 name: STATEFULSET_NAMEspec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: APP_NAME\u00a0 serviceName: \"SERVICE_NAME\"\u00a0 replicas: 3\u00a0 updateStrategy:\u00a0 \u00a0 type: RollingUpdate\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: APP_NAME\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: CONTAINER_NAME\u00a0 \u00a0 \u00a0 \u00a0 image: ...\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 80\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: PORT_NAME\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - name: PVC_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: ...\u00a0 volumeClaimTemplates:\u00a0 - metadata:\u00a0 \u00a0 \u00a0 name: PVC_NAME\u00a0 \u00a0 \u00a0 annotations:\u00a0 \u00a0 \u00a0 \u00a0 ...\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 accessModes: [ \"ReadWriteOnce\" ]\u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 storage: 1Gi\n```\nReplace the following:- ``: the name of the StatefulSet.\n- ``: the name of the Service.\n- ``: the name of the application run in the Pods.\n- ``: the name of the containers in the Pods.\n- ``: the name of the port opened by the StatefulSet.\n- ``: the name of the PersistentVolumeClaim.\nIn this file, the `kind` field specifies that a StatefulSet object should be created with the specifications defined in the file. This example StatefulSet produces three replicated Pods, and opens port 80 for exposing the StatefulSet to the internet.\nWhen using [clusters with Windows Server node pools](/kubernetes-engine/docs/how-to/creating-a-cluster-windows) , you must create a StorageClass because the default StorageClass uses `ext4` as the file system type, which only works for Linux containers. If you are using a Compute Engine persistent disk, you must use `NTFS` as the file storage type as shown in the following example:\n```\napiVersion: storage.k8s.io/v1kind: StorageClassmetadata:\u00a0 name: STORAGECLASS_NAMEparameters:\u00a0 type: pd-standard\u00a0 fstype: NTFSprovisioner: kubernetes.io/gce-pdreclaimPolicy: DeletevolumeBindingMode: WaitForFirstConsumer\n```\nThe following StatefulSet manifest uses the StorageClass defined above. It creates four PersistentVolume and PersistentVolumeClaim pairs to represent four Compute Engine persistent disks. Each Pod in the StatefulSet consumes one persistent disk.\nTo ensure your Pods are correctly scheduled onto Windows Server nodes, you must add a node selector to your Pod specification.\n```\napiVersion: apps/v1kind: StatefulSetmetadata:\u00a0 name: STATEFULSET_NAMEspec:\u00a0 replicas: 4\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: APP_NAME\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: APP_NAME\u00a0 \u00a0 \u00a0 name: CONTAINER_NAME\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 nodeSelector:\u00a0 \u00a0 \u00a0 \u00a0 kubernetes.io/os: windows\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: CONTAINER_NAME\u00a0 \u00a0 \u00a0 \u00a0 image: ...\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 80\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: PORT_NAME\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - name: PVC_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: C:\\mnt\\state\u00a0 volumeClaimTemplates:\u00a0 - metadata:\u00a0 \u00a0 \u00a0 name: PVC_NAME\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 storageClassName: STORAGECLASS_NAME\u00a0 \u00a0 \u00a0 accessModes: [ \"ReadWriteOnce\" ]\u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 storage: 1Gi\n```\nReplace the following:- ``: the name of the application run in the Pods.\n- ``: the name of the StatefulSet.\n- ``: the name of the containers in the Pods.\n- ``: the name of the port opened by the StatefulSet.\n- ``: the name of the PersistentVolumeClaim.\n- ``: the name of the StorageClass.\nTo create a StatefulSet resource, run the following command replacing `` with the manifest file name:\n```\nkubectl apply -f STATEFULSET_FILE\n```\nYou can also use `kubectl apply -f` `` `/` to create all objects (except existing ones) defined in configuration files stored in a directory.\n**Note:** `kubectl apply` fails if you do not have an active cluster.\n## Inspecting a StatefulSet\nTo inspect the StatefulSet, run the following command:\n```\nkubectl get statefulset STATEFULSET_NAME -o yaml\n```\nThis command displays the live configuration of the StatefulSet resource in YAML format.\nTo list the Pods created by the StatefulSet, run the following command:\n```\nkubectl get pods -l app=APP_NAME\n```\nIn this command, the `-l` flag instructs `kubectl` to get all Pods for the `` .\nThe output is similar to the following:\n```\nNAME        READY  STATUS RESTARTS AGE\npod-name       1/1  Running 0   1m\npod-name       1/1  Running 0   1m\n```\nTo get detailed information about the StatefulSet, run the following command:\n```\nkubectl describe statefulset STATEFULSET_NAME\n```\nTo get information about a specific Pod, run the following command:\n```\nkubectl describe pod POD_NAME\n```\nTo list the PersistentVolumeClaim objects that were created, run the following command:\n```\nkubectl get pvc\n```\nThe output is similar to the following:\n```\nNAME       STATUS VOLUME          CAPACITY ACCESS MODES STORAGECLASS AGE\nSTATEFULSET_NAME-PVC_NAME-0  Bound  pvc-bdff4e1e-183e-11e8-bf6d-42010a800002 1G   RWO   standard  9s\nSTATEFULSET_NAME-PVC_NAME-1  Bound  pvc-bdff4e1e-183e-11e8-bf6d-42010a800003 1G   RWO   standard  9s\nSTATEFULSET_NAME-PVC_NAME-2  Bound  pvc-bdff4e1e-183e-11e8-bf6d-42010a800004 1G   RWO   standard  9s\n```\nTo get information about a specific PersistentVolumeClaim, run the following command:\n```\nkubectl describe pvc STATEFULSET_NAME-PVC_NAME-0\n```\nTo get information about a specific PersistentVolume, run the following command:\n```\nkubectl describe pv PV_NAME\n```\nTo inspect a StatefulSet, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the StatefulSet you want to inspect.\n- On the **Stateful Set details** page, do any of the following:- Click the **Revision History** tab to see the StatefulSet's revision history.\n- Click the **Events** tab to see all events related to the StatefulSet.\n- Click the **Logs** tab to see container logs for the StatefulSet.\n- Click the **YAML** tab to see, copy, or download the configuration YAML for the StatefulSet.\n## Updating a StatefulSet\nThere are multiple ways of updating StatefulSets. The common, declarative method is `kubectl apply` . To update the StatefulSet directly from your shell or in a preferred editor, you can use `kubectl edit` . You can also use the YAML editor from the GKE Workloads menu in the Google Cloud console.\nYou can roll out updates to the [Pods specification](https://kubernetes.io/docs/tutorials/object-management-kubectl/imperative-object-management-configuration/) for a StatefulSet resource, such as its image, resource usage/requests, or configuration.\nYou can update the StatefulSet by a new or updated manifest file. This is useful for making various changes to your StatefulSet, such as when scaling or for specifying a new version of your application.\n **Note:** To update a resource with `kubectl apply` , the resource would need to have been created using either `kubectl apply` or `kubectl create --save-config` .\nTo update a StatefulSet, run the following command:\n```\nkubectl apply -f STATEFULSET_FILE\n```\nReplace `` with the updated manifest file.\nThe `kubectl apply` command applies a manifest file to a resource. If the specified resource does not exist, it is created by the command.\nFor more information about `kubectl apply` , see the [kubectl reference documentation](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply) .\nTo edit the live configuration of a StatefulSet, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the StatefulSet you want to modify.\n- Click **Edit** .\n- Change the configuration YAML as desired.\n- Click **Save** .\n**Note:** While it is possible to specify a different PersistentVolume, it is not possible to update existing PersistentVolume resources.\n### Inspecting update rollout\nTo inspect the rollout of the StatefulSet, run the following command:\n```\nkubectl rollout status statefulset STATEFULSET_NAME\n```\nTo see the StatefulSet's rollout history, run the following command:\n```\nkubectl rollout history statefulset STATEFULSET_NAME\n```\nTo undo a rollout, run the following command:\n```\nkubectl rollout undo statefulset STATEFULSET_NAME\n```\nTo see the revision history of a StatefulSet, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the StatefulSet you want to inspect.\n- Click the **Revision History** tab.\n- Select the desired revision.\n### Update strategies\nStatefulSet\u2019s `updateStrategy` field allows you to configure and disable automated rolling updates for containers, labels, resource requests, limits, and annotations for the Pods in a StatefulSet.\nYou can learn more about [Update Strategies](https://kubernetes.io/docs/tutorials/object-management-kubectl/imperative-object-management-configuration/) for StatefulSets in the Kubernetes documentation.\n## Scaling a StatefulSet\nThe `kubectl scale` command can be used at any time to scale your StatefulSet.\nTo manually scale a StatefulSet, run the following command:\n```\nkubectl scale statefulset STATEFULSET_NAME --replicas NUMBER_OF_REPLICAS\n```\nReplace `` with the desired number of replicated Pods.\nTo scale a StatefulSet, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the StatefulSet you want to modify.\n- Click **Actions > Scale > Edit replicas** .\n- Enter the new number of **Replicas** for the StatefulSet.\n- Click **Scale** .## Deleting a StatefulSet\nTo delete a StatefulSet, run the following command:\n```\nkubectl delete statefulset STATEFULSET_NAME\n```\nTo delete a StatefulSet, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, select one or more StatefulSets you want to delete.\n- Click **Delete** .\n- When prompted to confirm, click **Delete** .## What's next\n- [Learn how to deploy a MySQL cluster on GKE for high availability](/kubernetes-engine/docs/tutorials/stateful-workloads/mysql) \n- [Learn about deploying stateless applications](/kubernetes-engine/docs/how-to/stateless-apps) .\n- [Take a tutorial about upgrading a cluster running a stateful workload](/kubernetes-engine/docs/tutorials/upgrading-stateful-workload) .", "guide": "Google Kubernetes Engine (GKE)"}