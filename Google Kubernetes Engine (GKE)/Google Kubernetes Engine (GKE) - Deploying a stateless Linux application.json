{"title": "Google Kubernetes Engine (GKE) - Deploying a stateless Linux application", "url": "https://cloud.google.com/kubernetes-engine/docs/how-to/stateless-apps", "abstract": "# Google Kubernetes Engine (GKE) - Deploying a stateless Linux application\nThis page explains how to deploy a stateless Linux application using Google Kubernetes Engine (GKE). You can also learn how to [deploy a stateless Windows application](/kubernetes-engine/docs/how-to/deploying-windows-app) .\n", "content": "## Overview\nare applications which do not store data or application state to the [cluster](/kubernetes-engine/docs/how-to/creating-a-container-cluster) or to persistent storage. Instead, data and application state stay with the client, which makes stateless applications more scalable. For example, a frontend application is stateless: you deploy multiple replicas to increase its availability and scale down when demand is low, and the replicas have no need for unique identities.\nKubernetes uses the [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) controller to deploy stateless applications as uniform, non-unique [Pods](https://kubernetes.io/docs/concepts/workloads/pods) . Deployments manage the of your application: how many Pods should run your application, what version of the container image should run, what the Pods should be labelled, and so on. The desired state can be changed dynamically through updates to the Deployment's [Pod specification](https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates) .\nStateless applications are in contrast to [stateful applications](/kubernetes-engine/docs/how-to/stateful-apps) , which use [persistent storage](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) to save data and which use [StatefulSets](/kubernetes-engine/docs/concepts/statefulset) to deploy Pods with unique identities.\n## Before you begin\nBefore you start, make sure you have performed the following tasks:\n- Enable    the Google Kubernetes Engine API.\n- [    Enable Google Kubernetes Engine API   ](https://console.cloud.google.com/flows/enableapi?apiid=container.googleapis.com) \n- If you want to use the Google Cloud CLI for this task, [install](/sdk/docs/install) and then [initialize](/sdk/docs/initializing) the  gcloud CLI. If you previously installed the gcloud CLI, get the latest  version by running`gcloud components update`. **Note:** For existing gcloud CLI  installations, make sure to set the`compute/region`and`compute/zone` [properties](/sdk/docs/properties#setting_properties) . By setting default locations,  you can avoid errors in gcloud CLI like the following:`One of [--zone, --region] must be supplied: Please specify location`.\n- Ensure your containerized application is stored in an image registry, such as [Artifact Registry](/artifact-registry/docs/docker/pushing-and-pulling) .\n- If you are new to GKE, you should complete the [quickstart](/kubernetes-engine/docs/deploy-app-cluster) , in which you'll enable the GKE API and learn how the product works.## Anatomy of a Deployment\nThe following is an example of a simple Deployment manifest file. This Deployment creates three replicated Pods labelled `app=my-app` that run the `hello-app` image stored in [Artifact Registry](/artifact-registry/docs/docker/pushing-and-pulling) :\n```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: my-appspec:\u00a0 replicas: 3\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 run: my-app\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 run: my-app\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: hello-app\u00a0 \u00a0 \u00a0 \u00a0 image: us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0\n```\nIn this example:\n- `.spec.replicas`: is the number of replicated Pods that the Deployment manages.\n- `.spec.template.metadata.labels`: is the label given to each Pod, which the Deployment uses to manage the Pods.\n- `.spec.template.spec`: is the [Pod specification](https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates) , which defines how each Pod should run.`spec.containers`includes the name of the container to run in each Pod and the container image that should run.\nFor more information about the Deployment specification, refer to the [Deployment API reference](https://v1-25.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.25/#deployment-v1-apps) .\n## Creating a Deployment\nYou create a Deployment using one of the following methods:\n- You can use the Deploy feature in the Google Cloud console's [Workloads](/kubernetes-engine/docs/concepts/dashboards#workloads) menu to create a simple Deployment from a container image you've stored in [Artifact Registry](/artifact-registry/docs/docker/pushing-and-pulling) \n- You can write a Deployment manifest and run [kubectl apply](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply) to create the resource\nYou can [declaratively](https://kubernetes.io/docs/tutorials/object-management-kubectl/declarative-object-management-configuration/) create and update Deployments from manifest files using `kubectl apply` . This method also retains updates made to live resources without merging the changes back into the manifest files.\nTo create a Deployment from its manifest file, run the following command:\n```\nkubectl apply -f DEPLOYMENT_FILE\n```\nReplace `` with the manifest file, such as `config.yaml` .\nYou can also use `kubectl apply -f` `` `/` to create all objects (except existing ones) defined in manifest files stored a directory.\n **Note:** `kubectl apply` fails if you do not have an active cluster.\nTo create a Deployment, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- Click **Deploy** .\n- Under **Specify container** , select one of the following:- **Existing container image** to choose a container image available from Artifact Registry or DockerHub. In **Image path** , enter the path to the container image and the version.\n- **New container image** to use an image created with [Cloud Source Repositories](/source-repositories) and [Cloud Build](/source-repositories/docs/integrating-with-cloud-build) .\n- Optionally, configure your deployment with:- **Environment variables** to pass into the container.\n- **Initial commands** to customize the container's entrypoint at runtime.\n- Click **Done** , and then click **Continue** .\n- In the **Configuration** section, give your deployment an **Application name** and specify the Kubernetes **Namespace** to deploy it in.\n- Optionally, under **Labels** , you can add Kubernetes [Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) to the deployment.\n- To save the YAML that creates this deployment to [update](#update) it later, click **View YAML** . Copy and paste the YAML into a file, then save it and click **Close** on the **YAML Output** dialog.\n- From the **Kubernetes Cluster** drop-down menu, choose the desired cluster.\n- Click **Deploy** .## Inspecting the Deployment\nAfter you create a Deployment, you can use one of the following methods to inspect it:\n- You can use the [Workloads](/kubernetes-engine/docs/concepts/dashboards#workloads) menu\n- You can use [kubectl describe](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#describe) and [kubectl get](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get) \nTo get detailed information about the Deployment, run the following command:\n```\nkubectl describe deployment DEPLOYMENT_NAME\n```\nReplace `` with the name of the Deployment.\nTo list the Pods created by the Deployment, run the following command:\n```\nkubectl get pods -l KEY=VALUE\n```\nIn this command, the `-l` flag instructs `kubectl` to get all Pods with a key-value label. For example, if you labelled the Deployment `app: my-app` , you'd run `kubectl get pods -l app=my-app` to see Pods with that label.\nTo get information about a specific Pod:\n```\nkubectl describe pod POD_NAME\n```\nTo view a Deployment's manifest, run the following command:\n```\nkubectl get deployments DEPLOYMENT_NAME -o yaml\n```\nThis command displays the Deployment's live configuration in YAML format.\nTo inspect a Deployment, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the Deployment you want to inspect.\n- On the **Deployment details** page, do any of the following:- Click the **Revision History** tab to see the Deployment's revision history.\n- Click the **Events** tab to see all events related to the Deployment.\n- Click the **Logs** tab to see container activity logs in the Deployment.\n- Click the **YAML** tab to see, copy, and download the YAML manifest for the Deployment.\n## Updating the Deployment\nYou can roll out updates to a Deployment's [Pod specification](https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates) , such as their image, resource usage/requests, or configuration.\nYou can update a Deployment using the following methods:\n- You can use the **Rolling update** menu and YAML editor from the Google Cloud console [Workloads](/kubernetes-engine/docs/concepts/dashboards#workloads) menu.\n- You can make changes to a manifest file and apply them with [kubectl apply](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply) .\n- You can update the Pod specification's`image`,`resources`, or`selector`fields using [kubectl set](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#set) .\n- You can update a Deployment directly from your shell or in a preferred editor using [kubectl edit](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#edit) .\nYou can update the Deployment by a new or updated manifest file. This is useful for making various changes to your Deployment, such as for or for specifying a new of your application.\n **Note:** To update a resource with `kubectl apply` , the resource would need to have been created using either `kubectl apply` or `kubectl create --save-config` .\nTo update a Deployment, run the following command:\n```\nkubectl apply -f DEPLOYMENT_FILE\n```\nReplace `` with the updated manifest file.\nThe `kubectl apply` command applies a manifest file to a resource. If the specified resource does not exist, it is created by the command.\nYou can use `kubectl set` to change a Deployment's image, resources (requests or limits), or selector fields.\nTo change a Deployment's image, run the following command:\n```\nkubectl set image deployment DEPLOYMENT_NAME IMAGE IMAGE:TAG\n```\nFor example, to update a Deployment from `nginx` version 1.7.9 to 1.9.1, run the following command:\n```\nkubectl set image deployment nginx nginx=nginx:1.9.1\n```\nTo access the Deployment's **Rolling update** menu:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the Deployment you want to modify.\n- Click **Actions > Rolling update** .\n- Configure the following optional parameters for the update strategy:- **Minimum seconds ready:** Specifies the minimum number of seconds for which newly-created Pods should be ready to be considered available.\n- **Maximum surge:** Specifies the maximum number of Pods that can be created over the desired number of Pods. Value can be an absolute number or a percentage.\n- **Maximum unavailable:** Specifies the maximum number of Pods that can be unavailable during the update process. Value can be an absolute number or a percentage.\n- Under **Container images** , enter the image path and version for the updated container image.\n- Click **Update** .\n### Rolling back an update\nYou can roll back an update using [kubectl rollout undo](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout) .\nYou can roll back an in-progress or completed update to its previous revision:\n```\nkubectl rollout undo deployment my-deployment\n```\nYou can also roll back to a specific revision:\n```\nkubectl rollout undo deployment my-deployment --to-revision=3\n```\n## Scaling a Deployment\nYou can manually scale a Deployment using the Google Cloud console or [kubectl scale](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#scale) .\nYou can learn more about [autoscaling Deployments](/kubernetes-engine/docs/how-to/scaling-apps#autoscaling-deployments) .\n`kubectl scale` can be used at any time to scale your Deployment.\nTo manually scale a Deployment, run the following command:\n```\nkubectl scale deployment DEPLOYMENT_NAME --replicas NUMBER_OF_REPLICAS\n```\nReplace `` with the desired number of replicated Pods.\nTo scale a Deployment, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, click the name of the Deployment you want to modify.\n- Click **Actions > Scale > Edit replicas** \n- Enter the new number of **Replicas** for the Deployment.\n- Click **Scale** .## Deleting a Deployment\nYou can delete a Deployment using the Google Cloud console or [kubectl delete](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete) .\nTo delete a Deployment, run the following command:\n```\nkubectl delete deployment DEPLOYMENT_NAME\n```\nTo delete a Deployment, perform the following steps:- Go to the **Workloads** page in the Google Cloud console. [Go to Workloads](https://console.cloud.google.com/kubernetes/workload) \n- In the workloads list, select one or more Deployments to delete.\n- Click **Delete** .\n- When prompted to confirm, click **Delete** .## What's next\n- [Learn more about Deployments](/kubernetes-engine/docs/concepts/deployment) .\n- [Learn about stateful applications](/kubernetes-engine/docs/how-to/stateful-apps) .", "guide": "Google Kubernetes Engine (GKE)"}