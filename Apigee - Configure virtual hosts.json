{"title": "Apigee - Configure virtual hosts", "url": "https://cloud.google.com/apigee/docs/api-platform/get-started/what-apigee", "abstract": "# Apigee - Configure virtual hosts\nYou are currently viewing version 1.2 of the Apigee hybrid documentation. **This version is end of life.** You should upgrade to a newer version. For more information, see [Supported versions](/apigee/docs/hybrid/supported-platforms#supported-versions) .\n**NOTE: ** The`virtualhosts`configuration is new in version 1.2.0. The virtual host`name`must:- contain no more than 253 characters\n- contain only lowercase alphanumeric characters or a hyphen`-`\n- start with an alphanumeric character\n- end with an alphanumeric character\nThis topic discusses virtual host configuration. Virtual hosts allow Apigee hybrid to handle API requests to multiple domain names and route proxy basepaths to specific environments.\nTo specify which environment specific API proxy base paths should be routed to, use the `virtualhosts.routingRules[]` configuration property. For details on the individual properties, see [virtualhosts](/apigee/docs/hybrid/v1.2/config-prop-ref#virtualhosts) in the Configuration property reference. For example:\n```\n...\nvirtualhosts:\n - name: vhost-one\n hostAliases: [\"api.example.com\"]\n sslCertPath: ./certs/fullchain.pem\n sslKeyPath: ./certs/privkey.pem\n routingRules:\n  - paths:\n  - /orders\n  - /items\n  env: test1\n  - paths:\n  - /customers\n  env: test2\nenvs:\n - name: test1\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n - name: test2\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n```\nWhen an API call comes in such as: `https://api.example.com/orders` , the request is sent to the `test1` environment's message processor. Similarly, if a request to `https://api.example.com/customers` comes in, it is routed to the `test2` environment.\n", "content": "## \n Adding a new environment\nTo add a new environment, add its configuration to the `envs[]` property, and add a new `virtualhosts.routingRules.path` entry that specifies which base paths you want to map to the new environment. In the following example, a new environment named `test3` is added, and the `routingRules` have been updated to route two paths to the new environment:\n```\nvirtualhosts:\n - name: vhost-one\n hostAliases: [\"api.example.com\"]\n sslCertPath: ./certs/fullchain.pem\n sslKeyPath: ./certs/privkey.pem\n routingRules:\n  - paths:\n  - /orders\n  - /items\n  env: test1\n  - paths:\n  - /v0/hello\n  - /httpbin\n  env: test2\n  - paths:\n  - /v0/inventory\n  - /v0/customers\n  env: test3\nenvs:\n - name: test1\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n - name: test2\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n - name: test3\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n```\nTo apply the update, you only need to apply the `runtime` component, as follows:\n```\napigeectl apply -f overrides-file.yaml -c runtime\n```\n## \n Adding multiple virtual hosts\nThe `virtualhosts[]` property is an array, and therefore you can create more than one. Each virtual host must contain a unique set of host aliases: no two virtual hosts can share the same host alias. For example, the new virtual host `dev` handles traffic sent to the `api.internal.com` domain.\n```\nvirtualhosts:\n - name: vhost-one\n hostAliases: [\"api.example.com\"]\n sslCertPath: ./certs/fullchain.pem\n sslKeyPath: ./certs/privkey.pem\n routingRules:\n  - paths:\n  - /orders\n  - /items\n  env: test1\n  - paths:\n  - /v0/hello\n  - /httpbin\n  env: test2\n  - paths:\n  - /v0/inventory\n  - /v0/customers\n  env: test3\n - name: vhost-two\n hostAliases: [\"api.internal.com\"]\n sslCertPath: ./certs/fullchain.pem\n sslKeyPath: ./certs/privkey.pem\n routingRules:\n  - paths:\n  - /orders\n  - /items\n  env: test1\n  - paths:\n  - /v0/hello\n  - /httpbin\n  env: test2\n  - paths:\n  - /v0/inventory\n  - /v0/customers\n  env: test3\nenvs:\n - name: test1\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n - name: test2\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n - name: test3\n serviceAccountPaths:\n  synchronizer: ./sa/synchronizer.json\n  udca: ./sa/udca.json\n```\nTo apply the update, you only need to apply the `runtime` component, as follows:\n```\napigeectl apply -f overrides-file.yaml -c runtime\n```\n**NOTE: ** If you only add or change the`virtualhosts`stanza, and nothing else, then you can apply those changes with the`--settings`flag:```\napigeectl apply -f overrides-file.yaml --settings virtualhosts -c runtime\n```If you change virtualhosts and envs, then you must apply the change without using `--settings` ,  like this, to update the runtime component fully:```\napigeectl apply -f overrides-file.yaml -c runtime\n```\n## TLS keys and certificates\nWhen you create a new virtual host, you must provide a TLS key and certificate.  The key/cert are used to provide secure communication with the ingress gateway.\nIt is up to you how you generate proper TLS certificate/key pairs for your hybrid configuration. The following topics are provided as samples only, intended primarily for trying out or testing a new hybrid installation if it isn't feasible to obtain TLS credentials in another way:\n- See [Obtain TLS credentials](/apigee/docs/hybrid/v1.2/lets-encrypt) for a set of sample  steps for creating an authorized TLS certificate/key pair.\n- You can use a self-signed certificate/key pair(s) for testing purposes only. See [Generate self-signed TLS credentials](/apigee/docs/hybrid/v1.2/environment-self-signed-tls) .", "guide": "Apigee"}