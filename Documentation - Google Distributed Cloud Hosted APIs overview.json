{"title": "Documentation - Google Distributed Cloud Hosted APIs overview", "url": "https://cloud.google.com/distributed-cloud/hosted/docs/latest/gdch/overview", "abstract": "# Documentation - Google Distributed Cloud Hosted APIs overview\nGoogle Distributed Cloud Hosted (GDCH) application programming interfaces (APIs) are programmatic interfaces to the GDCH platform services. Google builds the control-plane APIs on top of Kubernetes, using the Kubernetes Resource Model (KRM). The control plane performs resource management for services such as creation, deletion, and updates.\nSpecific services have these APIs and their own data-plane APIs, which are XML, JSON, or gRPC-based. This page covers these services in their respective sections.\n", "content": "## About GDCH APIs\nThere are two types of GDCH APIs: those that are Kubernetes-based and those that are not. Many GDCH APIs are extensions to the open source Kubernetes API. They use Kubernetes custom resources and rely on the KRM. These APIs, like the Kubernetes API, are HTTP-based RESTful APIs, accepting and returning JSON as the default, or in Protobuf. The API endpoint is the relevant Kubernetes server.\nOther, non-Kubernetes based GDCH APIs, such as the Vertex pre-trained AI APIs, have their own endpoints. In addition to supporting HTTP, some of these APIs may also be accessible by gRPC, the open-source remote-procedure call framework. For more information on specific APIs, see their dedicated documentation in the vertical navigation menu.\nTo access GDCH APIs, use the [gdcloud CLI tools](/distributed-cloud/hosted/docs/latest/gdch/resources/gdcloud-overview) or GDCH console.\n## About the Kubernetes API and the KRM\nAs many of the GDCH APIs are extensions to the Kubernetes API and rely on the KRM, an understanding of these concepts help you take advantage of GDCH APIs to their full extent.\nThe Kubernetes API is fully declarative, and everything in the Kubernetes API is a resource that follows the KRM. API clients, both human and machine, act on those resources, often with create, read, update, and delete (CRUD) operations. The Kubernetes database stores the resource and represents the state of the system. Kubernetes continuously watches those resources and reconciles the real state of the system with the desired state. For example, if you update a `Deployment` resource to indicate that you want five replicas of your container instead of four, Kubernetes detects the change in the desired number of replicas and creates an additional container.\nFor the core Kubernetes API, Kubernetes performs the reconciliation between desired and real states itself. The Kubernetes API extensions are custom resources that are not part of the core Kubernetes API. The custom software continuously watches and interacts with the Kubernetes API and performs the reconciliation.\nTo learn more about the Kubernetes API and the Kubernetes resource model, read the official Kubernetes documentation.\n- Kubernetes API Overview, at [https://kubernetes.io/docs/reference/using-api/](https://kubernetes.io/docs/reference/using-api/) \n- Kubernetes API Concepts, at [https://kubernetes.io/docs/reference/using-api/api-concepts/](https://kubernetes.io/docs/reference/using-api/api-concepts/) \n- The Kubernetes Resource Model (KRM), at [https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/resource-management.md](https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/resource-management.md) ## GDCH APIs access\nBoth the gdcloud CLI tools and the GDCH console leverage the GDCH APIs. Google recommends that you use those to explore GDCH or to do one-off operations. However, if you use automated or programmatic access to GDCH, Google recommends that you use the GDCH APIs directly.\n### HTTP and gRPC support\nMost GDCH APIs provide a JSON HTTP interface that you call directly. The Kubernetes-based APIs use the Kubernetes client libraries. Some non-Kubernetes GDCH APIs have a gRPC interface, which provides improved performance and usability. Google also provides client libraries for GDCH APIs that aren't based on Kubernetes. To read more about gRPC, go to [https://grpc.io/](https://grpc.io/) .\n### TLS encryption\nAll GDCH APIs accept requests using the Transport Layer Security (TLS) encryption.\n- If you are using one of the Kubernetes or GDCH client libraries, the library handles in-transit encryption for you.\n- If you are using your own HTTP or gRPC client, you must authenticate with GDCH, which requires TLS. For gRPC, follow the instructions in the gRPC authentication guide at [https://grpc.io/docs/guides/auth/](https://grpc.io/docs/guides/auth/) .\n**Note:** GDCH recommends that you use existing clients, especially ones Google provides, to interact with GDCH APIs. Creating your own API client is an arduous software-engineering task that, if done incorrectly, might lead to unforeseen behaviors in your systems that are difficult to diagnose.\n### Access the Kubernetes API and Kubernetes-based APIs\nThe `kubectl` Kubernetes CLI is the primary way to work directly with the Kubernetes API and any Kubernetes-based APIs.\nWhen accessing the Kubernetes API for the first time, use the Kubernetes command-line tool, `kubectl` .\nTo access a cluster, you need the cluster location information and the credentials to access it. See the [Sign in with CLI and kubectl](/distributed-cloud/hosted/docs/latest/gdch/platform/pa-user/iam#sign_in_with_cli_and_the_kubectl_tool) section to learn how to get access to those credentials.\nExamine your current `kubectl` configuration and see the clusters to which you have access:\n```\nkubectl config view\n```\nThe following are ways to directly access the REST API with an HTTP client like `curl` , `wget` , or a browser:\n- Rely on`kubectl`to handle the authentication by using it in proxy mode.\n- Handle the authentication yourself.The `kubectl proxy` command runs `kubectl` in a mode where it acts as a reverse proxy. This command connects to the `apiserver` and manages the authentication.\nRunning `kubectl` in proxy mode uses the stored API server location and verifies the identity of the API server using a certificate. This method guards against man-in-the-middle (MITM) attacks.\nThe following example shows how to use the `kubectl proxy` command:\n```\nkubectl proxy --port=8080 &\n```\nOnce the `kubectl` proxy is running, you can explore the API with `curl` , `wget` , or a browser, as shown in the following:\n```\n$ curl http://localhost:8080/api/\n{\n \"versions\": [ \"v1\"\n ],\n \"serverAddressByClientCIDRs\": [ {\n  \"clientCIDR\": \"0.0.0.0/0\",\n  \"serverAddress\": \"10.0.1.149:443\"\n }\n ]\n}\n```\nIf you don't want to run `kubectl` in proxy mode, you can pass an authentication token directly to the `apiserver` . Replace `` with the name of the cluster you want to interact with in the following commands:\n```\n# Check all possible clusters, as your kubeconfig file may have multiple contexts:kubectl config view \\\u00a0 \u00a0 -o jsonpath='{\"Cluster name\\tServer\\n\"}{range.clusters[*]}{.name}{\"\\t\"}{.cluster.server}{\"\\n\"}{end}'# Select name of cluster you want to interact with from the previous output:export CLUSTER_NAME=\"[YOUR_CLUSTER]\"APISERVER=$(kubectl config view -o jsonpath=\"{.clusters[?(@.name==\\\"$CLUSTER_NAME\\\")].cluster.server}\")TOKEN=$(kubectl get secret $(kubectl get secrets | grep default | cut -f1 -d ' ') \u00a0\\\u00a0 \u00a0 -o jsonpath='{.data.token}' | base64 --decode)\n```\nAfter you have exported the token in the `$TOKEN` environment variable, use it with a tool like `curl` by adding the HTTP header `Authorization: Bearer $TOKEN` as shown in the following example:\n```\n$ curl -k $APISERVER/api --header \"Authorization: Bearer $TOKEN\"\n{\n \"kind\": \"APIVersions\",\n \"versions\": [ \"v1\"\n ],\n \"serverAddressByClientCIDRs\": [ {\n  \"clientCIDR\": \"0.0.0.0/0\",\n  \"serverAddress\": \"10.0.1.149:443\"\n }\n ]\n}\n```", "guide": "Documentation"}