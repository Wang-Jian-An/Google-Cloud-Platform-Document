{"title": "Google Kubernetes Engine (GKE) - About Jenkins on GKE", "url": "https://cloud.google.com/kubernetes-engine/docs/concepts/kubernetes-engine-overview", "abstract": "# Google Kubernetes Engine (GKE) - About Jenkins on GKE\n**Warning:** This page is **archived** and is not actively maintained. The commands on this page might not work and could cause disruptions to your cluster.\nThis topic teaches you best practices for using Jenkins with Google Kubernetes Engine. To implement this solution, see [setting up Jenkins on Kubernetes Engine](/solutions/jenkins-on-kubernetes-engine-tutorial) .\nJenkins is an open-source automation server that lets you flexibly orchestrate your build, test, and deployment pipelines. Kubernetes Engine is a hosted version of Kubernetes, a powerful cluster manager and orchestration system for containers.\nWhen you need to set up a continuous delivery (CD) pipeline, deploying Jenkins on Kubernetes Engine provides important benefits over a standard VM-based deployment:\n- When your build process uses containers, one virtual host can run jobs against different operating systems.\n- Kubernetes Engine provides ephemeral build executors, allowing each build to run in a clean environment that's identical to the builds before it.- As part of the ephemerality of the build executors, the Kubernetes Engine cluster is only utilized when builds are actively running, leaving resources available for other cluster tasks such as batch processing jobs.\n- Build executors launch in seconds.\n- Kubernetes Engine leverages the [Google global load balancer](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44824.pdf) to route web traffic to your instance. The load balancer handles SSL termination, and provides a global IP address that routes users to your web front end on one of the fastest paths from the point of presence closest to your users through the Google backbone network.\nFor a deep dive into Jenkins on Kubernetes Engine, watch the Next 2018 talk on YouTube:\nThe [State of DevOps](/devops) reports identified capabilities that drive software delivery performance. This topic will help you with the following capabilities:\n- [Continuous integration](/solutions/devops/devops-tech-continuous-integration) \n- [Continuous delivery](/solutions/devops/devops-tech-continuous-delivery) \n- [Deployment automation](/solutions/devops/devops-tech-deployment-automation) ", "content": "## Deploying the Jenkins controller with Helm\nUse [Helm](https://github.com/kubernetes/helm) to deploy Jenkins from the [Charts](https://github.com/kubernetes/charts) repository. Helm is a package manager you can use to configure and deploy [Kubernetes apps](https://hub.kubeapps.com/) .\nThe following image describes the architecture for deploying Jenkins in a multi-node Kubernetes cluster.\nDeploy the Jenkins controller into a separate [namespace](http://kubernetes.io/docs/admin/namespaces/) in the Kubernetes cluster. Namespaces allow for [creating quotas](http://kubernetes.io/docs/admin/resourcequota/) for the Jenkins deployment as well as logically separating Jenkins from other deployments within the cluster.\n### Creating Jenkins services\nJenkins provides two services that the cluster needs access to. Deploy these services separately so they can be individually managed and named.\n- An externally-exposed [NodePort service](http://kubernetes.io/docs/user-guide/services/#type-nodeport) on port 8080 that allows pods and external users to access the Jenkins user interface. This type of service can be load balanced by an HTTP load balancer.\n- An internal, private [ClusterIP service](http://kubernetes.io/docs/user-guide/services/#publishing-services---service-types) on port 50000 that the Jenkins executors use to communicate with the Jenkins controller from inside the cluster.\nThe following sections show sample service definitions. (The controller is called `master` in the definitions.)\n[  jenkins/k8s/service_jenkins.yaml ](https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/blob/v1/jenkins/k8s/service_jenkins.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/blob/v1/jenkins/k8s/service_jenkins.yaml)\n```\n---\u00a0 kind: Service\u00a0 apiVersion: v1\u00a0 metadata:\u00a0 \u00a0 name: jenkins-ui\u00a0 \u00a0 namespace: jenkins\u00a0 spec:\u00a0 \u00a0 type: NodePort\u00a0 \u00a0 selector:\u00a0 \u00a0 \u00a0 app: master\u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 - protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 port: 8080\u00a0 \u00a0 \u00a0 \u00a0 targetPort: 8080\u00a0 \u00a0 \u00a0 \u00a0 name: ui\n```\n[  jenkins/k8s/service_jenkins.yaml ](https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/blob/v1/jenkins/k8s/service_jenkins.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/blob/v1/jenkins/k8s/service_jenkins.yaml)\n```\n---\u00a0 kind: Service\u00a0 apiVersion: v1\u00a0 metadata:\u00a0 \u00a0 name: jenkins-discovery\u00a0 \u00a0 namespace: jenkins\u00a0 spec:\u00a0 \u00a0 selector:\u00a0 \u00a0 \u00a0 app: master\u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 - protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 port: 50000\u00a0 \u00a0 \u00a0 \u00a0 targetPort: 50000\u00a0 \u00a0 \u00a0 \u00a0 name: slaves\n```\n### Creating the Jenkins deployment\nDeploy the Jenkins controller as a [deployment](http://kubernetes.io/docs/user-guide/deployments) with a [replica count](http://kubernetes.io/docs/user-guide/replication-controller/#multiple-replicas) of 1. This ensures that there is a single Jenkins controller running in the cluster at all times. If the Jenkins controller pod dies or the node that it is running on shuts down, Kubernetes restarts the pod elsewhere in the cluster.\nIt's important to set [requests and limits](https://github.com/helm/charts/blob/28250ead2088bb36831864f43648d94dfee4f618/stable/jenkins/values.yaml#L42) as part of the Helm deployment, so that the container is guaranteed a certain amount of CPU and memory resources inside the cluster before being scheduled. Otherwise, your controller could go down due to CPU or memory starvation.\nThe Jenkins home volume stores XML configuration files and plugin JAR files that make up your configuration. This data is stored on a Persistent Disk managed by the GKE cluster and will persist data across restarts of Jenkins. To change the size of the persistent disk edit the `Persistence.Size` value when installing Jenkins with Helm.\n## Connecting to Jenkins\nOnce the Jenkins pod has been created you can create a load balancer endpoint to connect to it from outside of Cloud Platform. Consider the following best practices.\n- Use a Kubernetes [ingress](http://kubernetes.io/docs/user-guide/ingress/#what-is-ingress) resource for an easy-to-configure L7 load balancer with SSL termination.\n- Provide SSL certs to the load balancer using Kubernetes secrets. Use `tls.cert` and `tls.key` values, and reference the values in your ingress resource configuration.## Configuring Jenkins\n### Securing Jenkins\nAfter you connect to Jenkins for the first time, it's important to immediately [secure Jenkins](https://www.jenkins.io/doc/book/security/) .\n### Installing plugins\nYou can install the following plugins to enhance the interactions between Jenkins and Kubernetes Engine.\n- The [Kubernetes plugin](https://plugins.jenkins.io/kubernetes/) enables using Kubernetes service accounts for authentication, and creating labeled executor configurations with different base images. The plugin creates a pod when an executor is required and destroys the pod when a job ends.\n- The [Google Authenticated Source plugin](https://plugins.jenkins.io/google-source-plugin/) enables using your service account credentials when accessing Cloud Platform services such as Cloud Source Repositories.\nTo add additional plugins using the Helm chart, edit the [list of plugins](https://github.com/helm/charts/blob/28250ead2088bb36831864f43648d94dfee4f618/stable/jenkins/values.yaml#L137) in the values file that you pass to the Helm install or upgrade commands.\n### Customizing the Jenkins Agent Docker image\nWhen creating a pod template, you can either provide an existing Docker image, or you can create a custom image that has most of your build-time dependencies installed. Using a custom image can decrease overall build time and create more consistent build environments.\nYour custom Docker image must install and configure the [Jenkins JNLP inbound agent](https://github.com/jenkinsci/docker-inbound-agent) . The JNLP agent is software that communicates with the Jenkins controller to coordinate running your Jenkins jobs and reporting job status.\nOne option is to add `FROM jenkins/inbound-agent` to your image configuration. For example, if your application build process depends on the Go runtime, you can create the following Dockerfile to extend the existing image with your own dependencies and build artifacts.\n```\nFROM jenkins/inbound-agentRUN apt-get update && apt-get install -y golang\n```\nThen, build and upload the image to your project's Container Registry repository by running the following commands.\n```\ndocker build -t gcr.io/[PROJECT]/my-jenkins-image .\n```\n```\ngcloud auth configure-docker\n```\n```\ndocker push gcr.io/[PROJECT]/my-jenkins-image\n```\nWhen creating a pod template, you can now set the **Docker image** field to the following string, where `[PROJECT]` is replaced with your project name and `[IMAGE_NAME]` is replaced with the image name.\n```\ngcr.io/[PROJECT]/[IMAGE_NAME]\n```\nThe above example ensures that the Go language runtime is pre-installed when your Jenkins job starts.\n### Building Docker Images in Jenkins\nCloud Build can be used from within your Jenkins jobs to build Docker images without needing to host your own Docker daemon. Your Jenkins job must have service account credentials available that have been granted the `cloudbuild.builds.editor` role.\nFor an example Jenkins Pipeline file, see this [GitHub repository](https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/blob/320bf7b11cc3f4f9d74fe26a173f886574e2ef2f/sample-app/Jenkinsfile#L51) .\n[Kaniko](https://github.com/GoogleContainerTools/kaniko) is another option for users looking to build containers inside their clusters. Kaniko does not require a Docker daemon to be present in order to build and push images to a remote registry.\nFor an example of using Kaniko in Jenkins, see this [GitHub repository](https://github.com/jenkinsci/kubernetes-plugin/blob/kubernetes-1.14.5/examples/kaniko-declarative.groovy) .\n## What's next\n- See the [setting up Jenkins on Kubernetes Engine tutorial](/solutions/jenkins-on-kubernetes-engine-tutorial) .\n- Learn about how to set up [continuous deployment to Kubernetes Engine using Jenkins](/kubernetes-engine/docs/how-to/continuous-delivery-jenkins-kubernetes-engine) .\n- Read our resources about [DevOps](/devops) .\n- Learn more about the DevOps capabilities related to this solution:- [Continuous integration](/solutions/devops/devops-tech-continuous-integration) \n- [Continuous delivery](/solutions/devops/devops-tech-continuous-delivery) \n- [Deployment automation](/solutions/devops/devops-tech-deployment-automation) \n- Take the [DevOps quick check](https://www.devops-research.com/quickcheck.html) to understand where you stand in comparison with the rest of the industry.", "guide": "Google Kubernetes Engine (GKE)"}