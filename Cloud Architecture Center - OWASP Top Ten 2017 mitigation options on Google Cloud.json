{"title": "Cloud Architecture Center - OWASP Top Ten 2017 mitigation options on Google Cloud", "url": "https://cloud.google.com/architecture/reference-patterns/overview", "abstract": "# Cloud Architecture Center - OWASP Top Ten 2017 mitigation options on Google Cloud\nLast reviewed 2021-05-27 UTC\nThis document helps you identify Google Cloud products and mitigation strategies that can help you defend against common application-level attacks that are outlined in [OWASP Top Ten 2017](https://owasp.org/www-project-top-ten/2017/) . OWASP Top Ten is a list by the [Open Web Application Security (OWASP) Foundation](https://owasp.org/) of the top 10 security risks that every application owner should be aware of. Although no security product can guarantee full protection against these risks, applying these products and services when they make sense in your architecture can contribute to a strong multi-layer security solution.\nFor the OWASP Top 10 2021 mitigation options, see [OWASP Top 10 2021 mitigation options on Google Cloud](/architecture/owasp-top-ten-mitigation) .\n[Google infrastructure is designed to help you build, deploy, and operate services in a secure way](/security/infrastructure/design) . Physical and operational security, insider threat detection, data encryption at rest and in transit, and many other important facets of a secure infrastructure are managed by Google. You inherit these benefits by deploying your applications to Google Cloud, but you might need to take additional measures to protect your application against specific attacks.\nThe mitigation strategies listed in this document are sorted by application security risk and Google Cloud product. Many products play a role in creating a defense-in-depth strategy against web security risks. This document provides information about how other products can mitigate OWASP Top 10 risks, but it provides additional detail about how Google Cloud Armor and Apigee can mitigate a wide range of those risks. Google Cloud Armor, acting as a web application firewall (WAF), and Apigee, acting as an API gateway, can be especially helpful in blocking different kinds of attacks. These products are in the traffic path from the internet and can block external traffic before it reaches your applications in Google Cloud.\n**Note:** Some descriptions refer to vulnerabilities in the [OWASP Juice Shop application](https://owasp.org/www-project-juice-shop/) and show how to mitigate these vulnerabilities. The Juice Shop application is a useful example application used for security training and awareness, because it contains instances of each of the OWASP Top 10 security vulnerabilities\u2014by design\u2014that an attacker can exploit for testing purposes. Because the purpose of the Juice Shop is to learn about attacks, the [Juice Shop challenges](https://pwning.owasp-juice.shop/part2/) refer to challenges in attacking the insecure Juice Shop application, while the [challenge solutions](https://pwning.owasp-juice.shop/appendix/solutions.html) provide instructions about exploiting vulnerabilities. In this document, you learn how to mitigate some of the Juice Shop built-in vulnerabilities by using Google Cloud services.\n", "content": "## Product overviews\nThe Google Cloud products listed in the following table can help defend against the top 10 security risks:\n| Product       | Summary                                          | A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10 |\n|:--------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----|:-----|:-----|:-----|:-----|:-----|:-----|:-----|:-----|:------|\n| Access Transparency    | Expand visibility and control over your cloud provider with admin access logs and approval controls                   | nan | \u2713 | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Apigee       | Design, secure, and scale application programming interfaces                             | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | nan | nan | \u2713  |\n| Binary Authorization   | Ensure only trusted container images are deployed on Google Kubernetes Engine                         | nan | nan | nan | nan | nan | nan | nan | nan | \u2713 | nan |\n| Chronicle Detect    | Automatically find threats in real-time and at scale using Google's infrastructure, detection techniques, and signals               | nan | nan | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Cloud Asset Inventory   | View, monitor, and analyze all your Google Cloud and Google Distributed Cloud Virtual or multi-cloud assets across projects and services          | nan | nan | \u2713 | nan | \u2713 | \u2713 | nan | nan | nan | nan |\n| Sensitive Data Protection  | Discover, classify, and protect your most sensitive data                              | nan | nan | \u2713 | nan | nan | nan | nan | nan | nan | \u2713  |\n| Cloud Load Balancing   | Control which ciphers your SSL proxy or HTTPS load balancer negotiates                          | nan | nan | \u2713 | nan | \u2713 | \u2713 | nan | nan | \u2713 | nan |\n| Cloud Logging     | Real-time log management and analysis at scale                                | nan | nan | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Cloud Monitoring    | Collect and analyze metrics, events, and metadata from Google Cloud services and a wide variety of applications and third-party services          | nan | nan | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Cloud Source Repositories  | Store, manage, and track code in a single place for your team                             | nan | nan | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Container Threat Detection  | Continuously monitor the state of container images, evaluate all changes, and monitor remote access attempts to detect runtime attacks in near-real time      | \u2713 | nan | nan | nan | nan | nan | nan | nan | \u2713 | nan |\n| Event Threat Detection   | Monitor your organization's Cloud Logging stream and detect threats in near-real time                       | nan | \u2713 | nan | nan | nan | nan | nan | nan | \u2713 | \u2713  |\n| Forseti Inventory    | Collect and store snapshots of your architecture                                | nan | nan | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Forseti Scanner     | Scan inventory data according to custom-defined policies and alert on unexpected deviations                     | nan | nan | nan | nan | \u2713 | nan | nan | nan | nan | nan |\n| Google Cloud Armor    | A web application firewall (WAF) deployed at the edge of Google's network to help defend against common attack vectors              | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713  |\n| Google Cloud security bulletins | The latest security bulletins related to Google Cloud products                            | nan | nan | nan | nan | nan | nan | nan | nan | \u2713 | nan |\n| Identity-Aware Proxy (IAP)  | Use identity and context to guard access to your applications and VMs                           | nan | \u2713 | \u2713 | nan | \u2713 | nan | nan | nan | nan | nan |\n| Identity Platform    | Add identity and access management functionality to applications, protect user accounts, and scale identity management              | nan | \u2713 | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Key Management Service   | Manage encryption keys on Google Cloud                                  | nan | nan | \u2713 | nan | nan | nan | nan | nan | nan | \u2713  |\n| ReCAPTCHA Enterprise   | Help protect your website from fraudulent activity, spam, and abuse                           | nan | \u2713 | nan | nan | nan | nan | nan | nan | nan | nan |\n| Secret Manager     | Store API keys, passwords, certificates, and other sensitive data                            | nan | nan | \u2713 | nan | nan | nan | nan | nan | nan | nan |\n| Security Command Center   | Centralized visibility for security analytics and threat intelligence to surface vulnerabilities in your applications               | nan | nan | nan | nan | nan | nan | nan | nan | nan | \u2713  |\n| Security Health Analytics (SHA) | Generate vulnerability findings that are available in Security Command Center                         | nan | \u2713 | \u2713 | nan | \u2713 | \u2713 | nan | nan | nan | nan |\n| Titan Security Keys    | Help protect high-value users with phishing-resistant 2FA devices that are built with a hardware chip (with firmware engineered by Google) to verify the integrity of the key | nan | \u2713 | nan | nan | nan | nan | nan | nan | nan | nan |\n| VPC Service Controls   | Isolate resources of multi-tenant Google Cloud services to mitigate data exfiltration risks                     | nan | nan | \u2713 | nan | nan | nan | nan | nan | nan | nan |\n| VirusTotal      | Analyze suspicious files and URLs to detect types of malware; automatically share them with the security community               | nan | nan | \u2713 | nan | nan | nan | nan | \u2713 | nan | nan |\n| Web Security Scanner   | Generate vulnerability finding types that are available in Security Command Center                       | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | \u2713 | nan |\n## A1: Injection\n[Injection flaws](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection) , such as SQL, NoSQL, OS, and LDAP injection, occur when untrusted data is sent to an interpreter as part of a command or query. The attacker's hostile data can trick the interpreter into running unintended commands or accessing data without proper authorization. We recommend that user data is sanitized or filtered by the application before it is sent to an interpreter.\nThe following sections discuss the Google Cloud products that can help mitigate this risk.\n### Apigee\nUse case:\n- SQL injection blocking\n- NoSQL injection blocking\n- LDAP injection blocking\n- JavaScript injection blocking\nApigee provides several input validation policies to verify that the values provided by a client match your configured expectations before allowing the further processing of the policies or rules. Apigee, acting as a gateway for the incoming API requests, runs a limit check to ensure that the payload structure falls within an acceptable range. You can [configure an API proxy](/apigee/docs/api-platform/develop/attaching-and-configuring-policies-management-ui) so that the input validation routine transforms the input in order to remove risky character sequences, and then replace them with safe values.\nThere are several approaches to validating input with the Apigee platform:\n- [JSONThreatProtection](/apigee/docs/api-platform/reference/policies/json-threat-protection-policy) checks the JSON payload for threats.\n- [XMLThreatProtection](/apigee/docs/api-platform/reference/policies/xml-threat-protection-policy) checks the XML payload for threats.\n- [JavaScript](/apigee/docs/api-platform/reference/policies/javascript-policy) validates parameters and headers.\n- The [RegularExpressionProtection policy](/apigee/docs/api-platform/reference/policies/regular-expression-protection) handles SQL code injections.\n- The [OASValidation policy](/apigee/docs/api-platform/reference/policies/oas-validation-policy) validates an incoming request or response message against an OpenAPI Specification (JSON or YAML).\n- The [SOAPMessageValidation policy](/apigee/docs/api-platform/reference/policies/message-validation-policy) validates any XML message against their XSD schemas and can also validate SOAP messages against a WSDL definition.\n### Container Threat Detection\nUse case:\n- Malicious script detection\n- Reverse shell detection\n- Malware installation detection\nThe [Malicious Script Executed](/security-command-center/docs/how-to-investigate-threats#malicious_script_executed) detector of [Container Threat Detection](/security-command-center/docs/concepts-container-threat-detection-overview) analyzes every shell script executed on the system and reports ones that look malicious. This provides a vehicle to detect shell command injection attacks. After a successful shell command injection, an attacker can spawn a reverse shell, which triggers the [Reverse Shell](/security-command-center/docs/how-to-investigate-threats#reverse_shell) detector. Alternatively, they can install malware, which triggers the [Added Binary Executed](/security-command-center/docs/how-to-investigate-threats#added_binary_executed) and [Added Library Loaded](/security-command-center/docs/how-to-investigate-threats#added_library_loaded) detectors.\n### Google Cloud Armor\nUse case:\n- SQL injection filtering\n- PHP injection filtering\nGoogle Cloud Armor can block common injection attacks before they reach your application. For SQL injection (SQLi), Google Cloud Armor has a [predefined rule set](/armor/docs/rule-tuning) that is based on the [OWASP Modsecurity core rule set](https://modsecurity.org/crs/) (version 3.0.2 at the time of writing). You can [build security policies](/armor/docs/configure-security-policies) that [block SQLi attacks](/armor/docs/rules-language-reference#preconfigured-rules) defined in the core rule set by using the `evaluatePreconfiguredExpr('sqli-stable')` rule either by itself or in conjunction with other custom rules. For example, you can limit SQLi blocking to specific applications by using a [URL path filter](/armor/docs/rules-language-reference#allow_or_deny_traffic_for_a_request_uri_that_matches_a_regular_expression) .\nFor PHP injection, another [preconfigured rule set](/armor/docs/rule-tuning) exists. You can use the `evaluatePreconfiguredExpr('php-stable')` rule to block common PHP injection attacks.\nDepending on your application, activating the preconfigured expressions might lead to some false positives because some of the rules in the rule set are quite sensitive. For more information, see [troubleshooting false positives](/armor/docs/troubleshooting#false-positives) and [how to tune the rule set to different sensitivity levels](/armor/docs/rule-tuning) .\nFor injection attacks other than those targeting SQL or PHP, you can create [custom rules](/armor/docs/rules-language-reference#preconfigured-rules) to block requests when specific keywords or escape patterns in those protocols are used in the request path or query. Make sure that these patterns don't appear in valid requests. You can also limit these rules to only be used for specific endpoints or paths that might interpret data passed to them.\nAdditionally, some injection attacks can be mitigated by using the preconfigured rules for remote code execution and remote file injection.\n### Web Security Scanner\nUse case:\n- Monitoring for SQL injection\nWeb Security Scanner scans your web applications for vulnerabilities and provides detectors that monitor for [SQL injection](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#sql_injection) attacks.\n## A2: Broken authentication\n[Broken authentication](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication) is a common vulnerability because application authentication and session management are often implemented incorrectly. Attackers can exploit implementation flaws, such as compromised passwords, keys, and session tokens, in order to temporarily or permanently assume other users' identities.\n### Access Transparency\nUse case:\n- Service provider monitoring\n- Access justifications\nUsually, if you wanted hands-on support from external vendors, you had to grant and share temporary credentials, which creates the potential for orphaned or leaked credentials. Access Approval is an integrated service that lets you approve or dismiss requests for access by Google employees working to support your account. Each access request includes an access justification so you can view the reason for each access, including references to support tickets.\n### Apigee\nUse case:\n- Key validation\n- Token validation\n- OAuth policies\nApigee provides VerifyApiKey, OAuth, and JSON Web Token (JWT) policies, which help protect against this vulnerability.\n[API key validation](/apigee/docs/api-platform/tutorials/secure-calls-your-api-through-api-key-validation) is the simplest form of app-based security that can be configured for an API. A client application presents an API key with its request. Apigee Edge, through a policy attached to an API proxy, checks to see that the API key is in an approved state for the resource that is being requested.\n[OAuth 2.0](/apigee/docs/api-platform/reference/policies/oauthv2-policy) authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or on its own behalf by allowing the third-party application to obtain access.\n[JSON Web Tokens](/apigee/docs/api-platform/reference/policies/jwt-policies-overview) or JWT, are commonly used to share claims or assertions between connected applications. Apigee provides JWT support using three policies.\n### Event Threat Detection\nUse case:\n- Brute force detection\n- IAM abuse detection\nEvent Threat Detection monitors your Cloud Logging stream and applies detection logic and proprietary threat intelligence at a granular level. When Event Threat Detection detects a threat, it writes a finding to Security Command Center and to Cloud Logging in the project of your choosing. The following [event types](/security-command-center/docs/concepts-event-threat-detection-overview#rules) are useful for identifying broken authentication:\n- Brute force SSH. Detect successful brute force of SSH on a host.\n- Anomalous grant. Detect privileges granted to Identity and Access Management (IAM) users outside of the Google Cloud organization.\n### Google Cloud Armor\nUse case:\n- Limit authentication endpoint access\n- Restrict unauthorized token use\nAttacks against vulnerabilities that are classified under the broken authentication risk are best mitigated on the application level or by other controls. However, Google Cloud Armor can help limit the attack surface or block known-attack vectors.\nFor example, if your application has a limited user base and those users come from a known set of IP addresses or countries, you can create a [security policy](/armor/docs/security-policy-overview) that limits access to your application to users from those IP address blocks or countries. This policy can help mitigate against automated scanning from endpoints outside of these areas.\nIf other security mechanisms detect that passwords, keys, or session tokens have been compromised, you can block access for requests that contain those parameters in a query string by using a [custom rule](/armor/docs/rules-language-reference) . You can programmatically update rules that you previously defined by using the [securityPolicy.patchRule](/compute/docs/reference/rest/v1/securityPolicies/patchRule) method. You might be able to identify potential stolen tokens by using anomaly detection mechanisms over [HTTP load balancing logs](/load-balancing/docs/https/https-logging-monitoring) . You can also detect potential adversaries by scanning for common passwords in those logs.\nYou can block common session fixation attacks by using the [preconfigured ModSecurity rule set for session fixation](/armor/docs/rule-tuning) . You can use the rule set by adding the predefined `evaluatePreconfiguredExpr('sessionfixation-stable')` rule to your security policy.\nIf your application includes password changes in the query string, you can also block the use of common passwords by using a [custom rule](/armor/docs/rules-language-reference) that matches the `request.query` attribute. However, such checks are much better implemented on the application side if possible.\n### Identity-Aware Proxy (IAP)\nUse case:\n- Centralized access control\n- Works with cloud and on-premises\n- Protect HTTP and TCP connections\n- Context-Aware Access\nIAP integrates with HTTP(S) load balancing so you can use identity and context to form a secure authentication and authorization wall around your application. Prevent broken authentication to your public-facing application by provisioning external users in [Identity Platform](/identity-platform) (more information in the following section).\nYou can also prevent broken authentication to administrative interfaces by protecting them with Identity-Aware Proxy and authenticating users provisioned with [Identity and Access Management](/iam) or [Cloud Identity](/identity) . Any attempt to access the tool results in a logged authentication attempt followed by an authorization check to ensure the authenticated user is allowed to access the requested resource.\n### Identity Platform\nUse case:\n- Authentication as a service\n- Multi-factor authentication\n- Enterprise SLA\n- Broad protocol support\n- Google account protection intelligence\nIdentity Platform is Google Cloud's customer identity and access management (CIAM) platform that helps provide secure authentication as a service with multi-protocol support by using SDKs and APIs. It offers multi-factor authentication, integration with third-party authentication services, and auditable activity tracking.\n### reCAPTCHA Enterprise\nUse case:\n- Automated login attempts\n- Content scraping\n- Credential stuffing\n- Fraudulent transactions\n- Account takeovers\n- Fake accounts\n- Money laundering\n[reCAPTCHA Enterprise](/recaptcha-enterprise) provides highly effective filtering against bots and other forms of automation and bulk traffic by scoring the risk level of access attempts. You can [tune your site-specific model with automated feedback](/recaptcha-enterprise/docs/annotate-assessment) . reCAPTCHA adapts future scores to fit your site.\n### Security Health Analytics\nUse case:\n- MFA/2FA enforcement\n- API key protection\n- API key rotation enforcement\nSecurity Command Center helps prevent broken authentication by monitoring for multi-factor authentication compliance and the health of your API keys. You can identify suspicious requests and [block them or flag them for special handling](https://docs.apigee.com/sense/taking-action-bots) .\n### Titan Security Keys\nUse case:\n- Phishing-resistant 2FA\n- Mobile and PC authentication\nTitan Security Keys use public key cryptography to verify a user's identity and the URL of the login page to help ensure that attackers can't access your account even if you are tricked into providing your username and password.\n### Web Security Scanner\nUse case:\n- Session identifier leaks\nWeb Security Scanner scans your web applications for vulnerabilities, such as [session ID leaks](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#session_id_leak) , which allow other parties to impersonate or uniquely identify a user.\n## A3: Sensitive data exposure\n[Sensitive data exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure) can happen due to a lack of encryption or weak encryption in transit, or accidentally exposed sensitive data. Attacks against those vulnerabilities are usually specific to the application and therefore, need a defense-in-depth approach to mitigate.\n### Apigee\nUse case:\n- Protect sensitive data\nUse one-way and two-way TLS to guard sensitive information at the protocol level.\nUse policies such as [Assign Message policy](/apigee/docs/api-platform/reference/policies/assign-message-policy) and [JavaScript policy](/apigee/docs/api-platform/reference/policies/javascript-policy) to remove sensitive data before it's returned to the client.\nUse standard [OAuth](/apigee/docs/api-platform/tutorials/secure-calls-your-api-through-oauth-20-client-credentials) techniques and consider adding HMAC, hash, state, nonce, PKCE, or other techniques to improve the level of authentication for each request.\n[Mask sensitive data](/apigee/docs/api-platform/security/data-masking) in the Edge Trace tool.\nEncrypt sensitive data at rest in [key value maps](/apigee/docs/api-platform/cache/key-value-maps) .\n### Cloud Asset Inventory\nUse case:\n- Search service\n- Access analyzer\nOne of the most common vectors for data exposure is orphaned or unauthorized IT infrastructure. You can identify servers that nobody is maintaining and buckets with over-broad sharing rules by [analyzing the cloud asset time series data](/asset-inventory/docs/overview) .\n[Set up real-time notifications](/asset-inventory/docs/monitoring-asset-changes) to alert you to unexpected provisioning of resources which might be improperly secured or unauthorized.\n### Cloud Data Loss Prevention API (part of Sensitive Data Protection)\nUse case:\n- Sensitive data discovery and classification\n- Automatic data masking\nCloud Data Loss Prevention API (DLP API) lets you scan for any potentially sensitive data stored in buckets or databases to prevent unintended information leakage. If disallowed data is identified, it can be [automatically flagged or redacted](/dlp/docs/classification-redaction) .\n### Cloud Key Management Service (Cloud KMS)\nUse case:\n- Secure cryptographic key management\nPrevent potential exposure of your cryptographic keys by using a managed and audited service. A cloud-hosted key management service that lets you manage symmetric and asymmetric cryptographic keys for your cloud services the same way that you do on-premises. You can [generate, use, rotate, and destroy](/kms/docs/key-rotation) AES256, RSA 2048, RSA 3072, RSA 4096, EC P256, and EC P384 cryptographic keys.\n### Cloud Load Balancing\nUse case:\n- Fine-grained SSL/TLS cipher control\nSSL policies can help prevent sensitive data exposure by giving you control over the SSL/TLS features and ciphers that are allowed in a load balancer. [Block unapproved or insecure ciphers](/load-balancing/docs/use-ssl-policies) as needed.\n### Google Cloud Armor\nUse case:\n- Filter known attack URLs\n- Restrict sensitive endpoint access\nIn general, sensitive data exposure should be stopped at the source, but because every attack is application specific, web application firewalls can only be used in a limited way to stop data exposure broadly. However, if your application can't be immediately patched, you can restrict access to vulnerable endpoints or request patterns by using [Google Cloud Armor custom rules](/armor/docs/rules-language-reference) .\nFor example, several [Juice Shop challenges about sensitive data exposure](https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html) can be exploited due to insecure directory traversal and [null byte injection attacks](http://projects.webappsec.org/w/page/13246949/Null%20Byte%20Injection) . You can mitigate these injections by checking for the strings in the URL with the following custom expression:\n```\nrequest.path.contains(\"%00\") || request.path.contains(\"%2500\")\n```\nYou can [solve](https://pwning.owasp-juice.shop/appendix/solutions.html#find-the-endpoint-that-serves-usage-data-to-be-scraped-by-a-popular-monitoring-system) the [exposed metrics](https://pwning.owasp-juice.shop/part2/sensitive-data-exposure.html#find-the-endpoint-that-serves-usage-data-to-be-scraped-by-a-popular-monitoring-system) challenge by accessing the `/metrics` subdirectory that is used by Prometheus. If you have a sensitive endpoint like this exposed and can't immediately remove access, you can restrict access to it except for certain IP address ranges. Use a rule similar to the following custom expression:\n```\nrequest.path.contains(\"/metrics\") && !(inIpRange(origin.ip, '1.2.3.4/32')\n```\nReplace `` with the IP address range that should have access to the metrics interface.\n[Accidentally exposed log files](https://pwning.owasp-juice.shop/appendix/solutions.html#gain-access-to-any-access-log-file-of-the-server) are used to solve one of the Juice Shop challenges. To avoid exposing logs, set a rule disallowing access to log files completely: `request.path.endsWith(\".log\")` .\n### Identity-Aware Proxy and Context-Aware Access\nUse case:\n- Secure remote access to sensitive services\n- Centralized access control\n- Context-Aware Access\nUse identity and context to form a secure authentication and authorization perimeter around your application. Deploy tools, such as internal bug reporting, corporate knowledge base, or email behind IAP, in order to allow Context-Aware Access to only authorized individuals from anywhere on the internet.\nWith Context-Aware Access, you can [enforce granular access controls to web applications](/iap/docs/cloud-iap-context-aware-access-howto) , virtual machines (VMs), Google Cloud APIs, and Google Workspace applications based on a user's identity and context of the request without a traditional VPN. Based on the zero-trust security model and Google's BeyondCorp implementation, Context-Aware Access lets you provide access for your users, enforce granular controls, and use a single platform for both your cloud and on-premises applications and infrastructure resources.\n### Secret Manager\nUse case:\n- Crypto keys\n- API keys\n- Other system credentials\nSecret Manager is a secure storage service for your most valuable data such as API keys, service account passwords, and cryptographic assets. [Centrally storing these secrets](/secret-manager/docs/overview) lets you rely on Google Cloud's authentication and authorization systems, including IAM, to determine whether any given request for access is valid.\nSecret Manager isn't designed for massive scale operations such as credit card tokenization or individual user password storage. Such applications should rely on Identity Platform for CIAM, Cloud Identity for members of your organization, or [dedicated tokenization software](/solutions/tokenizing-sensitive-cardholder-data-for-pci-dss) .\n### Security Health Analytics\nUse case:\n- MFA/2FA enforcement\n- API key protection\n- API key rotation enforcement\n- Compute image privacy\n- SSH key rule enforcement\n- Secure boot monitoring\n- API access security\n- SSL policy monitoring\n- Disabled logging\n- Public bucket ACL alerts\nPrevent sensitive data exposure by monitoring for [multi-factor authentication compliance](/security-command-center/docs/concepts-vulnerabilities-findings#mfa-findings) and the [health of your API keys](/security-command-center/docs/concepts-vulnerabilities-findings#api-findings) . [Get alerts](/security-command-center/docs/how-to-enable-real-time-notifications) for insecure configurations in container image storage, Cloud Storage, SSL policy, SSH key policy, logging, API access, and more.\n### VirusTotal\nUse case:\n- Phishing prevention\nVirusTotal lets you [scan URLs for malicious content](https://developers.virustotal.com/reference#url-report) before presenting them to your users or employees, whether they're found in user input, emails, chat, logs, or other locations.\n### VPC Service Controls\nUse case:\n- Firewall for managed services\n[Wrap critically managed services in a firewall](/vpc-service-controls/docs/overview) in order to control who can call the service and who the service can respond to. Block unauthorized egress and data exfiltration with [outbound perimeter rules on services such as Cloud Functions](/functions/docs/securing/using-vpc-service-controls) . Prevent requests from unauthorized users and locations to [managed data stores and databases](/vpc-service-controls/docs/supported-products) . Create [secure perimeters around powerful or potentially costly APIs](/vpc-service-controls/docs/vpc-accessible-services) .\n### Web Application Scanner\nUse case:\n- Web application security risk scanner\n- Source repository availability scanner\nTo prevent your web application from exposing sensitive data, ensure that [passwords are not sent in clear text](/security-command-center/docs/concepts-web-security-scanner-overview#scan_findings) . Avoid leaking potentially devastating raw source code by [checking for exposed git and Apache Subversion source code repositories](/security-command-center/docs/concepts-web-security-scanner-overview#scan_findings) . These scans are [designed to cover specific OWASP top 10 controls](/security-command-center/docs/concepts-web-security-scanner-overview#scan_findings) .\n### Web Security Scanner\nUse case:\n- Unencrypted passwords transmitted over the network\n- Security vulnerabilities identified\nWeb Security Scanner scans your web applications and reports findings of errors and vulnerabilities. It follows links and attempts to exercise as many user inputs and event handlers as possible.\nIf your application transmits passwords in clear text, Web Security Scanner generates a [CLEAR_TEXT_PASSWORD](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#clear_text_password) finding. If passwords entered on the web application can be cached in a regular browser cache instead of a secure password storage, Web Security Scanner generates a [CACHEABLE_PASSWORD_INPUT](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#cacheable_password_input) finding.\n## A4: XML external entities (XXE)\nAttacks against [XML external entities](https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)) exploit vulnerabilities in XML processors when referencing external entities. You can mitigate these attacks by avoiding using XML data transfers from and to external clients and disabling processing of XXE in XML parsers.\nThis concept is broadened here to include non-XML documents and configurations that can reference or include external entities\u2014for example, a JSON configuration with an external schema reference or a container configuration pulling in external libraries or binaries not bundled in the image.\n### Apigee\nUse case:\n- Block XXE attacks by using LFI/RFI (local file inclusion, remote file inclusion)\nApigee has a built-in XML parser that uses XPath to extract data. It has an [XMLThreatProtection policy](/apigee/docs/api-platform/reference/policies/xml-threat-protection-policy) to guard against malicious XML payloads.\nThe Apigee [ExtractVariables policy](/apigee/docs/api-platform/reference/policies/extract-variables-policy) lets you extract the content from a request or response and assign that content to a variable. You can extract any part of the message, including headers, URI paths, JSON/XML payloads, form parameters, and query parameters. The policy works by applying a text pattern to the message content and when it finds a match, sets a variable with the specified message content.\n### Google Cloud Armor\nUse case:\n- Filter XXE attacks by using LFI/RFI (local file inclusion, remote file inclusion)\nBecause XXEs can be complex and come in different forms, the mitigation possibilities by web application firewalls are limited. Attacks are better mitigated by patching XML parsers, disallowing external entities, and limiting XML data transfers on public web servers to a minimum. However, depending on the application and type of attack, Google Cloud Armor can still help defend against data exfiltration and other impacts.\nAlthough no rules in the [OWASP ModeSecurity Core Rule Set](https://owasp.org/www-project-modsecurity-core-rule-set/) specifically defend against XXE attacks, the [local file inclusion (LFI) and remote file inclusion (RFI) rules](/armor/docs/rule-tuning) can help against some of these attacks. For example, the [Juice Shop XXE data access challenge](https://pwning.owasp-juice.shop/part2/xxe.html#retrieve-the-content-of-cwindowssystemini-or-etcpasswd-from-the-server) requires that the attacker retrieve local files on the server. The [solution of this challenge](https://pwning.owasp-juice.shop/appendix/solutions.html#retrieve-the-content-of-cwindowssystemini-or-etcpasswd-from-the-server) stops working if you use the `evaluatePreconfiguredExpr('lfi-stable')` rule [in a Google Cloud Armor Security policy](/armor/docs/configure-security-policies) .\n### Web Security Scanner\nUse case:\n- XML external entity (XXE)\nWeb Security Scanner monitors for vulnerabilities, like [XXE vulnerabilities](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#xxe_reflected_file_leakage) .\nFor more information, see [Overview of Web Security Scanner](/security-command-center/docs/concepts-web-security-scanner-overview) .\n## A5: Broken access control\n[Broken access control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html) refers to access controls that are only partially enforced on the client side, or weakly implemented. Mitigating these controls often requires a rewrite on the application side to properly enforce that resources are accessed only by authorized users.\n### Apigee\nUse case:\n- Access control enforcement\n- Limit data manipulation\nApigee supports a layered approach to implement access controls to keep the bad actors from making unauthorized changes or accessing the system.\n[Configure role-based access control (RBAC)](https://docs.apigee.com/api-platform/system-administration/understanding-roles) to only allow users access to the functionality and configuration that they need. [Create encrypted key value maps](/apigee/docs/api-platform/cache/key-value-maps) to store sensitive key/value pairs, which appear masked in the Edge UI and in management API calls. [Configure single sign-on](https://docs.apigee.com/api-platform/system-administration/enabling-saml-authentication-edge) with your company's identity provider.\n[Configure developer portals](/apigee/docs/api-platform/publish/portal/portal-interact) to show specific API products according to user role. Configure the portal to show or hide content based on user role.\n### Cloud Asset Inventory\nUse case:\n- Monitor for shadow IT\n- Outdated compute instances\nOne of the most common vectors for data exposure is orphaned or unauthorized IT infrastructure. [Set up real-time notifications](/asset-inventory/docs/monitoring-asset-changes) to alert you for unexpected running resources, which might be improperly secured or using outdated software.\n### Cloud Load Balancing\nUse case:\n- Fine-grained SSL/TLS cipher control\nPrevent the use of weak SSL/TLS ciphers by [assigning a predefined group or custom list of ciphers](/load-balancing/docs/use-ssl-policies) that Cloud Load Balancing can use.\n### Forseti Scanner\nUse case:\n- Access control configuration monitoring\nSystematically monitor your Google Cloud resources with the goal of ensuring access controls are set as you intended. [Create rule-based policies](https://forsetisecurity.org/docs/v2.23/configure/scanner/rules.html) to codify your security stance. If the configuration unexpectedly changes, Forseti Scanner notifies you so that you can automatically revert to a known state.\n### Google Cloud Armor\nUse case:\n- Filter cross-origin requests\n- Filter local/remote file inclusion attacks\n- Filter HTTP parameter pollution attacks\nMany cases of broken access control cannot be mitigated by using a web application firewall, because applications don't require or don't properly check access tokens for every request, and data can be manipulated client side. Multiple [Juice Shop challenges related to broken access control](https://pwning.owasp-juice.shop/part2/broken-access-control.html) \u2014for example, [posting feedback in another user's name](https://pwning.owasp-juice.shop/part2/broken-access-control.html#post-some-feedback-in-another-users-name) \u2014use the fact that some requests are not authenticated server side. As you can see in the [challenge solution](https://pwning.owasp-juice.shop/appendix/solutions.html#post-some-feedback-in-another-users-name) , the exploit for this vulnerability is completely client-side and can therefore not be mitigated using Google Cloud Armor.\nSome challenges can be partially mitigated server side if the application cannot be immediately patched.\nFor example, if [cross-site request forgery (CSRF) attacks](https://owasp.org/www-community/attacks/csrf) are possible because your web server [implements cross-origin resource sharing (CORS) poorly](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties) , as demonstrated in the [CSRF Juice Shop challenge](https://pwning.owasp-juice.shop/part2/broken-access-control.html#change-the-name-of-a-user-by-performing-cross-site-request-forgery-from-another-origin) , you can mitigate this by blocking requests from unexpected origins altogether with a custom rule. The following rule matches all requests with origins other than example.com and google.com:\n```\nhas(request.headers['origin']) &&!((request.headers['origin'] == 'https://example.com')||(request.headers['origin'] == 'https://google.com') )\n```\nWhen traffic that matches such a rule is denied, the [solution for the CSRF challenge](https://pwning.owasp-juice.shop/appendix/solutions.html#change-the-name-of-a-user-by-performing-cross-site-request-forgery-from-another-origin) stops working.\nIn the case of [server-side request forgery (SSRF) attacks](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery) , such as the [SSRF Juice Shop challenge](https://pwning.owasp-juice.shop/part2/broken-access-control.html#request-a-hidden-resource-on-server-through-server) , using the preconfigured remote file inclusion (RFI) or local file inclusion (LFI) rule sets can help mitigate some of these attacks because they block inclusion of URLs or path traversal. For example, the following rule enables both rule sets:\n```\nevaluatePreconfiguredExpr('lfi-stable') ||evaluatePreconfiguredExpr('rfi-stable')\n```\nWhen such a rule is implemented, the [solution for the SSRF challenge](https://pwning.owasp-juice.shop/appendix/solutions.html#request-a-hidden-resource-on-server-through-server) also stops working.\nThe [basket manipulation challenge](https://pwning.owasp-juice.shop/part2/broken-access-control.html#put-an-additional-product-into-another-users-shopping-basket) uses [HTTP parameter pollution](https://en.wikipedia.org/wiki/HTTP_parameter_pollution) as you can see when following how to attack the shop by following the [challenge solution](https://pwning.owasp-juice.shop/appendix/solutions.html#put-an-additional-product-into-another-users-shopping-basket) . Parameter pollution is detected as part of the protocol attack rule set. To help block this kind of attack, use the following rule: `evaluatePreconfiguredExpr('protocolattack-stable')` .\n### Identity-Aware Proxy and Context-Aware Access\nUse case:\n- Centralized access control\n- Works with cloud and on-premises\n- Protects HTTP and TCP connections\n- Context-Aware Access\nIAP lets you use identity and context to [form a secure authentication and authorization wall around your application](/iap/docs/how-to) . Prevent broken authorization or access control to your public-facing application with a centrally managed authentication and authorization system [built on Cloud Identity and IAM](/iap/docs/managing-access) .\nEnforce [granular access controls](/iap/docs/cloud-iap-context-aware-access-howto) to web applications, VMs, Google Cloud APIs, and Google Workspace applications based on a user's identity and context of the request without the need for a traditional VPN. Use a single platform for both your cloud and [on-premises applications and infrastructure resources](/iap/docs/signed-headers-howto) .\n### Security Health Analytics\nUse case:\n- MFA/2FA enforcement\n- API key protection\n- SSL policy monitoring\nPrevent broken access control by monitoring for multi-factor authentication compliance, SSL policy, and the health of your API keys.\n### Web Security Scanner\nUse case:\n- Repositories exposed to the public\n- Insecure request header validation\nWeb Security Scanner scans your web applications for vulnerabilities, such as [publicly visible code repositories](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#accessible_repository) and [misconfigured validation of requestheaders](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#insecure_allow_origin_ends_with_validation) .\n## A6: Security misconfiguration\n[Security misconfiguration](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html) refers to unpatched application flaws, open default accounts, and unprotected files and directories that can typically be prevented with application hardening. Security misconfiguration can happen in many ways, such as trusting default configurations, making partial configurations that might be insecure, letting error messages contain sensitive details, storing data in the cloud without proper security controls, or misconfiguring HTTP headers.\n### Apigee\nUse case:\n- Manage security configurations\n- Monitor security configurations\nA [shared flow](/apigee/docs/api-platform/fundamentals/shared-flows) lets API developers combine policies and resources into a reusable group. By capturing reusable functionality in one place, a shared flow helps you ensure consistency, shorten development time, and more easily manage code. You can include a shared flow inside individual API proxies using a [FlowCallout policy](/apigee/docs/api-platform/reference/policies/flow-callout-policy) or you can place shared flows in [flow hooks](/apigee/docs/api-platform/fundamentals/flow-hooks) to automatically run shared flow logic for every API proxy deployed in the same environment.\n### Cloud Asset Inventory\nUse case:\n- Real-time notification service\n[Real-time notifications](/asset-inventory/docs/monitoring-asset-changes) can alert you to unexpected provisioning of resources that might be improperly secured or unauthorized.\n### Cloud Load Balancing\nUse case:\n- Fine-grained SSL/TLS cipher control\nPrevent the usage of known-vulnerable SSL/TLS ciphers by [assigning a predefined group or custom list of ciphers](/load-balancing/docs/use-ssl-policies) usable by a load balancer.\n### Google Cloud Armor\nUse case:\n- Filter insecure endpoints\n- Filter local/remote file inclusion attacks\n- Filter protocol attacks\nBecause security misconfiguration can happen at the application level, the OWASP Foundation recommends hardening and patching your application directly and removing all unnecessary functionality.\nAlthough a web application firewall (WAF), such as Google Cloud Armor, can't help you fix the underlying misconfiguration, you can block access to parts of the application either fully or for everyone except specific IP addresses or countries. Restricting access can reduce the risk of those misconfigurations being exploited.\nFor example, if your application exposes an administrative interface using a common URL such as `/admin` , you can restrict access to this interface even if it is authenticated. You can do this with a deny rule\u2014for example:\n```\nrequest.path.contains(\"/admin\") && !(inIpRange(origin.ip,\n'1.2.3.4/32')\n```\nReplace `` with the IP address range that should have access to the admin interface.\nSome misconfigurations can be partially mitigated by using the predefined local file inclusion (LFI) or remote file inclusion (RFI) rulesets. For example, exploiting the Juice Shop [cross-site imaging](https://pwning.owasp-juice.shop/part2/security-misconfiguration.html#stick-cute-cross-domain-kittens-all-over-our-delivery-boxes) challenge doesn't succeed when the LFI ruleset is applied. Use the `evaluatePreconfiguredExpr('lfi-stable') || evaluatePreconfiguredExpr('rfi-stable')` rule to block requests using the LFI and RFI rule sets and [tune the rules](/armor/docs/rule-tuning) as necessary. You can verify that the [challenge solution](https://pwning.owasp-juice.shop/appendix/solutions.html#stick-cute-cross-domain-kittens-all-over-our-delivery-boxes) no longer succeeds.\n**    Preview    \u2014 preconfigured rule sets for method enforcement ** This feature is subject to the \"Pre-GA Offerings Terms\" in the General Service Terms section   of the [Service Specific Terms](/terms/service-terms#1) .     Pre-GA features are available \"as is\" and might have limited support.    For more information, see the [launch stage descriptions](/products#product-launch-stages) .\nSome HTTP attacks can also be mitigated using preconfigured rulesets:\n- To avoid [HTTP verb tampering](https://capec.mitre.org/data/definitions/274.html) , use the method enforcement rule set (in preview). Use the`evaluatePreconfiguredExpr('methodenforcement-stable')`rule to disallow HTTP request methods other than the`GET`,`HEAD`,`POST`, and`OPTIONS`methods\n- To block common attacks against HTTP parsing and proxies, such as [HTTP Request Smuggling](https://wikipedia.org/wiki/HTTP_request_smuggling) , [HTTP Response Splitting](https://wikipedia.org/wiki/HTTP_response_splitting) and [HTTP Header Injection](https://wikipedia.org/wiki/HTTP_header_injection) , use the protocol attack rule set by using the`evaluatePreconfiguredExpr('protocolattack-stable')`rule.\n### Security Health Analytics\nUse case:\n- Security control monitoring and alerting\nMonitor [dozens of signals](/security-command-center/docs/concepts-vulnerabilities-findings) through a single interface to ensure your application is maintaining security best practices.\n### Web Security Scanner\nUse case:\n- Web application scanner tailored for OWASP Top 10\n- HTTP server configuration\n- Mixed HTTP/HTTPS content\nWeb Security Scanner monitors for common security errors, such as content-type mismatches, invalid security headers, and mixed content serving. These scans are [designed to cover specific OWASP top 10 controls](/security-command-center/docs/concepts-web-security-scanner-overview#scan_findings) .\nThe following detectors scan for security misconfigurations:\n- `INVALID_CONTENT_TYPE`\n- `INVALID_HEADER`\n- `MISMATCHING_SECURITY_HEADER_VALUES`\n- `MISSPELLED_SECURITY_HEADER_NAME`\n- `MIXED_CONTENT`\nFor more information on these and other detectors, see [Overview of Web Security Scanner](/security-command-center/docs/concepts-web-security-scanner-overview) .\n## A7: Cross-site scripting (XSS)\n[Cross-site scripting (XSS)](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html) lets attackers run scripts in user web browsers to control user sessions, manipulate web sites, or maliciously impact users in other ways.\n### Apigee\nUse case:\n- XSS detection\nApigee provides threat protection policies that can guard against XSS in the API.\n[Cross-origin resource sharing (CORS)](https://wikipedia.org/wiki/Cross-origin_resource_sharing) is one of the common implementations of the [same-origin policy](https://wikipedia.org/wiki/Same-origin_policy) that is enforced by all browsers. You [can implement CORS](/apigee/docs/api-platform/develop/adding-cors-support-api-proxy) by using the [AssignMessage policy](/apigee/docs/api-platform/reference/policies/assign-message-policy) . Using regular expressions, either with the [RegularExpressionProtection policy](/apigee/docs/api-platform/reference/policies/regular-expression-protection) or [JavaScript policy](/apigee/docs/api-platform/reference/policies/javascript-policy) check payload and parameter values for JavaScript and other injection-type attacks.\n### Google Cloud Armor\nUse case:\n- Filter XSS patterns\n- Filter protocol attacks\nYou can block common XSS attacks by using the predefined rule set for XSS attacks. You can insert the `evaluatePreconfiguredExpr('xss-stable')` rule either by itself or combine it with other expressions using the [custom rules language](/armor/docs/rules-language-reference) . Make sure you follow the guidance for [troubleshooting false positives](/armor/docs/troubleshooting#false-positives) and to [tune the rule set to different sensitivity levels](/armor/docs/rule-tuning) .\nUsing this predefined rule set can block the majority of XSS attacks defined through the [XSS challenges in the OWASP Juice Shop](https://pwning.owasp-juice.shop/part2/xss.html) \u2014for example, the [API-only XSS challenge](https://pwning.owasp-juice.shop/part2/xss.html#perform-a-persisted-xss-attack-without-using-the-frontend-application-at-all) that uses XSS payload inside the `POST` body of HTTP requests.\nHowever, you can't block all XSS attacks this way. Some XSS attacks only use client-side functionality\u2014for example the [DOM XSS challenge](https://pwning.owasp-juice.shop/part2/xss.html#perform-a-dom-xss-attack) . As you can see in the [challenge solution for the DOM XSS challenge](https://pwning.owasp-juice.shop/appendix/solutions.html#perform-a-dom-xss-attack) , there is no server interaction required for the attack to succeed. These kinds of attacks cannot be mitigated with any web application firewall (WAF) because no server-side calls are involved. Instead, you must patch the client-side application.\nA few other attacks can't be mitigated with the predefined Google Cloud Armor rule set because they aren't caught by the underlying [OWASP Modsecurity core rule set](https://modsecurity.org/crs/) . These are uncommon attacks\u2014for example, the [reflected XSS challenge](https://pwning.owasp-juice.shop/part2/xss.html#perform-a-reflected-xss-attack) requires you to attack the application with queries that have the XSS payload in the URL path and not the query or the `POST` body as detailed in the [challenge solution for the reflected XSS challenge](https://pwning.owasp-juice.shop/appendix/solutions.html#perform-a-reflected-xss-attack) . Having the URL path parsed unreflected is not a typical vulnerability. The [HTTP header XSS challenge](https://pwning.owasp-juice.shop/part2/xss.html#perform-a-persisted-xss-attack-through-an-http-header) requires you to send the XSS payload in a proprietary HTTP header as described in the [HTTP header XSS challenge solution](https://pwning.owasp-juice.shop/appendix/solutions.html#perform-a-persisted-xss-attack-through-an-http-header) . If you are aware of vulnerabilities in your application, these kinds of attacks can potentially be mitigated with Google Cloud Armor [custom rules](/armor/docs/rules-language-reference) .\nSome XSS attacks are also enabled by misconfigurations of the underlying HTTP server, such as [HTTP response splitting](https://wikipedia.org/wiki/HTTP_response_splitting) and [HTTP header injection](https://wikipedia.org/wiki/HTTP_header_injection) attacks. You can use the protocol attack rule set by using the `evaluatePreconfiguredExpr('protocolattack-stable')` rule to block attacks detected by this rule set.\n### Security Command Center Web Application Scanner\nUse case:\n- XSS detection\n[Monitor for common security errors](/security-command-center/docs/concepts-web-security-scanner-overview) such as XSS vulnerabilities and specific AngularJS misconfigurations.\n### Web Security Scanner\nUse case:\n- Monitoring for cross-site scripting\nWeb Security Scanner scans your web applications for vulnerabilities and provides detectors that monitor for [cross-site scripting](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#xss) attacks.\n## A8: Insecure deserialization\nAttackers can use [flaws in deserialization](https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization.html) for different types of attacks, such as replay, privilege escalation, and injection. Insecure deserialization can also enable remote code execution (RCE).\n### Google Cloud Armor\nUse case:\n- Block remote code execution\nBecause most attacks against insecure deserialization are application specific, there are only a few ways to help mitigate these attacks\u2014for example, using a web application firewall (WAF) like Google Cloud Armor. OWASP recommends that you don't accept serialized objects from untrusted sources. If possible, you can restrict endpoints accepting those objects to a set of trusted IP addresses with a deny rule similar to the following:\n```\nrequest.path.contains(\"/endpoint\") && !(inIpRange(origin.ip,\n'1.2.3.4/32')\n```\nReplace the following:\n- ``: the path of the endpoint accepting serialized objects\n- ``: the IP address range that should keep access to the interface.\nTo mitigate typical attacks against insecure deserialization that use remote code execution (RCE), use the predefined rule set against RCE attacks. You can use the `evaluatePreconfiguredExpr('rce-stable')` rule to block common RCE attacks against UNIX and Windows Shells.\nThe RCE attacks described in the [Juice Shop challenges for insecure deserializations](https://pwning.owasp-juice.shop/part2/insecure-deserialization.html) run functions and regular expressions in Node.js on the server. These kinds of attacks are not blocked by the predefined RCE rule set and the corresponding OWASP Modsecurity rule and have to be mitigated by using patches on the server side or [custom rules](/armor/docs/rules-language-reference) .\n### VirusTotal\nUse case:\n- Untrusted data scanning\nVirusTotal's API lets you upload and scan files for malware. You can scan [images, documents, binaries, and other untrusted data](https://support.virustotal.com/hc/en-us/articles/115002075969-What-kind-of-files-will-VirusTotal-scan-) before it is processed to eliminate certain categories of malicious input.\n### Web Security Scanner\nUse case:\n- Insecure deserialization\nWeb Security Scanner scans your web applications for vulnerabilities. For example, if you're using an [Apache Struts](https://struts.apache.org/) version that makes your application vulnerable to remote command injection attacks, Web Security Scanner generates a [STRUTS_INSECURE_DESERIALIZATION finding](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#struts_insecure_deserialization) .\n## A9: Using components with known vulnerabilities\n[Components with known vulnerabilities](https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities.html) is a category for generic attack vectors, and such vulnerabilities are best mitigated by monitoring and quickly upgrading all of your application components.\n### Binary Authorization\nUse case:\n- Restrict GKE clusters to trusted containers\nBinary Authorization is a deploy-time security control that helps ensure that only trusted container images are deployed on Google Kubernetes Engine (GKE). With Binary Authorization, you can require that images are signed by trusted authorities during the development process and then enforce signature validation when deploying. By enforcing validation, you can be assured that your build-and-release process uses only verified images.\n### Cloud Load Balancing\nUse case:\n- Fine-grained SSL/TLS cipher control\nPrevent the use of known-vulnerable SSL/TLS ciphers by assigning a predefined group or custom list of ciphers that Cloud Load Balancing can use.\n### Container Threat Detection\nUse case:\n- Malicious script detection\n- Reverse shell detection\n- Malware installation detection\nIf an attacker exploits a vulnerable component and runs a malicious script, the [Malicious Script Executed](/security-command-center/docs/how-to-investigate-threats#malicious_script_executed) detector of [Container Threat Detection](/security-command-center/docs/concepts-container-threat-detection-overview) generates a finding. If an attacker spawns a reverse shell, the [Reverse Shell](/security-command-center/docs/how-to-investigate-threats#reverse_shell) detector generates a finding. If an attacker installs malware, the [Added Binary Executed](/security-command-center/docs/how-to-investigate-threats#added_binary_executed) and [Added Library Loaded](/security-command-center/docs/how-to-investigate-threats#added_library_loaded) detectors generate findings.\n### Event Threat Detection\nUse case:\n- Cryptomining detection\n- Malware detection\n- Data exfiltration\n- Outgoing DoS\nEvent Threat Detection monitors your Cloud Logging stream and applies detection logic and threat intelligence at a granular level. When Event Threat Detection detects a threat, it writes a finding to Security Command Center and to a Cloud Logging project. The following detection rules are useful for [detecting the effects of using components with known vulnerabilities](/security-command-center/docs/how-to-use-event-threat-detection) :\n- Cryptomining. Detect cryptomining based on DNS requests or connection to known mining addresses.\n- Malware. Detect malware-based DNS requests or connection to known bad addresses.\n- Exfiltration to external table. Detect resources that are saved outside the organization, including copy or transfer operations.\n- Outgoing DoS. Detect exploited vulnerabilities attempting denial of service attacks.\n### Google Cloud Armor\nUse case:\n- Block access to unused application endpoints\n- Block common attack vectors\nA web application firewall (WAF) like Google Cloud Armor shouldn't be used as a single mitigation strategy to block attacks against this category, because attacks are often library specific and cannot be blocked by preconfigured rule sets or cannot be patched server side. Regularly monitoring and upgrading all components of your application is the only option to mitigate these kind of vulnerabilities.\nHowever, Google Cloud Armor can help mitigate some common attacks against vulnerable applications through its [preconfigured rules](/armor/docs/rules-language-reference#preconfigured-rules) for remote code execution, local file inclusion, or remote file inclusion.\nIf you're aware of vulnerable components in your application but can't patch the application immediately, you can block access to these parts of your application to temporarily lower the risk of an exploit of these components. Build a custom rule that matches either the URL path or queries that access these vulnerable components and deny access. If you require access to these components from specific users or locations, you can still allow certain trusted source IP addresses to access these components. A rule using the URL path looks similar to the following:\n```\n`request.path.contains(\"/component\") && !(inIpRange(origin.ip,\n'1.2.3.4/32')\n```\nReplace the following:\n- ``: the path of the component with known vulnerabilities\n- ``: the IP address range that should keep access to the interface.\nIf there are parts of your application\u2014for example, certain directories or file types that never need to be accessed by end users\u2014you can also block or [restrict access to these resources with a custom rule](/armor/docs/rules-language-reference) , proactively mitigating the risk if these components become vulnerable in the future.\n### Google Cloud Security Bulletins\nUse case:\n- Security bulletin monitoring\n- CVEs for Google Cloud products\n[Google Cloud Security Bulletins](/support/bulletins) are an authoritative source for security bulletins that impact Google Cloud. Posts include background information, CVE links, and recommendations for further action.\n### Web Security Scanner\nUse case:\n- Outdated libraries\n- Vulnerabilities and findings dashboards\nMonitor for [outdated libraries](/security-command-center/docs/how-to-remediate-web-security-scanner-findings#outdated_library) included in your web application. [Monitor these findings in the Security Command Center dashboard](/security-command-center/docs/how-to-use-web-security-scanner) .\n## A10: Insufficient logging and monitoring\nIf you [don't adequately log, monitor, or manage incidents](https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring.html) in your systems, attackers can perform deeper and more prolonged attacks on data and software.\n### Access Transparency\nUse case:\n- Service provider access monitoring and auditing\n- Access justifications\n- Resource and method identification\nInability to audit cloud provider access can be a barrier to migrate from on-premises to cloud. Access Transparency enables verification of cloud provider access, bringing your audit controls closer to on-premises conditions. You can record the reason for each access, including references to relevant support tickets. Resource and method identification names which resources are accessed and which methods were run by which administrator. Access Approval lets you approve or dismiss requests for access by Google employees who are working to support your service.\n### Apigee\nUse case:\n- Export Apigee logs to SIEM\n- Use Apigee monitoring UI\n- Follow monitoring best practices\nApigee has several ways to perform logging, monitoring, error handling, and audit logging:\n- Logging- Log messages can be sent to Splunk or other syslog endpoints using the [MessageLogging policy](/apigee/docs/api-platform/reference/policies/message-logging-policy) .\n- API analytics data can be pulled through the [analytics API](https://docs.apigee.com/api-platform/analytics/use-analytics-api-measure-api-program-performance) and imported or [exported](/apigee/docs/api-platform/analytics/export-data) into other systems.\n- In Edge for Private Cloud, you can use the MessageLogging policy to write to local log files. Log files from each of the running components are available as well.\n- The [JavaScript policy](/apigee/docs/api-platform/reference/policies/javascript-policy) can be used to send log messages to a REST logging endpoint synchronously or asynchronously.\n- Monitoring- Use the [API Monitoring](/apigee/docs/api-monitoring) UI or API to regularly monitor APIs and backends and trigger alerts.\n- Use [health monitoring](/apigee/docs/api-platform/deploy/load-balancing-across-backend-servers#healthmonitoring) to regularly monitor target server backends.\n- Apigee provides [recommendations](https://docs.apigee.com/private-cloud/latest/what-monitor) for monitoring Edge for Private Cloud.\n- Apigee also provides [best practices](https://www.googlecloudcommunity.com/gc/Cloud-Product-Articles/Forming-an-API-Monitoring-Strategy-Where-to-Start/ta-p/78688) that your team can leverage for monitoring your API program.\n- Error handling- Apigee offers a powerful, versatile [fault handling mechanism](/apigee/docs/api-platform/fundamentals/fault-handling) for API proxies. Similar to how a Java program would catch exceptions, API proxies can catch faults and determine how to return appropriate responses to clients.\n- Apigee's custom fault handling lets you add functionality such as message logging whenever an error occurs.\n- Audit logs- The Apigee platform keeps an audit log that tracks changes to API proxies, products, and organization history.\n- This log is available [through the UI](https://docs.apigee.com/api-platform/debug/view-api-history) or through the [Management API](https://apidocs.apigee.com/api/audits-0) .\n### Chronicle Detect\nUse case:\n- Threat detection\n- Early warning\nSecurity teams can send their security telemetry to Chronicle so that you can apply [powerful detection rules](https://go.chronicle.security/hubfs/Chronicle%20Detect%20Datasheet%20.pdf) to a unified set of data.\n### Sensitive Data Protection (part of Sensitive Data Protection)\nUse case:\n- Automatic sensitive data masking\nIdentify compliance-sensitive information in your log streams and [mask or transform](/dlp/docs/transformations-reference) it appropriately before archiving it in logs. For example, an error message or core dump might contain sensitive information such as credit card numbers or personally identifiable information that needs to be masked.\n### Cloud Key Management Service (Cloud KMS)\nUse case:\n- Cryptographic key request event logging\n- Access justifications\n[Key Access Justifications](/blog/products/identity-security/control-access-to-gcp-data-with-key-access-justifications) give you historical visibility into every request for an encryption key by logging the stated justification and a record of approval or denial of that request.\n### Cloud Logging\nUse case:\n- Log aggregation\n- Log storage\n- Log search\n- Log analysis\nCloud Logging allows you to [store, search, analyze, monitor, and alert on logging data and events](/logging/docs/how-to) from Google Cloud and Amazon Web Services. It includes access to the BindPlane service, which you can use to collect logging data from over 150 common application components, on-premises systems, and hybrid cloud systems.\n### Cloud Monitoring\nUse case:\n- Log monitoring\n- Event alerting\nCloud Monitoring provides visibility into the performance, uptime, and overall health of cloud-powered applications. It provides a monitoring dashboard, event monitors, and alerting through multiple channels.\n### Cloud Source Repositories\nUse case:\n- Code change attribution\n- Access audit logging\nGet insights into what actions were performed on your repository, including where and when, with Cloud Audit Logs generated by Cloud Source Repositories.\n### Error Reporting\nUse case:\n- Capture internal application errors in Cloud Logging\n- Collect crash reports outside of the crashed compute instance\nInternal application errors can be an indicator of a security problem, broken functionality, or attempts to circumvent security. Error Reporting counts, analyzes, and aggregates the crashes in your running cloud services. A centralized error management interface displays the results with sorting and filtering capabilities. [A dedicated view](/error-reporting/docs/viewing-errors) shows the error details\u2014for example, time chart, occurrences, affected user count, first- and last-seen dates, and a cleaned exception stack trace. Opt-in to receive [email and mobile alerts](/error-reporting/docs/notifications) on new errors.\n### Event Threat Detection\nUse case:\n- Brute force\n- Cryptomining\n- IAM abuse\n- Malware\n- Phishing\nEvent Threat Detection monitors your Cloud Logging stream and applies detection logic and proprietary threat intelligence at a granular level. Event Threat Detection identifies notable entries in your logs and elevates them for review. When Event Threat Detection detects a threat, it writes a finding to Security Command Center and to a Cloud Logging project.\n### Forseti Inventory\nUse case:\n- Inventory change monitoring and alerting\nForseti Inventory saves an inventory snapshot of your Google Cloud resources to a database, so you have a historical record of your resources. With this information, you can understand all the resources you have in Google Cloud and take action to conserve resources, reduce cost, and minimize security exposure. [Inventory can be configured](https://forsetisecurity.org/docs/v2.23/use/cli/inventory.html) to run as often as you want, and send email notifications when it updates your resource snapshot.\n### Google Cloud Armor\nUse case:\n- Security policy logging\n- Monitoring dashboards\n- Alerting on traffic anomalies\nGoogle Cloud Armor request logs are part of [Cloud Logging for external Application Load Balancers](/load-balancing/docs/https/https-logging-monitoring) To have access to logging information\u2014such as which security policy rule matched traffic\u2014enable logging on all backend services that have attached security policies. Use rules in [preview mode](/armor/docs/security-policy-overview#preview_mode) to test them and log results without enforcing the effects.\nGoogle Cloud Armor also offers [monitoring dashboards](/armor/docs/monitoring) for security policies that let you get an overview of the amount of traffic that passed or was denied by any of your security policies. Google Cloud Armor publishes [findings about traffic anomalies](/armor/docs/cscc-findings) , such as spikes in allowed traffic or increased denied traffic, in Security Command Center.\nGoogle Cloud Armor automatically writes [Admin Activity audit logs](/armor/docs/audit-logging) , which record operations that modify the configuration or metadata of a resource. This service can also be configured to [write Data Access audit logs](/armor/docs/audit-logging) which contain API calls that read the configuration or metadata of resources, as well as user-driven API calls that create, modify, or read user-provided resource data.\n### Identity Platform\nUse case:\n- Admin activity audit logs\n- Data access audit logs\n- System event audit logs\n- Policy denied audit logs\n- Authentication activity logs\nIdentity Platform is Google Cloud's user-facing identity and access management platform that logs authentication activity by default.\n[Enable several powerful audit logs](/identity-platform/docs/audit-logging) including admin activity, data access, system events, and denied authentication attempts.\n### Security Command Center\nUse case:\n- Alert monitoring\n- Threat management\n- Vulnerability scan reporting\n- Compliance monitoring\n- Asset monitoring\n- Security scan findings\nView the total number of findings in your organization by severity level in the overview panel. Use the threats dashboard to review potentially harmful events in your organization's Google Cloud resources. View Security Health Analytics findings and recommendations in the vulnerabilities tab.\nWith the compliance dashboard, you can continuously monitor compliance with controls from PCI-DSS, CIS Google Cloud Computing Foundations Benchmark, and more. The Assets view provides a detailed display of all Google Cloud resources, called , in your organization. The assets tab lets you view assets for your entire organization or you can filter assets within a specific project, by asset type, or by change type. Finally, the findings tab displays a detailed findings inventory for all your organization assets so you can view potential security risks.\n## What's next\n- [Web application and API protection on Google Cloud](/solutions/web-app-and-api-protection) \n- [OWASP Top 10](https://owasp.org/www-project-top-ten/2017/) \n- [Google Cloud security bulletins](/support/bulletins) \n- [Google Cloud security best practices center](/security/best-practices) \n- [Compliance offerings](/security/compliance/offerings) \n- [CIS benchmark for Google Cloud](https://www.cisecurity.org/blog/new-cis-benchmark-for-google-cloud-computing-platform/) \n- [Security Command Center](/security-command-center) \n- [Apigee](/apigee) \n- [Google Cloud Armor](/armor) \n- [All Google Cloud security products](/security/products) \n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Cloud Architecture Center"}