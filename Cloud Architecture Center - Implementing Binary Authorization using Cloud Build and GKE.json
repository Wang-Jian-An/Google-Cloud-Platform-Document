{"title": "Cloud Architecture Center - Implementing Binary Authorization using Cloud Build and GKE", "url": "https://cloud.google.com/architecture/reference-patterns/overview", "abstract": "# Cloud Architecture Center - Implementing Binary Authorization using Cloud Build and GKE\nThis tutorial shows you how to set up, configure, and use [Binary Authorization](/binary-authorization) for [Google Kubernetes Engine](/kubernetes-engine) (GKE). Binary authorization is the process of creating [attestations](/binary-authorization/docs/key-concepts#attestations) on container images for the purpose of verifying that certain criteria are met before you can deploy the images to GKE.\nFor example, Binary Authorization can verify that an app passed its unit tests or that an app was built using a specific set of systems. For more information, see [Software Delivery Shield overview](/software-supply-chain-security/docs/sds/overview) .\nThis tutorial is intended for practitioners who want to better understand container vulnerability scanning and binary authorization, as well as their implementation and application in a CI/CD pipeline.\nThis tutorial assumes you are familiar with the following topics and technologies:- Continuous integration and continuous deployment\n- Common vulnerabilities and exposures (CVE) vulnerability scanning\n- GKE\n- Artifact Registry\n- Cloud Build\n- Cloud Key Management Service (Cloud KMS)\n", "content": "## Objectives\n- Deploy GKE clusters for staging and production.\n- Create multiple attestors and attestations.\n- Deploy a CI/CD pipeline using Cloud Build.\n- Test deployment pipeline.\n- Develop a break-glass process.\n## CostsIn this document, you use the following billable components of Google Cloud:- [GKE](/kubernetes-engine/pricing) \n- [Cloud Build](/build/pricing) \n- [Cloud Source Repositories](/source-repositories/pricing) \n- [Artifact Registry](/artifact-registry/pricing) \n- [Cloud KMS](/kms/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .## Before you begin- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) At the bottom of the Google Cloud console, a [Cloud Shell](/shell/docs/how-cloud-shell-works) session starts and displays a command-line prompt. Cloud Shell is a shell environment  with the Google Cloud CLI  already installed and with values already set for  your current project. It can take a few seconds for the session to initialize.\n- All commands in this tutorial are run in Cloud Shell.## Architecture of the CI/CD pipelineAn important aspect of software development lifecycle (SDLC) is ensuring and enforcing that app deployments follow your organization's approved processes. One method for establishing these checks and balances is with Binary Authorization on GKE. First, Binary Authorization attaches notes to container images. Then, GKE verifies that the required notes are present before you can deploy the app.\nThese notes, or **attestations** , make statements about the image. Attestations are completely configurable, but here are a few common examples:- The app passed unit tests.\n- The app was verified by the Quality Assurance (QA) team.\n- The app was scanned for vulnerabilities and none were found.\nThe following diagram depicts a SDLC where a single attestation is applied after vulnerability scanning finishes with no known vulnerabilities.In this tutorial, you create a CI/CD pipeline using Cloud Source Repositories, Cloud Build, Artifact Registry, and GKE. The following diagram illustrates the CI/CD pipeline.This CI/CD pipeline consists of the following steps:- Builds a container image with app source code.\n- Pushes the container image into Artifact Registry.\n- [Artifact Analysis](/container-registry/docs/container-analysis) , scans the container image for known security vulnerabilities or [CVEs](https://cve.mitre.org/) .\nIf the image contains no CVEs with a [severity score](https://www.first.org/cvss/specification-document#Qualitative-Severity-Rating-Scale) greater than five, the image is attested as having no critical CVEs and is automatically deployed to staging. A score greater than five indicates mid-range medium to critical vulnerability, and thus is not attested or deployed.\nA QA team inspects the app in the staging cluster. If it passes their requirements, they apply a manual attestation that the container image is of sufficient quality for deployment to production. The production manifests are updated and the app is deployed to the production GKE cluster.\nThe GKE clusters are configured to examine the container images for attestations and reject any deployments that don't have the required attestations. The staging GKE cluster only requires the vulnerability scan attestation, but the production GKE cluster requires both a vulnerability scan and QA attestation.\nIn this tutorial, you introduce failures into the CI/CD pipeline to test and verify this enforcement. Finally, you implement a [break-glass procedure](https://wikipedia.org/wiki/Computer_access_control#Break-Glass_Access_Control_Models) for bypassing these deployment checks in GKE in case of an emergency.## Setting up your environmentThis tutorial uses the following environment variables. You can change these values to match your requirements, but all steps in the tutorial assume these environment variables exist and contain a valid value.- In Cloud Shell, set the Google Cloud project where you deploy and manage all resources used in this tutorial:```\nexport PROJECT_ID=\"${DEVSHELL_PROJECT_ID}\"gcloud config set project ${PROJECT_ID}\n```\n- Set the region in which you deploy these resources:```\nexport REGION=\"us-central1\"\n```The GKE cluster and the Cloud KMS keys reside in this region. In this tutorial, the region is `us-central1` . For more information about regions, see [Geography and regions](/docs/geography-and-regions) .\n- Set the Cloud Build project number:```\nexport PROJECT_NUMBER=\"$(gcloud projects describe \"${PROJECT_ID}\" \\\u00a0 --format='value(projectNumber)')\"\n```\n- Set the Cloud Build service account email:```\nexport CLOUD_BUILD_SA_EMAIL=\"${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com\"\n```\n## Creating GKE clustersCreate two GKE clusters and grant Identity and Access Management (IAM) permissions for Cloud Build to deploy apps to GKE. Creating GKE clusters can take a few minutes.- In Cloud Shell, create a GKE cluster for staging:```\ngcloud container clusters create \"staging-cluster\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --machine-type \"n1-standard-1\" \\\u00a0 --region \"${REGION}\" \\\u00a0 --num-nodes \"1\" \\\u00a0 --binauthz-evaluation-mode=PROJECT_SINGLETON_POLICY_ENFORCE\n```\n- Create a GKE cluster for production:```\ngcloud container clusters create \"prod-cluster\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --machine-type \"n1-standard-1\" \\\u00a0 --region \"${REGION}\" \\\u00a0 --num-nodes \"1\" \\\u00a0 --binauthz-evaluation-mode=PROJECT_SINGLETON_POLICY_ENFORCE\n```\n- Grant the Cloud Build service account permission to deploy to GKE:```\ngcloud projects add-iam-policy-binding \"${PROJECT_ID}\" \\\u00a0 --member \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\" \\\u00a0 --role \"roles/container.developer\"\n```\n## Creating signing keysCreate two Cloud KMS [asymmetric keys](/kms/docs/create-validate-signatures) for signing attestations.- In Cloud Shell, create a Cloud KMS key ring named `binauthz` :```\ngcloud kms keyrings create \"binauthz\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --location \"${REGION}\"\n```\n- Create an asymmetric Cloud KMS key named `vulnz-signer` which will be used to sign and verify vulnerability scan attestations:```\ngcloud kms keys create \"vulnz-signer\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --location \"${REGION}\" \\\u00a0 --keyring \"binauthz\" \\\u00a0 --purpose \"asymmetric-signing\" \\\u00a0 --default-algorithm \"rsa-sign-pkcs1-4096-sha512\"\n```\n- Create an asymmetric Cloud KMS key named `qa-signer` to sign and verify QA attestations:```\ngcloud kms keys create \"qa-signer\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --location \"${REGION}\" \\\u00a0 --keyring \"binauthz\" \\\u00a0 --purpose \"asymmetric-signing\" \\\u00a0 --default-algorithm \"rsa-sign-pkcs1-4096-sha512\"\n```\n## Configuring attestationsYou create the notes that are attached to container images, grant permissions to the Cloud Build service account to view notes, attach notes, and create the attestors using the keys from the previous steps.\n### Create the vulnerability scanner attestation\n- In Cloud Shell, create a Artifact Analysis note named `vulnz-note` :```\ncurl \"https://containeranalysis.googleapis.com/v1/projects/${PROJECT_ID}/notes/?noteId=vulnz-note\" \\\u00a0 --request \"POST\" \\\u00a0 --header \"Content-Type: application/json\" \\\u00a0 --header \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\u00a0 --header \"X-Goog-User-Project: ${PROJECT_ID}\" \\\u00a0 --data-binary @- <<EOF\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"projects/${PROJECT_ID}/notes/vulnz-note\",\u00a0 \u00a0 \u00a0 \"attestation\": {\u00a0 \u00a0 \u00a0 \u00a0 \"hint\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"human_readable_name\": \"Vulnerability scan note\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }EOF\n```\n- Grant the Cloud Build service account permission to view and attach the `vulnz-note` note to container images:```\ncurl \"https://containeranalysis.googleapis.com/v1/projects/${PROJECT_ID}/notes/vulnz-note:setIamPolicy\" \\\u00a0 --request POST \\\u00a0 --header \"Content-Type: application/json\" \\\u00a0 --header \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\u00a0 --header \"X-Goog-User-Project: ${PROJECT_ID}\" \\\u00a0 --data-binary @- <<EOF\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"resource\": \"projects/${PROJECT_ID}/notes/vulnz-note\",\u00a0 \u00a0 \u00a0 \"policy\": {\u00a0 \u00a0 \u00a0 \u00a0 \"bindings\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"role\": \"roles/containeranalysis.notes.occurrences.viewer\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"role\": \"roles/containeranalysis.notes.attacher\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }EOF\n```\n- Create the vulnerability scan attestor:```\ngcloud container binauthz attestors create \"vulnz-attestor\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --attestation-authority-note-project \"${PROJECT_ID}\" \\\u00a0 --attestation-authority-note \"vulnz-note\" \\\u00a0 --description \"Vulnerability scan attestor\"\n```\n- Add the public key for the attestor's signing key:```\ngcloud beta container binauthz attestors public-keys add \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --attestor \"vulnz-attestor\" \\\u00a0 --keyversion \"1\" \\\u00a0 --keyversion-key \"vulnz-signer\" \\\u00a0 --keyversion-keyring \"binauthz\" \\\u00a0 --keyversion-location \"${REGION}\" \\\u00a0 --keyversion-project \"${PROJECT_ID}\"\n```\n- Grant the Cloud Build service account permission to view attestations made by `vulnz-attestor` :```\ngcloud container binauthz attestors add-iam-policy-binding \"vulnz-attestor\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --member \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\" \\\u00a0 --role \"roles/binaryauthorization.attestorsViewer\"\n```\n- Grant the Cloud Build service account permission to sign objects using the `vulnz-signer` key:```\ngcloud kms keys add-iam-policy-binding \"vulnz-signer\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --location \"${REGION}\" \\\u00a0 --keyring \"binauthz\" \\\u00a0 --member \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\" \\\u00a0 --role 'roles/cloudkms.signerVerifier'\n```\n### Create the QA attestation\n- In Cloud Shell, create a Artifact Analysis note named `qa-note` :```\ncurl \"https://containeranalysis.googleapis.com/v1/projects/${PROJECT_ID}/notes/?noteId=qa-note\" \\\u00a0 --request \"POST\" \\\u00a0 --header \"Content-Type: application/json\" \\\u00a0 --header \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\u00a0 --header \"X-Goog-User-Project: ${PROJECT_ID}\" \\\u00a0 --data-binary @- <<EOF\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"projects/${PROJECT_ID}/notes/qa-note\",\u00a0 \u00a0 \u00a0 \"attestation\": {\u00a0 \u00a0 \u00a0 \u00a0 \"hint\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"human_readable_name\": \"QA note\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }EOF\n```\n- Grant the Cloud Build service account permission to view and attach the `qa-note` note to container images:```\ncurl \"https://containeranalysis.googleapis.com/v1/projects/${PROJECT_ID}/notes/qa-note:setIamPolicy\" \\\u00a0 --request POST \\\u00a0 --header \"Content-Type: application/json\" \\\u00a0 --header \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\u00a0 --header \"X-Goog-User-Project: ${PROJECT_ID}\" \\\u00a0 --data-binary @- <<EOF\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"resource\": \"projects/${PROJECT_ID}/notes/qa-note\",\u00a0 \u00a0 \u00a0 \"policy\": {\u00a0 \u00a0 \u00a0 \u00a0 \"bindings\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"role\": \"roles/containeranalysis.notes.occurrences.viewer\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"role\": \"roles/containeranalysis.notes.attacher\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }EOF\n```\n- Create the QA attestor:```\ngcloud container binauthz attestors create \"qa-attestor\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --attestation-authority-note-project \"${PROJECT_ID}\" \\\u00a0 --attestation-authority-note \"qa-note\" \\\u00a0 --description \"QA attestor\"\n```\n- Add the public key for the attestor's signing key:```\ngcloud beta container binauthz attestors public-keys add \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --attestor \"qa-attestor\" \\\u00a0 --keyversion \"1\" \\\u00a0 --keyversion-key \"qa-signer\" \\\u00a0 --keyversion-keyring \"binauthz\" \\\u00a0 --keyversion-location \"${REGION}\" \\\u00a0 --keyversion-project \"${PROJECT_ID}\"\n```\n- Grant the Cloud Build service account permission to view attestations made by `qa-attestor` :```\ngcloud container binauthz attestors add-iam-policy-binding \"qa-attestor\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --member \"serviceAccount:${CLOUD_BUILD_SA_EMAIL}\" \\\u00a0 --role \"roles/binaryauthorization.attestorsViewer\"\n```\n- Grant your QA team permission to sign attestations: **Note:** This is an example using a group or team alias to grant permission. You can also add individual users. If you don't have a team alias to test, replace the member with your email address, for example `user:you@example.com` .```\ngcloud kms keys add-iam-policy-binding \"qa-signer\" \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --location \"${REGION}\" \\\u00a0 --keyring \"binauthz\" \\\u00a0 --member \"group:qa-team@example.com\" \\\u00a0 --role 'roles/cloudkms.signerVerifier'\n```\n## Setting the Binary Authorization policyEven though you created the GKE clusters with `--binauthz-evaluation-mode=PROJECT_SINGLETON_POLICY_ENFORCE` , you must author a policy that instructs GKE on what attestations the binaries require to run in the cluster. Binary Authorization policies exist at the level, but contain configuration for the level.\nThe following policy alters the default policy in the following ways:- Changes the default `evaluationMode` to `ALWAYS_DENY` . Only exempted images or images with the required attestations are admitted to run in the cluster.\n- Enables `globalPolicyEvaluationMode` , which changes the default allowlist to only include system images provided by Google.\n- Defines the following cluster admission rules:- `staging-cluster` requires attestations from `vulnz-attestor` .\n- `prod-cluster` requires attestations from `vulnz-attestor` and `qa-attestor` .\nFor more information on Binary Authorization policies, see [Policy YAML reference](/binary-authorization/docs/policy-yaml-reference) .- In Cloud Shell, create a YAML file that describes the Binary Authorization policy for the Google Cloud project:```\ncat > ./binauthz-policy.yaml <<EOFadmissionWhitelistPatterns:- namePattern: docker.io/istio/*defaultAdmissionRule:\u00a0 enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG\u00a0 evaluationMode: ALWAYS_DENYglobalPolicyEvaluationMode: ENABLEclusterAdmissionRules:\u00a0 # Staging cluster\u00a0 ${REGION}.staging-cluster:\u00a0 \u00a0 evaluationMode: REQUIRE_ATTESTATION\u00a0 \u00a0 enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG\u00a0 \u00a0 requireAttestationsBy:\u00a0 \u00a0 - projects/${PROJECT_ID}/attestors/vulnz-attestor\u00a0 # Production cluster\u00a0 ${REGION}.prod-cluster:\u00a0 \u00a0 evaluationMode: REQUIRE_ATTESTATION\u00a0 \u00a0 enforcementMode: ENFORCED_BLOCK_AND_AUDIT_LOG\u00a0 \u00a0 requireAttestationsBy:\u00a0 \u00a0 - projects/${PROJECT_ID}/attestors/vulnz-attestor\u00a0 \u00a0 - projects/${PROJECT_ID}/attestors/qa-attestorEOF\n```\n- Upload the new policy to the Google Cloud project:```\ngcloud container binauthz policy import ./binauthz-policy.yaml \\\u00a0 --project \"${PROJECT_ID}\"\n```\n## Creating the vulnerability scan checker and enabling the APICreate a container image that is used as a build step in Cloud Build. This container compares the severity scores of any detected vulnerabilities against the configured threshold. If the score is within the threshold, Cloud Build creates an attestation on the container. If the score is outside of the threshold, the build fails, and no attestation is created.- In Cloud Shell, create a new Artifact Registry repository to store the attestor image:```\ngcloud artifacts repositories create cloudbuild-helpers \\\u00a0 --repository-format=DOCKER --location=${REGION}\n```\n- Clone the binary authorization tools and sample application source:```\ngit clone https://github.com/GoogleCloudPlatform/gke-binary-auth-tools ~/binauthz-tools\n```\n- Build and push the vulnerability scan attestor container named `attestor` to `cloudbuild-helpers` Artifact Registry:```\ngcloud builds submit \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --tag \"us-central1-docker.pkg.dev/${PROJECT_ID}/cloudbuild-helpers/attestor\" \\\u00a0 ~/binauthz-tools\n```\n## Setting up the Cloud Build pipelineCreate a Cloud Source Repositories repository and Cloud Build trigger for the sample app and Kubernetes manifests.\n### Create the hello-app Cloud Source Repositories and Artifact Registry repository\n- In Cloud Shell, create a Cloud Source Repositories repository for the sample app:```\ngcloud source repos create hello-app \\\u00a0 --project \"${PROJECT_ID}\"\n```\n- Clone the repository locally:```\ngcloud source repos clone hello-app ~/hello-app \\\u00a0 --project \"${PROJECT_ID}\"\n```\n- Copy the sample code into the repository:```\ncp -R ~/binauthz-tools/examples/hello-app/* ~/hello-app\n```\n- Create a new Artifact Registry repository to store application images:```\ngcloud artifacts repositories create applications \\\u00a0 --repository-format=DOCKER --location=${REGION}\n```\n### Create the hello-app Cloud Build trigger\n- In the Google Cloud console, go to the **Triggers** page. [Go to Triggers](https://console.cloud.google.com/cloud-build/triggers) \n- Click **Manage Repositories** .\n- For the `hello-app` repository, click the **...** and select **Add Trigger** .\n- In the **Trigger Settings** window, enter the following details:- In the **Name** field, enter`build-vulnz-deploy`.\n- For **Event** choose **Push to a branch** .\n- In the **Repository** field, choose **hello-app** from the menu.\n- In the **Branch** field, enter`master`.\n- For **Configuration** , select **Cloud Build configuration file (yaml or json)** .\n- In the **Location** , select **Repository** enter the default value`/cloudbuild.yaml`.\n- Add the following **Substitution Variable** pairs:- `_COMPUTE_REGION`with the value`us-central1`(or the region you chose in the beginning).\n- `_KMS_KEYRING`with the value`binauthz`.\n- `_KMS_LOCATION`with the value`us-central1`(or the region you chose in the beginning).\n- `_PROD_CLUSTER`with the value`prod-cluster`.\n- `_QA_ATTESTOR`with the value`qa-attestor`.\n- `_QA_KMS_KEY`with the value`qa-signer`.\n- `_QA_KMS_KEY_VERSION`with the value`1`.\n- `_STAGING_CLUSTER`with the value`staging-cluster`.\n- `_VULNZ_ATTESTOR`with the value`vulnz-attestor`.\n- `_VULNZ_KMS_KEY`with the value`vulnz-signer`.\n- `_VULNZ_KMS_KEY_VERSION`with the value`1`.\n- Click **Create** .\n## Test the Cloud Build pipelineTest the CI/CD pipeline by committing and pushing the sample app to the Cloud Source Repositories repository. Cloud Build detects the change, builds, and deploys the app to `staging-cluster` . The pipeline waits for up to 10 minutes for QA verification. After the deployment is verified by the QA team, the process continues and the production Kubernetes manifests are updated and Cloud Build deploys the app to `prod-cluster` .- In Cloud Shell, commit and push the `hello-app` files to the Cloud Source Repositories repository to trigger a build:```\ncd ~/hello-appgit add .git commit -m \"Initial commit\"git push origin master\n```\n- In the Google Cloud console, go to the **History** page. [Go to History page](https://console.cloud.google.com/cloud-build/builds) \n- To watch the build progress, click the most recent run of Cloud Build. \n- When the deployment to `staging-cluster` is finished, go to the **Services** page. [Go to Services page](https://console.cloud.google.com/kubernetes/discovery) \n- To verify that the app is working, click the **Endpoints** link for the app.\n- Go to the **Repositories** page. [Go to Images page](https://console.cloud.google.com/artifacts) \n- Click **applications** .\n- Click **hello-app** .\n- Click the image that you validated in the staging deployment. \n- Copy the **Digest** value from the image details. This information is needed in the next step \n- To apply the manual QA attestation, replace `...` with the value you copied from the image details. The `DIGEST` variable should be in the format `sha256:` `` `.The `Await QA attestation` build step will also output a copy-pasteable command, shown below.```\nDIGEST=\"sha256:...\" # Replace with your valuegcloud beta container binauthz attestations sign-and-create \\\u00a0 --project \"${PROJECT_ID}\" \\\u00a0 --artifact-url \"${REGION}-docker.pkg.dev/${PROJECT_ID}/applications/hello-app@${DIGEST}\" \\\u00a0 --attestor \"qa-attestor\" \\\u00a0 --attestor-project \"${PROJECT_ID}\" \\\u00a0 --keyversion \"1\" \\\u00a0 --keyversion-key \"qa-signer\" \\\u00a0 --keyversion-location \"${REGION}\" \\\u00a0 --keyversion-keyring \"binauthz\" \\\u00a0 --keyversion-project \"${PROJECT_ID}\"\n```\n- To verify the app was deployed, go to the **Services page** . [Go to Services page](https://console.cloud.google.com/kubernetes/discovery) \n- To view the app, click the endpoint link.\n## Deploying an unattested imageSo far, the sample app didn't have any vulnerabilities. Update the app to output a different message and change the base image.- In Cloud Shell, change the output from `Hello World` to `Binary Authorization` , and change the base image from `distroless` to `debian` :```\ncd ~/hello-appsed -i \"s/Hello World/Binary Authorization/g\" main.gosed -i \"s/FROM gcr\\.io\\/distroless\\/static-debian11/FROM debian/g\" Dockerfile\n```\n- Commit and push the changes:```\ngit add .git commit -m \"Change message and base image\"git push origin master\n```\n- To monitor the status of the CI/CD pipeline, in the Google Cloud console, go to the **History** page. [Go to History page](https://console.cloud.google.com/cloud-build/builds) This build fails because of detected CVEs in the image.\n- To examine the identified CVEs, go to the **Images** page. [Go to Images page](https://console.cloud.google.com/gcr/images) \n- Click **hello-app** .\n- To review the identified CVEs, click the vulnerability summary for the most recent image. \n- In Cloud Shell, attempt to deploy the new image to production without the attestation from the vulnerability scan:```\nexport SHA_DIGEST=\"[SHA_DIGEST_VALUE]\"cd ~/hello-appsed \"s/REGION/${REGION}/g\" kubernetes/deployment.yaml.tpl | \\\u00a0 \u00a0 sed \"s/GOOGLE_CLOUD_PROJECT/${PROJECT_ID}/g\" | \\\u00a0 \u00a0 sed -e \"s/DIGEST/${SHA_DIGEST}/g\" > kubernetes/deployment.yamlgcloud container clusters get-credentials \\\u00a0 \u00a0 --project=${PROJECT_ID} \\\u00a0 \u00a0 --region=\"${REGION}\" prod-clusterkubectl apply -f kubernetes\n```\n- In the Google Cloud console, go to the **Workloads** page. [Go to Workloads page](https://console.cloud.google.com/kubernetes/workload) The image failed to deploy because it wasn't signed by the `vulnz-attestor` and the `qa-attestor` .\n## Break-glass procedureOccasionally, you need to allow changes that are outside the normal workflow. To allow image deployments without the required attestations, the pod definition is annotated with a break-glass policy flag. Enabling this flag still causes GKE to check for the required attestations, but allows the container image to be deployed and logs violations.\nFor more information about bypassing attestation checks, see [Override a policy](/binary-authorization/docs/deploying-containers#override_a_policy) .- In Cloud Shell, uncomment the break-glass annotation in the Kubernetes manifest:```\nsed -i \"31s/^#//\" kubernetes/deployment.yaml\n```\n- Use `kubectl` to apply the changes:```\nkubectl apply -f kubernetes\n```\n- To verify the change was deployed to `prod-cluster` go to the **Workloads** page in Google Cloud console. [Go to Workloads page](https://console.cloud.google.com/kubernetes/workload) The deployment error message is now gone.\n- To verify the app was deployed, go to the **Services** page. [Go to Services page](https://console.cloud.google.com/kubernetes/discovery) \n- To view the app, click the endpoint link.\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n## What's next\n- [Best practices for building containers](/solutions/best-practices-for-building-containers) .\n- [Deploying a containerized web application](/kubernetes-engine/docs/tutorials/hello-app) .\n- [GitOps-style continuous delivery with Cloud Build](/kubernetes-engine/docs/tutorials/gitops-cloud-build) .\n- [Managed base images](/artifact-registry/docs/docker/manage-images) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Cloud Architecture Center"}