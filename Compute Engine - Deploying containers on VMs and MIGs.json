{"title": "Compute Engine - Deploying containers on VMs and MIGs", "url": "https://cloud.google.com/compute/docs/instances", "abstract": "# Compute Engine - Deploying containers on VMs and MIGs\nYou can configure a virtual machine (VM) instance or an [instance template](/compute/docs/instance-templates) to deploy and launch a Docker container. Compute Engine supplies an up-to-date [Container-Optimized OS (COS)](/container-optimized-os/docs) image with Docker installed and launches your container when your VM starts.\n", "content": "## Before you begin\n- If you aren't familiar with containers, read [What are containers and their benefits](/containers) .\n- If you aren't familiar with Docker, read the [Docker documentation](https://docs.docker.com/) .\n- Read about [Container-Optimized OS](/container-optimized-os/docs) .\n- Read about [managed instance groups (MIGs)](/compute/docs/instance-groups#managed_instance_groups) .\n- If you haven't already, set up authentication. [Authentication](/compute/docs/authentication) is the process by which your identity is verified for access to Google Cloud services and APIs. To run code or samples from a local development environment, you can authenticate to Compute Engine as follows.Select the tab for how you plan to use the samples on this page:\nWhen you use the Google Cloud console to access Google Cloud services and   APIs, you don't need to set up authentication.- [Install](/sdk/docs/install) the Google Cloud CLI, then [initialize](/sdk/docs/initializing) it by running the following command:```\ngcloud init\n``` **Note:** If you installed the gcloud CLI  previously, make sure you have the latest version by running`gcloud components  update`.\n- [ Set a default region and zone](/compute/docs/gcloud-compute#set_default_zone_and_region_in_your_local_client) .\n## Choosing to deploy containers on VMs and MIGs\nBy deploying containers on Compute Engine, you can simplify app deployment while controlling your VM infrastructure.\n- Manage VMs that are running containers in the same way you would treat any other VM when configuring and managing your Compute Engine infrastructure.\n- Create scalable services using managed instance groups (MIGs) running containers, which offer features like autoscaling, autohealing, rolling updates, multi-zone deployments, and load balancing.\n- Use familiar processes and tools such as the Google Cloud CLI or the Compute Engine API to manage your VMs with containers.\nAlternatively, you might consider deploying to [Google Kubernetes Engine](/kubernetes-engine) to:\n- Run a large number of microservices\n- Have faster container startup time\n- Take advantage of [Kubernetes](https://kubernetes.io/) automated orchestration, including auto upgrades, node auto repair, and autoscaling\nRunning each microservice on a separate virtual machine (VM) on Compute Engine could make the operating system overhead a significant part of your cost. Google Kubernetes Engine lets you deploy multiple containers and groups of containers for each VM instance, which can allocate host VM resources more efficiently to microservices with a smaller footprint.\n## How deploying containers on Compute Engine works\nThe common methods of deploying software onto a Compute Engine VM instance include:\n- Deploying software on VM boot using a [startup script](/compute/docs/startupscript) or [cloud-init](https://cloudinit.readthedocs.io/en/latest/index.html) .\n- Creating a custom boot disk image with software pre-installed.\nBoth of the above methods combine the tasks of configuring the app and setting up the operating system environment. As the developer, you must carefully track and resolve any runtime dependencies. For example, if two apps running on a VM use different versions of the same library, you must install both versions and point to them through system variables.\nAlternatively, you can deploy software in a container onto a VM instance or to a MIG. A container carries both application software and the required libraries and is isolated from OS apps and libraries. A container can be easily moved between deployment environments without dealing with conflicting library versions in the container and its OS.\nThe following process describes how you deploy a container on Compute Engine:\n- You bundle your app and required libraries into a Docker image and publish the image to [Artifact Registry](/artifact-registry) , or a third-party registry such as Docker Hub.\n- You specify a Docker image name and the`docker run`configuration when creating a VM instance or an instance template for a MIG.\n**Note:** As of November 1, 2020, Docker Hub [rate limits](https://www.docker.com/blog/scaling-docker-to-serve-millions-more-developers-network-egress/) apply to unauthenticated or authenticated pull requests on the Docker Free plan. To avoid disruptions and have greater control over your software supply chain, you can migrate your dependencies to [Artifact Registry](/artifact-registry/docs/docker/migrate-external-containers) .\nCompute Engine executes the following tasks after you make a request to create a VM instance:\n- Compute Engine creates a VM instance that uses a Google-provided [Container-Optimized OS](/container-optimized-os/docs) image. This image includes a Docker runtime and additional software that is responsible for starting your container.\n- Compute Engine stores your container settings in [instance metadata](/compute/docs/storing-retrieving-metadata) under the`gce-container-declaration`metadata key.\n- When the VM starts, the Container-Optimized OS image uses the`docker run`command configuration that is stored in the instance's metadata, pulls the container image from the repository, and starts the container.\n## Limitations\n- You can only deploy one container for each VM instance. Consider [Google Kubernetes Engine](/kubernetes-engine) if you need to deploy multiple containers per VM instance.\n- You can only deploy containers from a public repository or from a private Artifact Registry or Container Registry repository that you can access. Other private repositories are not supported.See the access control documentation for [Artifact Registry](/artifact-registry/docs/access-control) or [Container Registry](/container-registry/docs/access-control) for information about private registry permissions. **Note:** Container Registry is deprecated. Organizations that haven't used Container Registry prior to January 8, 2024 will have new gcr.io repositories hosted on Artifact Registry by default. After May 15, 2024, Google Cloud projects without previous usage of Container Registry will only support hosting and managing images for the `gcr.io` domain in [Artifact Registry](/artifact-registry/docs) . For details, see [Container Registry deprecation](/container-registry/docs/deprecations/container-registry-deprecation) .\n- You can't map a VM instance's ports to the container's ports (Docker's `-p` option). To enable access to your containers, see [Publishing container ports](/compute/docs/containers/configuring-options-to-run-containers#publishing_container_ports) .\n- You can only use [Container-Optimized OS images](/container-optimized-os/docs) with this deployment method.\n- You can only use this feature through the Google Cloud console or the Google Cloud CLI, not the API.## Preparing a container for deployment\nChoose one of the following approaches to make your container image accessible to Compute Engine:\n- [Upload](/artifact-registry/docs/docker/pushing-and-pulling) your Docker image to Artifact Registry.\n- Use any publicly available container images from [Docker Hub](https://hub.docker.com) or other registries.\n**Note:** Consider running your container image builds on [Cloud Build](/build) , with none of the overhead of managing your own build servers.\n## Deploying a container on a new VM instance\nYou can deploy a container on a new VM instance by using the [Google Cloud console](https://console.cloud.google.com/) or the Google Cloud CLI.\nThe following example deploys a container from a Google-provided Nginx Docker image, `https://gcr.io/cloud-marketplace/google/nginx1:latest` , to a VM instance. To use a different Docker image, specify the image you want instead in the examples below.- Go to the **Create an instance** page. [Go to Create an instance](https://console.cloud.google.com/compute/instancesAdd) \n- Specify the VM details.\n- In the **Container** section, click **Deploy container** .\n- On the **Configure container** page, specify a container image name and configure [options to run the container](/compute/docs/containers/configuring-options-to-run-containers) for your needs. For example, you can specify `gcr.io/cloud-marketplace/google/nginx1:latest` for the container image.\n- Continue with the VM creation process.\nUse the `gcloud compute instances create-with-container` command:\n```\ngcloud compute instances create-with-container VM_NAME \\\n --container-image DOCKER_IMAGE\n```\nFor example, the following command creates a new VM instance named `nginx-vm` , which launches and runs the Docker image `gcr.io/cloud-marketplace/google/nginx1:latest` .\n```\ngcloud compute instances create-with-container nginx-vm \\\n --container-image gcr.io/cloud-marketplace/google/nginx1:latest\n```\nLearn more about the [gcloud compute instances create-with-container command](/sdk/gcloud/reference/compute/instances/create-with-container) .\nYou must always specify a full Docker image name when using a public image from Docker Hub. For example, specify the following image name to deploy an Apache container image:\n```\ndocker.io/httpd:2.4\n```\n## Updating a container on a VM instance\nYou can update a Docker image and configuration options to run the container on a VM instance using Google Cloud console or the Google Cloud CLI.\nWhen you update a VM running a container, Compute Engine performs two steps:\n- Updates container declaration on the instance. Compute Engine stores the updated container declaration in [instance metadata](/compute/docs/storing-retrieving-metadata) under the`gce-container-declaration`metadata key.\n- [Stops and restarts](/compute/docs/instances/stop-start-instance) the instance to actuate the updated configuration, if the instance is running. If the instance is stopped, updates the container declaration and keeps the instance stopped. The VM instance downloads the new image and launches the container on VM start.\n**Note:** If you specify a Docker image labeled with `latest` , the VM instance downloads the latest image and launches a container from the new image each time the VM starts. Do not use the `latest` label in production if you depend on a specific image version.\n- Go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Click the name of the VM to update.\n- On the instance details page, click **Edit** .\n- Specify the new container image and update the [options to run the container](/compute/docs/containers/configuring-options-to-run-containers) as needed.\n- To save your changes, click **Save and restart** . Compute Engine saves the changes and restarts the instance automatically to make the update. After the VM restarts, it downloads the new image and starts the container with the updated configuration.\nUpdate the container declaration by using the `gcloud compute instances update-container` command. For example:\n```\ngcloud compute instances update-container nginx-vm \\\n --container-image gcr.io/cloud-marketplace/google/nginx1:latest\n```\nThis command sets the container image to `gcr.io/cloud-marketplace/google/nginx1:latest` and restarts the instance to actuate the changes. You can also update any of the properties described in [Configuring options to run your container](/compute/docs/containers/configuring-options-to-run-containers) by adding corresponding flags.\nAfter the instance restarts, it downloads the new container image and starts the container with the new configuration.\n## Deploying a container on a managed instance group\nYou can deploy a container to a new managed instance group (MIG) using [Google Cloud console](https://console.cloud.google.com/) or the Google Cloud CLI by following these steps:\n- Create an [instance template](/compute/docs/instance-templates) that is based on a Docker image. **Note:** To maintain identical instances in your group, include a specific Docker image version in your instance template, such as `nginx1:15` . For more information, see [Deterministic instance templates](/compute/docs/instance-templates/deterministic-instance-templates) .\n- Create a [MIG](/compute/docs/instance-groups/creating-groups-of-managed-instances#create_managed_group) from the new instance template.\nThe following example creates an instance template that deploys a container from a Google-provided Nginx ( `gcr.io/cloud-marketplace/google/nginx1:15` ) Docker image to a MIG. To use other Docker images, specify your desired image instead of `gcr.io/cloud-marketplace/google/nginx1:15` in the following example.- Go to the **Instance templates** page. [Go to Instance templates](https://console.cloud.google.com/compute/instanceTemplates) \n- To create an instance template, click **Create instance template** .\n- Under **Container** , select **Deploy container image** .\n- Under **Container image** , specify the Docker image name and configure [options to run the container](/compute/docs/containers/configuring-options-to-run-containers) if desired. For example, you can specify `gcr.io/cloud-marketplace/google/nginx1:15` for the container image.\n- Click **Create** .\nNext, create a MIG that uses the new instance template.\nCreate an instance template for running Docker images using the `gcloud compute instance-templates create-with-container` command:\n```\ngcloud compute instance-templates create-with-container TEMPLATE_NAME \\\n --container-image DOCKER_IMAGE\n```\nYou can also configure [options to run your container](/compute/docs/containers/configuring-options-to-run-containers) if desired.\nFor example, the following command creates a new instance template with name `nginx-template` , which includes information about the Docker image. A VM instance created from this template launches and runs the Docker image `gcr.io/cloud-marketplace/google/nginx1:15` when the VM starts.\n```\ngcloud compute instance-templates create-with-container nginx-template \\\n --container-image gcr.io/cloud-marketplace/google/nginx1:15\n```\nNext, create a MIG using the new instance template.\nNow that you have an instance template, you can [create a MIG](/compute/docs/instance-groups/creating-groups-of-managed-instances#create_managed_group) that uses the instance template. For example, to create a MIG by using the gcloud CLI and the `nginx-template` that you just created, run the following command:\n```\ngcloud compute instance-groups managed create example-group \\\n --base-instance-name nginx-vm \\\n --size 3 \\\n --template nginx-template\n```\n## Updating a managed instance group running a container\n**    Beta     ** This feature is subject to the \"Pre-GA Offerings Terms\" in the General Service Terms section   of the [Service Specific Terms](/terms/service-terms#1) .     Pre-GA features are available \"as is\" and might have limited support.    For more information, see the [launch stage descriptions](/products#product-launch-stages) .\nYou can update a managed instance group (MIG) to deploy a new version of a Docker image or a new version of the Container-Optimized OS image.\n### Updating a MIG to a new version of a container image\nYou can deploy a new version of a Docker image to a MIG by using the Managed Instance Group Updater, in three steps:\n- [Prepare](#prepare) a new Docker image for deployment.\n- Create an instance template based on the new Docker image in the same way you [create a container-based template](#managedinstancegroupcontainer) .\n- Update a MIG to the new instance template by using the [Managed Instance Group Updater](/compute/docs/instance-groups/updating-managed-instance-groups) .\n### Updating a managed instance group to a new version of Container-Optimized OS image\nGoogle updates Container-Optimized OS images [regularly](/container-optimized-os/docs/resources/support-policy#release_quality) , and you might want to apply those updates to your containerized MIGs without changing your Docker image. You can update a MIG to a new version of a Container-Optimized OS image by using Google Cloud console or the Google Cloud CLI in two steps:\n- Create an instance template based on the current version of your Docker image, the same way you [create a container-based template](#managedinstancegroupcontainer) for a new MIG. The latest supported version of a Container-Optimized OS image is used by default.\n- Update a MIG with the new instance template by using [Managed Instance Group Updater](/compute/docs/instance-groups/updating-managed-instance-groups) .## Connecting to a container using SSH\nYou can connect to a container on a VM by using SSH. Use the gcloud CLI to run `gcloud compute ssh` with the `--container` flag:\n```\ngcloud compute ssh VM_NAME --container CONTAINER_NAME\n```\nReplace the following:\n- ``: the name of the VM instance\n- ``: the name of the container\nLearn more about the [gcloud compute ssh](/sdk/gcloud/reference/compute/ssh) command and its arguments.\n## Monitoring containers on Compute Engine\nTo monitor your instances running a Container-Optimized OS image, use the [Node Problem Detector](/container-optimized-os/docs/how-to/monitoring) agent, which communicates with Cloud Monitoring and reports health-related metrics. The agent is built into Container-Optimized OS images starting with Milestone 77.\nTo enable the agent, in containers using images with Milestone 88 or later, edit the [custom metadata section](/container-optimized-os/docs/how-to/monitoring#metadata) and set `google-monitoring-enabled` to `true` .\n**Note:** For more information about setting custom metadata for an instance, refer to the [VM metadata documentation](/compute/docs/storing-retrieving-metadata) .\nTo find other ways of enabling the Node Problem Detector, visit [Enabling health monitoring](/container-optimized-os/docs/how-to/monitoring#enabling_health_monitoring) .\nThe Node Problem Detector agent supports the metrics in the [metrics list](/monitoring/api/metrics_gcp#gcp-compute) that begin with `guest/` .\nTo interact with the metrics collected by the agent, visit the [Metrics Explorer](/monitoring/charts/metrics-explorer) .\n## Viewing logs\nYou can view three types of logs related to containers:\n- **Startup agent logs** , also known as [konlet](https://github.com/GoogleCloudPlatform/konlet) logs. The startup agent parses the container's configuration and runs tasks to start the container on a Compute Engine VM instance.\n- **Docker event logs** report container events, including container start and stop events.\n- **Logs from your container** include the `STDOUT` from apps that run in your container.\n**Note:** Depending on the container that you're using, you might need to allow incoming traffic to the container before you see any log entries. To enable access to your containers, see [Publishing container ports](/compute/docs/containers/configuring-options-to-run-containers#publishing_container_ports) .\".\n### Viewing startup agent logs\nStartup agent logs are available in the serial console, through the `journald` system service included in the OS image, and through [Cloud Logging](/logging/docs) .- Go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Select the VM instance for which you want to view startup agent logs.\n- Under **Logs** , click **Serial port 1 (console)** to view serial console logs.\nUse the [get-serial-port-output](/sdk/gcloud/reference/compute/instances/get-serial-port-output) command to view logs on the instance's serial port.\n```\ngcloud compute instances get-serial-port-output VM_NAME\n```\nReplace `` with the name of the VM instance.\nFor example, use the following command to view the serial port output of a VM instance named `nginx-vm` :\n```\ngcloud compute instances get-serial-port-output nginx-vm\n```- [Connect to your instance](/compute/docs/instances/connecting-to-instance) with a container by using SSH.\n- Execute the `sudo journalctl` command to see the VM startup and container startup logs. Use the following command to filter for container startup agent logs ( `konlet` ).```\nsudo journalctl -u konlet*\n```- Go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Select the VM instance for which you want to view startup agent logs.\n- Under **Logs** , click **Cloud Logging** to view Cloud Logging logs.\n- Enter a search filter to retrieve startup agent logs.```\nresource.type=\"gce_instance\"\nlogName=\"projects/PROJECT_ID/logs/cos_system\"\njsonPayload.SYSLOG_IDENTIFIER=\"konlet-startup\"\njsonPayload._HOSTNAME=\"VM_NAME\"\n```Replace the following:- ``: the project ID that contains the instance\n- ``: the name of the instance you want to get logs for\nUse the [gcloud logging read command](/sdk/gcloud/reference/logging/read) with an appropriate filter to view container startup agent logs.\n```\ngcloud logging read \"resource.type=gce_instance AND \\\n logName=projects/PROJECT_ID/logs/cos_system AND \\\n jsonPayload.SYSLOG_IDENTIFIER=konlet-startup AND \\\n jsonPayload._HOSTNAME=VM_NAME\"\n```\nReplace the following:- ``: the project ID that contains the instance\n- ``: the name of the instance that you want to get logs for\nFor example, use the following command to view the last 10 startup agent logs in Logging for a VM instance named `nginx-vm` that's running COS 70 and that exists in `my-project` .\n```\ngcloud logging read \"resource.type=gce_instance AND \\\n logName=projects/my-project/logs/cos_system AND \\\n jsonPayload.SYSLOG_IDENTIFIER=konlet-startup AND \\\n jsonPayload._HOSTNAME=nginx-vm\" \\\n --limit 10\n```\n### Viewing Docker event logs\nYou can view Docker event logs in `journald` and in Cloud Logging.- [Connect to your instance](/compute/docs/instances/connecting-to-instance) with a container using SSH.\n- Execute the `sudo journalctl` command with the following filter to see Docker event logs.```\nsudo journalctl -u docker-events-collector\n```- Go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Select the VM instance for which you want to view startup agent logs.\n- Under **Logs** , click **Cloud Logging** to view Cloud Logging logs.\n- Enter the following search filter to retrieve Docker event logs.```\nresource.type=\"gce_instance\"\nlogName=\"projects/PROJECT_ID/logs/cos_system\"\njsonPayload._HOSTNAME=\"VM_NAME\"\njsonPayload.SYSLOG_IDENTIFIER=\"docker\"\n```Replace the following:- ``: the project ID that contains the instance\n- ``: the name of the instance you want to get logs for\nUse the [gcloud logging read command](/sdk/gcloud/reference/logging/read) with an appropriate filter to view Docker event logs.\n```\ngcloud logging read \"resource.type=gce_instance AND \\\n logName=projects/PROJECT_ID/logs/cos_system AND \\\n jsonPayload._HOSTNAME=VM_NAME AND \\\n jsonPayload.SYSLOG_IDENTIFIER=docker\"\n```\nReplace the following:- ``: the project ID that contains the instance\n- ``: the name of the instance you want to get logs for\nFor example, use the following command to view the last 10 Docker event logs in Logging for a VM instance named `nginx-vm` that's running COS 70 and that exists in `my-project` .\n```\ngcloud logging read \"resource.type=gce_instance AND \\\n logName=projects/my-project/logs/cos_system AND \\\n jsonPayload._HOSTNAME=nginx-vm AND \\\n jsonPayload.SYSLOG_IDENTIFIER=docker\" \\\n --limit 10\n```\n### Viewing container logs\n- Go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Select the VM instance for which you want to view startup agent logs.\n- Under **Logs** , click **Cloud Logging** to view Cloud Logging logs.\n- The Cloud Logging page loads with a default search filter. Copy the value for `resource.labels.instance_id` . You will use it later.\n- Update the search filter to retrieve container logs.```\nresource.type=\"gce_instance\"\nlogName=\"projects/PROJECT_ID/logs/cos_containers\"\nresource.labels.instance_id=\"INSTANCE_ID\"\n```Replace the following:- ``: the project ID that contains the instance\n- ``: the ID of the instance that you want to get logs for\nUse the [gcloud logging read](/sdk/gcloud/reference/logging/read) command to view container logs.- Determine the ID for the instance that you want to get logs for:```\ngcloud compute instances describe VM_NAME \\\n --zone ZONE \\\n --format=\"value(id)\"\n```Replace the following:- ``: the name of the instance that you want to get logs for\n- ``: the zone where the instance is located\n- Use the following command and filter to view the instance's container logs.```\ngcloud logging read \"resource.type=gce_instance AND \\\n logName=projects/PROJECT_ID/logs/cos_containers AND \\\n resource.labels.instance_id=INSTANCE_ID\"\n```Replace the following:- ``: the project ID that contains the instance.\n- ``: the ID of the instance.\nFor example, use the following command to view the last 10 container logs in Cloud Logging for a VM instance that is running COS 70, that exists in `my-project` , and that has an instance ID of `555123456789012345` .```\ngcloud logging read \"resource.type=gce_instance AND \\\n logName=projects/my-project/logs/cos_containers AND \\\n resource.labels.instance_id=555123456789012345\" \\\n --limit 10\n```## Specifying container-optimized images or image families\nContainerized VM instances or instance templates are created to use the latest supported [container-optimized image](/container-optimized-os/docs) by default. The image belongs to the `cos-cloud` project.\nYou can override this default with another image from the `cos-cloud` project. For information about available image families and their attributes, see [Choosing the right Container-Optimized OS version](https://cloud.google.com/container-optimized-os/docs/concepts/versioning#choosing_the_right_version) .\nFor example, after you know which image you want to use, in the gcloud CLI, either provide the `--image` flag to override the default container-optimized image or provide the `--image-family` flag to pick the latest image from the specified family at VM creation time.\nThe following example creates a containerized VM instance that uses the latest image from the `cos-dev` image family:\n```\ngcloud compute instances create-with-container nginx-vm \\\n --image-family cos-dev \\\n --image-project cos-cloud \\\n --container-image gcr.io/cloud-marketplace/google/nginx1:1.15\n```\n## Configuring firewall rules\nContainerized VMs launch containers whose network is set to host mode. A container shares the host network stack, and all interfaces from the host are available to the container.\n**Note:** A VM instance starts a container with the `--network=\"host\"` flag of the `docker run` command. Learn about [container network settings and host mode](https://docs.docker.com/engine/reference/run#network-settings) .\nBy [default](/vpc/docs/firewalls#default_firewall_rules) , Google Cloud [firewall rules](/vpc/docs/firewalls) block all incoming connections to a VM instance and allow all outgoing connections from a VM instance.\n[Create firewall rules](/vpc/docs/using-firewalls#creating_firewall_rules) to allow incoming connections to your instance and therefore to the container.\n**Note:** This method of VM creation overrides the [default host firewall configuration](/container-optimized-os/docs/how-to/firewall) of container-optimized images and opens all ports for incoming TCP connections. The ports are still not accessible from outside the VM because of the [default firewall settings](/vpc/docs/firewalls#default_firewall_rules) of the [Virtual Private Cloud](/vpc/docs) (VPC) network.\n## Configuring options to run a container\nYou can configure the following options to run your container:\n- Specify a container restart policy.\n- Override container`ENTRYPOINT`(default command to be executed on container start).\n- Pass arguments to container`ENTRYPOINT`command.\n- Run a container in a privileged mode.\n- Mount a host directory or`tmpfs`as a data volume inside the container.\n- Set environment variables.\n- Allocate a buffer for`STDIN`in the container runtime.\n- Allocate a pseudo-TTY.\nLearn more about [configuring options to run your container](/compute/docs/containers/configuring-options-to-run-containers) .\n## What's next\n- Learn about [configuring options to run your container](/compute/docs/containers/configuring-options-to-run-containers) .\n- Learn more about [managed instance groups](/compute/docs/instance-groups/creating-groups-of-managed-instances) .\n- Learn about [Container-Optimized OS](/container-optimized-os/docs) .", "guide": "Compute Engine"}