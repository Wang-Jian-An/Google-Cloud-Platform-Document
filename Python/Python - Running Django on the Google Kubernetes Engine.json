{"title": "Python - Running Django on the Google Kubernetes Engine", "url": "https://cloud.google.com/python/django/kubernetes-engine", "abstract": "# Python - Running Django on the Google Kubernetes Engine\nDjango apps that run on [GKE](/gke) scale dynamically according to traffic.\nThis tutorial assumes that you're familiar with Django web development. If you're new to Django development, it's a good idea to work through [writing your first Django app](https://docs.djangoproject.com/en/stable/intro/tutorial01/) before continuing.\nWhile this tutorial demonstrates Django specifically, you can use this deployment process with other Django-based frameworks, such as [Wagtail](https://wagtail.org/) and [Django CMS](https://www.django-cms.org/en/) .\nThis tutorial uses Django 5, [which requires at least Python 3.10](https://docs.djangoproject.com/en/stable/faq/install/#what-python-version-can-i-use-with-django) .\nYou also need to have [Docker installed](https://docs.docker.com/engine/installation/) .", "content": "## ObjectivesIn this tutorial, you will:- Create and connect a Cloud SQL database.\n- Create and use Kubernetes secret values.\n- Deploy a Django app to Google Kubernetes Engine.\n## CostsIn this document, you use the following billable components of Google Cloud:- [GKE](/kubernetes-engine/pricing) \n- [Cloud SQL](/sql/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . ## Before you begin\n## Prepare your environment\n### Clone a sample appThe code for the Django sample app is in the [GoogleCloudPlatform/python-docs-samples](https://github.com/GoogleCloudPlatform/python-docs-samples) repository on GitHub.- You can either [download the sample](https://github.com/GoogleCloudPlatform/python-docs-samples/archive/master.zip) as a ZIP file and extract it or clone the repository to your local machine:```\ngit clone https://github.com/GoogleCloudPlatform/python-docs-samples.git\n```\n- Go to the directory that contains the sample code:\n```\ncd python-docs-samples/kubernetes_engine/django_tutorial\n```\n```\ncd python-docs-samples\\kubernetes_engine\\django_tutorial\n```### Confirm your Python setupThis tutorial relies on Python to run the sample application on your machine. The sample code also requires installing dependencies\nFor more details, refer to the [Python development environment guide](/python/docs/setup) .- Confirm your Python is at least version 5.0.```\n\u00a0python -V\n```You should see `Python 5.0.0` or higher. **Note:** If you see a version number starting with \"2\", you may need to run `python3` instead of `python` . If so, remember to reference your chosen Python installation when running `python` commands.\n- Create a Python virtual environment and install dependencies:\n```\npython -m venv venvsource venv/bin/activatepip install --upgrade pippip install -r requirements.txt\n```\n```\npython -m venv venvvenv\\scripts\\activatepip install --upgrade pippip install -r requirements.txt\n```### Download Cloud SQL Auth Proxy to connect to Cloud SQL from your local machine **Note:** If you are completing this tutorial from Cloud Shell, this section is not required.\nWhen deployed, your app uses the Cloud SQL Auth Proxy that is built into the Google Kubernetes Engine environment to communicate with your Cloud SQL instance. However, to test your app locally, you must install and use a local copy of the proxy in your development environment. For more details, refer to the [Cloud SQL Auth Proxy guide](/sql/docs/postgres/sql-proxy) .\nThe Cloud SQL Auth Proxy uses the Cloud SQL API to interact with your SQL instance. To do this, it requires application authentication through the [gcloud CLI](/sdk/gcloud) .- Authenticate and acquire credentials for the API:```\ngcloud auth application-default login\n```\n- Download and install the Cloud SQL Auth Proxy to your local machine.- Download the Cloud SQL Auth Proxy:```\ncurl -o cloud-sql-proxy https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.linux.amd64\n```\n- Make the Cloud SQL Auth Proxy executable:```\nchmod +x cloud-sql-proxy\n```\n- Download the Cloud SQL Auth Proxy:```\ncurl -o cloud-sql-proxy https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.linux.386\n```\n- If the`curl`command is not found, run`sudo apt install curl`and repeat the download command.\n- Make the Cloud SQL Auth Proxy executable:```\nchmod +x cloud-sql-proxy\n```\n- Download the Cloud SQL Auth Proxy:```\ncurl -o cloud-sql-proxy https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.darwin.amd64\n```\n- Make the Cloud SQL Auth Proxy executable:```\nchmod +x cloud-sql-proxy\n```\n- Download the Cloud SQL Auth Proxy:```\n\u00a0 curl -o cloud-sql-proxy https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.darwin.arm64\u00a0 \n```\n- Make the Cloud SQL Auth Proxy executable:```\n\u00a0 chmod +x cloud-sql-proxy\u00a0 \n```Right-click\n [https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.x64.exe](https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.x64.exe) \nand select\n **Save Link As** \nto download the Cloud SQL Auth Proxy. Rename the file to\n`cloud-sql-proxy.exe`\n.\nRight-click\n [https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.x86.exe](https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.9.0/cloud-sql-proxy.x86.exe) \nand select\n **Save Link As** \nto download the Cloud SQL Auth Proxy. Rename the file to\n`cloud-sql-proxy.exe`\n.\nThe Cloud SQL Auth Proxy has different container images, such as `distroless` , `alpine` , and `buster` . The default Cloud SQL Auth Proxy container image uses [distroless](https://github.com/GoogleContainerTools/distroless) , which contains no shell. If you need a shell or related tools, then download an image based on `alpine` or `buster` . For more information, see [Cloud SQL Auth Proxy Container Images](https://github.com/GoogleCloudPlatform/cloudsql-proxy#container-images) .\nYou can pull the latest image to your local machine using Docker by using the following command:\n```\ndocker pull gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.9.0\n```\n **Note** : The Cloud SQL Auth Proxy uses a repository that supports the`gcr.io`domain but serves images from Artifact Registry. For more information, see [Transition from Container Registry](/artifact-registry/docs/transition/transition-from-gcr) .\nFor other operating systems not included here, you can\n [compile the Cloud SQL Auth Proxy from source](http://github.com/GoogleCloudPlatform/cloudsql-proxy) \n.\nYou can choose to move the download to somewhere common, such as a location on your `PATH` , or your home directory. If you choose to do this, when you start the Cloud SQL Auth Proxy later on in the tutorial, remember to reference your chosen location when using `cloud_sql_proxy` commands.\n## Create backing servicesThis tutorial uses several Google Cloud services to provide the database, media storage, and secret storage that support the deployed Django project. These services are deployed in a specific region. For efficiency between services, all services should be deployed in the same region. For more information about the closest region to you, see [Products available by region](/about/locations#products-available-by-location) .\n### Set up a Cloud SQL for PostgreSQL instanceDjango officially supports multiple relational databases, but offers the most support for PostgreSQL. PostgreSQL is supported by Cloud SQL, so this tutorial chooses to use that type of database.\nThe following section describes the creation of a PostgreSQL instance, database, and database user for the app.- Create the PostgreSQL instance:\n- In the Google Cloud console, go to the **Cloud SQL Instances** page. [Go to the Cloud SQL Instances page](https://console.cloud.google.com/sql/instances) \n- Click **Create Instance** .\n- Click **PostgreSQL** .\n- In the **Instance ID** field, enter `` .\n- Enter a password for the postgres user.\n- Keep the default values for the other fields.\n- Click **Create** .\nIt takes a few minutes to create the instance and for it to be ready for use.- Create the PostgreSQL instance:```\ngcloud sql instances create INSTANCE_NAME \\\u00a0 \u00a0 --project PROJECT_ID \\\u00a0 \u00a0 --database-version POSTGRES_13 \\\u00a0 \u00a0 --tier db-f1-micro \\\u00a0 \u00a0 --region REGION\n```\nReplace the following:- ``: the Cloud SQL instance name\n- ``: the Google Cloud project ID\n- ``: the [Google Cloud region](https://cloud.google.com/run/docs/locations) \nIt takes a few minutes to create the instance and for it to be ready for use.\n- Within the created instance, create a database:\n- Within your instance page, go to the **Databases** tab.\n- Click **Create database** .\n- In the **Database name** dialog, enter``.\n- Click **Create** .\n- Create the database within the recently created instance:```\ngcloud sql databases create DATABASE_NAME \\\u00a0 \u00a0 --instance INSTANCE_NAME\n```Replace `` with a name for the database inside the instance.- Create a database user: **Note:** Users created this way get additional database rights. See [Limit the database user privileges](#limit-db-user-privileges) for an alternative method.\n- Within your instance page, go to the **Users** tab.\n- Click **Add User Account** .\n- In the **Add a user account to instance** dialog under \"Built-in Authentication\":\n- Enter the username``.\n- Enter the password``\n- Click **Add** .\n- Create the user within the recently created instance:```\ngcloud sql users create DATABASE_USERNAME \\\u00a0 \u00a0 --instance INSTANCE_NAME \\\u00a0 \u00a0 --password DATABASE_PASSWORD\n```Replace `` with a secure password.\n## Create a service accountThe proxy requires a service account with Editor privileges for your Cloud SQL instance. For more information about service accounts, see the [Google Cloud authentication overview](/docs/authentication) .\nIf you are connecting from Compute Engine, make sure your VM has the proper`scope`to connect using the Cloud SQL Admin API. [Configure the service account](/compute/docs/access/create-enable-service-accounts-for-instances#changeserviceaccountandscopes) to have either of the following access scopes:- https://www.googleapis.com/auth/sqlservice.admin\n- https://www.googleapis.com/auth/cloud-platform\n- In the Google Cloud console, go to the **Service accounts** page. [Go to Service accounts](https://console.cloud.google.com/iam-admin/serviceaccounts/) \n- Select the project that contains your Cloud SQL instance.\n- Click **Create service account** .\n- In the **Service account name** field, enter a descriptive name for the service account.\n- Change the **Service account ID** to a unique, recognizable value and then click **Create and continue** .\n- Click the **Select a role** field and select one of the following roles:- **Cloud SQL > Cloud SQL Client** \n- **Cloud SQL > Cloud SQL Editor** \n- **Cloud SQL > Cloud SQL Admin** \n- **Note:** To create a service account with the required permissions, you must have`resourcemanager.projects.setIamPolicy`permission. This permission is included in the  Project Owner, Project IAM Admin, and Organization Administrator roles.You must also have enabled the Cloud SQL Admin API. If you are using the legacy project  roles (Viewer, Editor, Owner), the service account must have at least the Editor role.- Click **Done** to finish creating the service account.\n- Click the action menu for your new service account and then select **Manage keys** .\n- Click the **Add key** drop-down menu and then click **Create new key** .\n- Confirm that the key type is JSON and then click **Create** .The private key file is downloaded to your machine. You can move it to another  location. Keep the key file secure.\n## Configure the database settingsUse the following commands to set environment variables for database access. These environment variables are used for local testing.\n```\nexport DATABASE_NAME=DATABASE_NAMEexport DATABASE_USER=DATABASE_USERNAMEexport DATABASE_PASSWORD=DATABASE_PASSWORD\n```\n```\nset DATABASE_USER=DATABASE_USERNAMEset DATABASE_PASSWORD=DATABASE_PASSWORD\n```## Set up your GKE configuration\n- This application is represented in a single Kubernetes configuration called `polls` . In `polls.yaml` replace `<your-project-id>` with your Google Cloud project ID ( ).\n- Run the following command and note the value of `connectionName` :```\ngcloud sql instances describe INSTANCE_NAME --format \"value(connectionName)\"\n```\n- In the `polls.yaml` file, replace `<your-cloudsql-connection-string>` with the `connectionName` value.\n## Run the app on your local computerWith the backing services configured, you can now run the app on your computer. This setup allows for local development, creating a superuser, and applying database migrations.- In a separate terminal, start the Cloud SQL Auth Proxy:\n```\n./cloud-sql-proxy PROJECT_ID:REGION:INSTANCE_NAME\n```\n```\ncloud-sql-proxy.exe PROJECT_ID:REGION:INSTANCE_NAME\n```\nThis step establishes a connection from your local computer to your Cloud SQL instance for local testing purposes. Keep the Cloud SQL Auth Proxy running the entire time you test your app locally. Running this process in a separate terminal allows you to keep working while this process runs.\n- In the original terminal, set the Project ID locally:\n```\nexport GOOGLE_CLOUD_PROJECT=PROJECT_ID\n```\n```\nset GOOGLE_CLOUD_PROJECT=PROJECT_ID\n```\n- Run the Django migrations to set up your models and assets:```\npython manage.py makemigrationspython manage.py makemigrations pollspython manage.py migratepython manage.py collectstatic\n```\n- Start the Django web server:```\npython manage.py runserver 8080\n```\n- In your browser, go to [http://localhost:8080](http://localhost:8080) .If you are in Cloud Shell, click the **Web Preview** button, and select **Preview on port 8080** .The page displays the following text: \"Hello, world. You're at the polls index.\" The Django web server running on your computer delivers the sample app pages.\n- Press `Ctrl` / `Cmd` + `C` to stop the local web server.\n## Use the Django admin consoleIn order to log into Django's admin console, you need to create a **superuser** . Since you have a locally accessible connection to the database, you can run management commands:- Create a superuser. You will be prompted to enter a username, email, and password.```\npython manage.py createsuperuser\n```\n- Start a local web server:```\npython manage.py runserver\n```\n- In your browser, go to [http://localhost:8000/admin](http://localhost:8000/admin) .\n- Log in to the admin site using the username and password you used when you ran `createsuperuser` .\n **Note:** Since you are connected to your Cloud SQL database, you will log into your deployed Django application with the same credentials.## Deploy the app to GKEWhen the app is deployed to Google Cloud, it uses the Gunicorn server. Gunicorn doesn't serve static content, so the app uses Cloud Storage to serve static content.\n### Collect and upload static resources\n- Create a Cloud Storage bucket and make it publicly readable.```\ngsutil mb gs://PROJECT_ID_MEDIA_BUCKETgsutil defacl set public-read gs://PROJECT_ID_MEDIA_BUCKET\n```\n- Gather all the static content locally into one folder:```\npython manage.py collectstatic\n```\n- Upload the static content to Cloud Storage:```\ngsutil -m rsync -r ./static gs://PROJECT_ID_MEDIA_BUCKET/static\n```\n- In `mysite/settings.py` , set the value of `STATIC_URL` to the following URL, replacing `[YOUR_GCS_BUCKET]` with your bucket name:```\nhttp://storage.googleapis.com/PROJECT_ID_MEDIA_BUCKET/static/\n```\n### Set up GKE\n- To initialize GKE, go to the **Clusters** page. [Go to the Clusters page](https://console.cloud.google.com/kubernetes/list) When you use GKE for the first time in a project, you need to wait for the \"Kubernetes Engine is getting ready. This may take a minute or more\" message to disappear.\n- Create a GKE cluster: [](None) ```\ngcloud container clusters create polls \\\u00a0 --scopes \"https://www.googleapis.com/auth/userinfo.email\",\"cloud-platform\" \\\u00a0 --num-nodes 4 --zone \"us-central1-a\"\n```Did you get the error: [\"Project [PROJECT_ID] is not fully initialized with thedefault service accounts.\"](#create-cluster) ?\n- After the cluster is created, use the `kubectl` command-line tool, which is integrated with the [gcloud CLI](/sdk/gcloud) , to interact with your GKE cluster. Because `gcloud` and `kubectl` are separate tools, make sure `kubectl` is configured to interact with the right cluster.```\ngcloud container clusters get-credentials polls --zone \"us-central1-a\"\n```\n### Set up Cloud SQL\n- You need several [secrets](https://kubernetes.io/docs/concepts/configuration/secret/) to enable your GKE app to connect with your Cloud SQL instance. One is required for instance-level access (connection), while the other two are required for database access. For more information about the two levels of access control, see [Instance access control](/sql/docs/mysql/instance-access-control) .- To create the secret for instance-level access, provide the location ( `[PATH_TO_CREDENTIAL_FILE]` ) of the JSON service account key you downloaded when you created your service account (see [Creating a service account](#creating_a_service_account) ):```\nkubectl create secret generic cloudsql-oauth-credentials \\\u00a0 --from-file=credentials.json=[PATH_TO_CREDENTIAL_FILE]\n```\n- To create the secrets for database access, use the SQL database, user name, and password defined in step 2 of [Initializing your Cloud SQL instance](#initializing_your_cloud_sql_instance) :```\nkubectl create secret generic cloudsql \\\u00a0 --from-literal=database=DATABASE_NAME \\\u00a0 --from-literal=username=DATABASE_USERNAME \\\u00a0 --from-literal=password=DATABASE_PASSWORD\n```\n- Retrieve the public Docker image for the Cloud SQL proxy.```\ndocker pull b.gcr.io/cloudsql-docker/gce-proxy\n```\n- Build a Docker image, replacing `<your-project-id>` with your project ID.```\ndocker build -t gcr.io/PROJECT_ID/polls .\n```\n- Configure Docker to use `gcloud` as a credential helper, so that you can push the image to [Container Registry](/container-registry) :```\ngcloud auth configure-docker\n```\n- Push the Docker image. Replace `<your-project-id>` with your project ID.```\ndocker push gcr.io/PROJECT_ID/polls\n``` **Note:** This command requires write access to Cloud Storage. If you run this tutorial on a Compute Engine instance, your access to Cloud Storage might be read-only. To get write access, [create a service account](https://console.cloud.google.com/project/_/iam-admin/serviceaccounts) and [use the service account to authenticate](/sdk/gcloud/reference/auth/activate-service-account) on your instance.\n- Create the GKE resource:```\nkubectl create -f polls.yaml\n``` **Note:** If you used different names when creating the secrets in the previous commands, then you need to update the `polls.yaml` file to match those new names.\n### Deploy the app to GKEAfter the resources are created, there are three `polls` pods on the cluster. Check the status of your pods:\n```\nkubectl get pods\n```\nWait a few minutes for the pod statuses to display as `Running` . If the pods aren't ready or if you see restarts, you can get the logs for a particular pod to figure out the issue. `[YOUR-POD-ID]` is a part of the output returned by the previous `kubectl get pods` command.\n```\nkubectl logs [YOUR_POD_ID]\n```## See the app run in Google CloudAfter the pods are ready, you can get the public IP address of the load balancer:\n```\nkubectl get services polls\n```\nNote the `EXTERNAL-IP` address, and go to `http://[EXTERNAL-IP]` in your browser to see the Django polls landing page and access the admin console.## Understand the code\n### Sample applicationThe Django sample app was created using standard Django tooling. The following commands create the project and the polls app:\n```\ndjango-admin startproject mysitepython manage.py startapp polls\n```\nThe base views, models, and route configurations were copied from [Writing your first Django app](https://docs.djangoproject.com/en/stable/#first-steps) ( [Part 1](https://docs.djangoproject.com/en/stable/intro/tutorial01/) and [Part 2](https://docs.djangoproject.com/en/stable/intro/tutorial02/) ).\n### Database configurationThe `settings.py` contains the configuration for your SQL database:\n [  kubernetes_engine/django_tutorial/mysite/settings.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/kubernetes_engine/django_tutorial/mysite/settings.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/kubernetes_engine/django_tutorial/mysite/settings.py) \n```\nDATABASES = {\u00a0 \u00a0 \"default\": {\u00a0 \u00a0 \u00a0 \u00a0 # If you are using Cloud SQL for MySQL rather than PostgreSQL, set\u00a0 \u00a0 \u00a0 \u00a0 # 'ENGINE': 'django.db.backends.mysql' instead of the following.\u00a0 \u00a0 \u00a0 \u00a0 \"ENGINE\": \"django.db.backends.postgresql\",\u00a0 \u00a0 \u00a0 \u00a0 \"NAME\": os.getenv(\"DATABASE_NAME\"),\u00a0 \u00a0 \u00a0 \u00a0 \"USER\": os.getenv(\"DATABASE_USER\"),\u00a0 \u00a0 \u00a0 \u00a0 \"PASSWORD\": os.getenv(\"DATABASE_PASSWORD\"),\u00a0 \u00a0 \u00a0 \u00a0 \"HOST\": \"127.0.0.1\",\u00a0 \u00a0 \u00a0 \u00a0 \"PORT\": \"5432\",\u00a0 \u00a0 }}\n```\n### Kubernetes pod configurationsThe `polls.yaml` file specifies two Kubernetes resources. The first is the [Service](http://kubernetes.io/docs/user-guide/services/) , which defines a consistent name and private IP address for the Django web app. The second is an [HTTP load balancer](/kubernetes-engine/docs/load-balancer) with a public-facing external IP address.\n [  kubernetes_engine/django_tutorial/polls.yaml ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/kubernetes_engine/django_tutorial/polls.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/kubernetes_engine/django_tutorial/polls.yaml) \n```\n# The polls service provides a load-balancing proxy over the polls app# pods. By specifying the type as a 'LoadBalancer', Kubernetes Engine will# create an external HTTP load balancer.# For more information about Services see:# \u00a0 https://kubernetes.io/docs/concepts/services-networking/service/# For more information about external HTTP load balancing see:# \u00a0 https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/apiVersion: v1kind: Servicemetadata:\u00a0 name: polls\u00a0 labels:\u00a0 \u00a0 app: pollsspec:\u00a0 type: LoadBalancer\u00a0 ports:\u00a0 - port: 80\u00a0 \u00a0 targetPort: 8080\u00a0 selector:\u00a0 \u00a0 app: polls\n```\nThe service provides a network name and IP address, and GKE pods run the app's code behind the service. The `polls.yaml` file specifies a [deployment](http://kubernetes.io/docs/user-guide/deployments/) that provides declarative updates for GKE pods. The service directs traffic to the deployment by matching the service's selector to the deployment's label. In this case, the selector `polls` is matched to the label `polls` .\n [  kubernetes_engine/django_tutorial/polls.yaml ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/kubernetes_engine/django_tutorial/polls.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/kubernetes_engine/django_tutorial/polls.yaml) \n```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: polls\u00a0 labels:\u00a0 \u00a0 app: pollsspec:\u00a0 replicas: 3\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: polls\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: polls\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: polls-app\u00a0 \u00a0 \u00a0 \u00a0 # Replace \u00a0with your project ID or use `make template`\u00a0 \u00a0 \u00a0 \u00a0 image: gcr.io/<your-project-id>/polls\u00a0 \u00a0 \u00a0 \u00a0 # This setting makes nodes pull the docker image every time before\u00a0 \u00a0 \u00a0 \u00a0 # starting the pod. This is useful when debugging, but should be turned\u00a0 \u00a0 \u00a0 \u00a0 # off in production.\u00a0 \u00a0 \u00a0 \u00a0 imagePullPolicy: Always\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: DATABASE_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: cloudsql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: database\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: DATABASE_USER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: cloudsql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: username\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: DATABASE_PASSWORD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: cloudsql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password\u00a0 \u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - containerPort: 8080\u00a0 \u00a0 \u00a0 - image: gcr.io/cloudsql-docker/gce-proxy:1.16\u00a0 \u00a0 \u00a0 \u00a0 name: cloudsql-proxy\u00a0 \u00a0 \u00a0 \u00a0 command: [\"/cloud_sql_proxy\", \"--dir=/cloudsql\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"-instances=<your-cloudsql-connection-string>=tcp:5432\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"-credential_file=/secrets/cloudsql/credentials.json\"]\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: cloudsql-oauth-credentials\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /secrets/cloudsql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 readOnly: true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: ssl-certs\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /etc/ssl/certs\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - name: cloudsql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /cloudsql\u00a0 \u00a0 \u00a0 volumes:\u00a0 \u00a0 \u00a0 \u00a0 - name: cloudsql-oauth-credentials\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secret:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretName: cloudsql-oauth-credentials\u00a0 \u00a0 \u00a0 \u00a0 - name: ssl-certs\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 hostPath:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 path: /etc/ssl/certs\u00a0 \u00a0 \u00a0 \u00a0 - name: cloudsql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 emptyDir: {}\n```## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete the individual resourcesIf you don't want to delete the project, delete the individual resources.- Delete the Google Kubernetes Engine cluster:```\ngcloud container clusters delete polls\n```\n- Delete the Docker image that you pushed to Container Registry:```\ngcloud container images delete gcr.io/PROJECT_ID/polls\n```\n- Delete the Cloud SQL instance:```\ngcloud sql instances delete INSTANCE_NAME\n```\n## What's next\n- Learn how to [configure PostgreSQL for production](/solutions/setting-up-cloud-sql-for-postgresql-for-production) \n- Learn more about [Django on Google Cloud](/python/django)", "guide": "Python"}