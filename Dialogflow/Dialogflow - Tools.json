{"title": "Dialogflow - Tools", "url": "https://cloud.google.com/dialogflow/vertex/docs/concept/tools", "abstract": "# Dialogflow - Tools\n**    Preview     ** This product or feature is subject to the \"Pre-GA Offerings Terms\" in the General Service Terms section   of the [Service Specific Terms](/terms/service-terms#1) .     Pre-GA products and features are available \"as is\" and might have limited support.    For more information, see the [launch stage descriptions](/products#product-launch-stages) .\nUsing tools, you can connect playbook agents to external systems. These systems can augment the knowledge of playbook agents and empower them to execute complex tasks efficiently.\nYou can use [built-in tools](#built-in) or build [customized tools](#customized) to suit your requirements.\n", "content": "## Built-in tools\nBuilt-in tools are hosted by Google. You can activate these tools in playbook agents without the need for manual configuration.\nThe supported built-in tools are:\n- `Code Interpreter`: A Google first party tool that combines the capability of code generation and code execution and allow the user to perform various tasks, including: data analysis, data visualization, text processing, solving equations or optimization problems.\nYour playbook agent is optimized to determine how and when these tools should be invoked, but you can provide additional examples to fit your use cases.\nExamples should have a schema like the following:\n```\n{\u00a0 \"toolUse\": {\u00a0 \u00a0 \"tool\": \"projects/PROJECT_ID/locations/LOCATION_ID/agents/AGENT_ID/tools/df-code-interpreter-tool\",\u00a0 \u00a0 \"action\": \"generate_and_execute\",\u00a0 \u00a0 \"inputParameters\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"generate_and_execute input\",\u00a0 \u00a0 \u00a0 \u00a0 \"value\": \"4 + 4\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ],\u00a0 \u00a0 \"outputParameters\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"generate_and_execute output\",\u00a0 \u00a0 \u00a0 \u00a0 \"value\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"output_files\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"contents\": \"\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"execution_result\": \"8\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"execution_error\": \"\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"generated_code\": \"GENERATED_CODE\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\n## Customized tools\nThe following sections describe customized tools.\n### OpenAPI tools\nA playbook agent can connect to an external API using an OpenAPI tool by providing the [OpenAPI](https://www.openapis.org/) schema. By default, the playbook agent will call the API on your behalf. Alternatively, you can execute OpenAPI tools on the [client side](#client-side) .\nExample schema:\n```\nopenapi: 3.0.0info:\u00a0 title: Simple Pets API\u00a0 version: 1.0.0servers:\u00a0 - url: 'https://api.pet-service-example.com/v1'paths:\u00a0 /pets/{petId}:\u00a0 \u00a0 get:\u00a0 \u00a0 \u00a0 summary: Return a pet by ID.\u00a0 \u00a0 \u00a0 operationId: getPet\u00a0 \u00a0 \u00a0 parameters:\u00a0 \u00a0 \u00a0 \u00a0 - in: path\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: petId\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 required: true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: Pet id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: integer\u00a0 \u00a0 \u00a0 responses:\u00a0 \u00a0 \u00a0 \u00a0 200:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: OK\u00a0 /pets:\u00a0 \u00a0 get:\u00a0 \u00a0 \u00a0 summary: List all pets\u00a0 \u00a0 \u00a0 operationId: listPets\u00a0 \u00a0 \u00a0 parameters: \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 - name: petName\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 in: query\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 required: false\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: Pet name\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\u00a0 \u00a0 \u00a0 \u00a0 - name: label\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 in: query\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: Pet label\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 style: form\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 explode: true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 required: false\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: array\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 items:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\u00a0 \u00a0 \u00a0 \u00a0 - name: X-OWNER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 in: header\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: Optional pet owner provided in the HTTP header\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 required: false\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\u00a0 \u00a0 \u00a0 \u00a0 - name: X-SESSION\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 in: header\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: Dialogflow session id\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 required: false\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $ref: \"@dialogflow/sessionId\"\u00a0 \u00a0 \u00a0 responses:\u00a0 \u00a0 \u00a0 \u00a0 '200':\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: An array of pets\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 content:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 application/json:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: array\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 items:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $ref: '#/components/schemas/Pet'\u00a0 \u00a0 post:\u00a0 \u00a0 \u00a0 summary: Create a new pet\u00a0 \u00a0 \u00a0 operationId: createPet\u00a0 \u00a0 \u00a0 requestBody:\u00a0 \u00a0 \u00a0 \u00a0 description: Pet to add to the store\u00a0 \u00a0 \u00a0 \u00a0 required: true\u00a0 \u00a0 \u00a0 \u00a0 content:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 application/json:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $ref: '#/components/schemas/Pet'\u00a0 \u00a0 \u00a0 responses:\u00a0 \u00a0 \u00a0 \u00a0 '201':\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 description: Pet created\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 content:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 application/json:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 schema:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $ref: '#/components/schemas/Pet'components:\u00a0 schemas:\u00a0 \u00a0 Pet:\u00a0 \u00a0 \u00a0 type: object\u00a0 \u00a0 \u00a0 required:\u00a0 \u00a0 \u00a0 \u00a0 - id\u00a0 \u00a0 \u00a0 \u00a0 - name \u00a0 \u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 properties:\u00a0 \u00a0 \u00a0 \u00a0 id:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: integer\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 format: int64\u00a0 \u00a0 \u00a0 \u00a0 name:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\u00a0 \u00a0 \u00a0 \u00a0 owner:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\u00a0 \u00a0 \u00a0 \u00a0 label:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: array\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 items:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 type: string\n```\nYou can optionally use the internal schema reference `@dialogflow/sessionId` as parameter schema type. With this parameter schema type, the Dialogflow session ID for the current conversation will be supplied as a parameter value. For example:\n```\n- name: X-SESSION\u00a0 \u00a0in: header\u00a0 \u00a0description: Dialogflow session id\u00a0 \u00a0required: false\u00a0 \u00a0schema:\u00a0 \u00a0 \u00a0$ref: \"@dialogflow/sessionId\"\n```\nThe following limitations apply:\n- Supported parameter types are`path`,`query`,`header`. The`cookie`parameter type is not supported yet.\n- Parameters defined by OpenAPI schema support the following data types:`string`,`number`,`integer`,`boolean`,`array`. The`object`type is not supported yet.\n- You currently can't specify query parameters in the console example editor.\n- Request and response body must be empty or JSON.The following authentication options are supported when calling an external API:\n- Dialogflow Service Agent auth- Dialogflow can generate an [ID token](/docs/authentication/token-types#id) or [access token](/docs/authentication/token-types#access) using [Dialogflow Service Agent](/iam/docs/service-agents#dialogflow-service-agent) . The token is added in the authorization HTTP header when Dialogflow calls an external API.\n- An ID token can be used to access Cloud Functions and Cloud Run services after you grant the [roles/cloudfunctions.invoker](/functions/docs/reference/iam/roles#cloudfunctions.invoker) and [roles/run.invoker](/run/docs/reference/iam/roles#run.invoker) roles to **service-agent-project-number@gcp-sa-dialogflow.iam.gserviceaccount.com** . If the Cloud Functions and Cloud Run services are in the same [resource project](/dialogflow/cx/docs/concept/multi-project) , you don't need additional IAM permission to call them.\n- An access token can be used to access other Google Cloud APIs after you grant required roles to **service-agent-project-number@gcp-sa-dialogflow.iam.gserviceaccount.com** .\n- API key- You can configure API key authentication by providing the key name, request location (header or query string) and API key so that Dialogflow passes the API key in the request.\n- OAuth- OAuth Client Credential flow is supported for server-to-server authentication. Client ID, Client Secret and Token endpoint from OAuth provider need to be configured in Dialogflow. Dialogflow exchanges an OAuth access token and passes it in the auth header of the request.\n- For other OAuth flows, you need to use the Function Tool to integrate with your own sign-in UI to exchange the token.\n- Mutual TLS authentication- See the [Mutual TLS authentication](/dialogflow/cx/docs/concept/mtls) documentation.\n- Custom CA certificate- See the [Custom CA certificates](/dialogflow/cx/docs/concept/custom-ca) documentation.\n### Data store tools\nData store tools can be used by a playbook agent for answers to end-user's questions from your [data stores](/dialogflow/vertex/docs/concept/data-store) . You can set up one data store of each type per tool, and the tool will query each of these data stores for answers. By default, the playbook agent will call the data store tool on your behalf. Alternatively, you can execute data store tools on the [client side](#client-side) .\nThe data store type can be one of the following:\n- `PUBLIC_WEB`: A data store that contains public web content.\n- `UNSTRUCTURED`: A data store that contains unstructured private data.\n- `STRUCTURED`: A data store that contains structured data (for example FAQ).\nThe following example shows how to reference a data store:\n```\n\"dataStoreConnections\": [\u00a0 {\u00a0 \u00a0 \"dataStoreType\": \"PUBLIC_WEB\",\u00a0 \u00a0 \"dataStore\": \"projects/PROJECT_NUMBER/locations/LOCATION_ID/collections/default_collection/dataStores/DATASTORE_ID\"\u00a0 },\u00a0 {\u00a0 \u00a0 \"dataStoreType\": \"UNSTRUCTURED\",\u00a0 \u00a0 \"dataStore\": \"projects/PROJECT_NUMBER/locations/LOCATION_ID/collections/default_collection/dataStores/DATASTORE_ID\"\u00a0 },\u00a0 {\u00a0 \u00a0 \"dataStoreType\": \"STRUCTURED\",\u00a0 \u00a0 \"dataStore\": \"projects/PROJECT_NUMBER/locations/LOCATION_ID/collections/default_collection/dataStores/DATASTORE_ID\"\u00a0 }]\n```\nData store tool responses might also contain snippets about the content source that was used to generate the response. The playbook agent can further provide instructions on how to proceed with the answer from the data stores or how to respond when there is no answer.\nYou can overwrite an answer by adding an [FAQ entry](/dialogflow/vertex/docs/concept/data-store#structured) for a specific question.\nExamples can be used to further enhance the playbook agent behavior. The example should have the following schemas:\n```\n{\u00a0 \"toolUse\": {\u00a0 \u00a0 \"tool\": \"projects/PROJECT_ID/locations/LOCATION_ID/agents/AGENT_ID/tools/TOOL_ID\",\u00a0 \u00a0 \"action\": \"TOOL_DISPLAY_NAME\",\u00a0 \u00a0 \"inputParameters\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"TOOL_DISPLAY_NAME input\",\u00a0 \u00a0 \u00a0 \u00a0 \"value\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"query\": \"QUERY\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ],\u00a0 \u00a0 \"outputParameters\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"TOOL_DISPLAY_NAME output\",\u00a0 \u00a0 \u00a0 \u00a0 \"value\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"answer\": \"ANSWER\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"snippets\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"title\": \"TITLE\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"text\": \"TEXT_FROM_DATASTORE\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"uri\": \"URI_OF_DATASTORE\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\nWhen creating data store tool examples, two optional parameters are available, together with the required `query` string - a `filter` string and an `userMetadata` structured object.\nThe `filter` parameter provides the ability to filter search queries of your structured data or unstructured data with metadata. This string must follow the [supported filter expression syntax](/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax) . Multiple examples are encouraged to instruct the agent LLM on how to populate this parameter. In the case of an invalid filter string, the filter will be ignored when performing the search query.\nAn example of a `filter` string to refine search results based on location could look like:\n```\n\u00a0 \"filter\": \"country: ANY(\\\"Canada\\\")\"\n```\nThe `userMetadata` parameter provides information about the end-user. Any key-value pairs can be populated in this parameter. This metadata is passed into the data store tool to better inform the search results and tool response. It is encouraged to provide multiple examples to instruct the playbook LLM on how to populate this parameter.\nAn example of a `userMetadata` parameter value to refine search results relevant to a specific user could look like:\n```\n\u00a0 \"userMetadata\": {\u00a0 \u00a0 \"favoriteColor\": \"blue\",\u00a0 \u00a0 ...\u00a0 }\n```\nIf you find some responses during testing don't meet your expectations, the following customizations are available in the Tool page for a data store tool:\nFor each response generated from the content of your connected data stores, the agent evaluates a confidence level, which gauges the confidence that all information in the response is supported by information in the data stores. You can customize which responses to allow by selecting the lowest confidence level you are comfortable with. Only responses at or above that confidence level will be shown.\nThere are 5 confidence levels to choose from: `VERY_LOW` , `LOW` , `MEDIUM` , `HIGH` , and `VERY_HIGH` .\nYou can select the generative model used by a data store agent for the summarization generative request. If none gets selected, a default model option is used. The following table contains the available options:\n| Model Identifier      | Language Support       |\n|:--------------------------------------|:-----------------------------------------|\n| text-bison@001      | Available in all supported languages. |\n| text-bison@002      | Available in all supported languages. |\n| text-bison@001 tuned (conversational) | Only English is supported at the moment. |\n| text-bison@001 tuned (informational) | Only English is supported at the moment. |\n| gemini-pro       | Available in all supported languages. |\nYou can also provide your own prompt for the summarization LLM call.\n**Note:** Providing a custom prompt may influence the quality of answers either positively or negatively. You are responsible for the quality of answers.\nThe prompt is a text template that may contain predefined placeholders. The placeholders will be replaced with the appropriate values at runtime and the final text will be sent to the LLM.\nThe placeholders are as follows:\n- `$original-query`: The user's query text.\n- `$rewritten-query`: The agent uses a rewriter module to rewrite the original user query into a more accurate format.\n- `$sources` : The agent uses Enterprise Search to search for sources based on the user's query. The found sources are rendered in a specific format:```\n[1] title of first sourcecontent of first source[2] title of second sourcecontent of first source\n```\n- `$conversation` : The conversation history is rendered in the following format:```\nHuman: user's first queryAI: answer to user's first queryHuman: user's second queryAI: answer to user's second query\n```\nA custom prompt should instruct the LLM to return \"NOT_ENOUGH_INFORMATION\" when it cannot provide an answer. The agent will transform this constant to a user friendly message for the user.\nYou have the option to define specific phrases which shouldn't be allowed. These are configured at the agent level and utilized by both the playbook LLMs and the data store tools. If the generated response or parts of the LLM prompt, such as the user's utterances, contain any of the banned phrases verbatim, then that response won't be shown.\n### Function tools\nIf you have functionality accessible by your client code, but not accessible by OpenAPI tools, you can use function tools. Function tools are always executed on the client side, not by the playbook agent.\nThe process is as follows:\n- Your client code sends a detect intent request.\n- The playbook agent detects that a function tool is required, and the detect intent response contains the name of the tool along with input arguments. This session is paused until another detect intent request is received with the tool result.\n- Your client code calls the tool.\n- Your client code sends another detect intent request that provides the tool result as output arguments.\nThe following example shows the input and output schema of a function tool:\n```\n{\u00a0 \"type\": \"object\",\u00a0 \"properties\": {\u00a0 \u00a0 \"location\": {\u00a0 \u00a0 \u00a0 \"type\": \"string\",\u00a0 \u00a0 \u00a0 \"description\": \"The city and state, for example, San Francisco, CA\"\u00a0 \u00a0 }\u00a0 },\u00a0 \"required\": [\u00a0 \u00a0 \"location\"\u00a0 ]}\n```\n```\n{\u00a0 \"type\": \"object\",\u00a0 \"properties\": {\u00a0 \u00a0 \"temperature\": {\u00a0 \u00a0 \u00a0 \"type\": \"number\",\u00a0 \u00a0 \u00a0 \"description\": \"The temperature\"\u00a0 \u00a0 }\u00a0 }}\n```\nThe following example shows the initial detect intent request and response using REST:\n```\nHTTP method and URL:\nPOST https://REGION_ID-dialogflow.googleapis.com/v3/projects/PROJECT_ID/locations/LOCATION_ID/agents/AGENT_ID/sessions/SESSION_ID:detectIntent\n{\n \"queryInput\": {\n \"text\": {\n  \"text\": \"what is the weather in Mountain View\"\n },\n \"languageCode\": \"en\"\n }\n}\n```\n```\n{\u00a0 \"queryResult\": {\u00a0 \u00a0 \"text\": \"what is the weather in Mountain View\",\u00a0 \u00a0 \"languageCode\": \"en\",\u00a0 \u00a0 \"responseMessages\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"source\": \"VIRTUAL_AGENT\",\u00a0 \u00a0 \u00a0 \u00a0 \"toolCall\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"tool\": \"<tool-resource-name>\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"action\": \"get-weather-tool\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"inputParameters\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"location\": \"Mountain View\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\nThe following example shows the second detect intent request, which provides the tool result:\n```\n{\u00a0 \"queryInput\": {\u00a0 \u00a0 \"toolCallResult\": {\u00a0 \u00a0 \u00a0 \"tool\": \"<tool-resource-name>\",\u00a0 \u00a0 \u00a0 \"action\": \"get-weather-tool\",\u00a0 \u00a0 \u00a0 \"outputParameters\": {\u00a0 \u00a0 \u00a0 \u00a0 \"temperature\": 28.0\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 },\u00a0 \u00a0 \"languageCode\": \"en\"\u00a0 }}\n```\n### Client side execution\nLike function tools, OpenAPI and data store tools can be executed on the client side by applying an API override when interacting with the session.\nFor example:\n```\nDetectIntentRequest {\u00a0 ...\u00a0 query_params {\u00a0 \u00a0 playbook_state_override {\u00a0 \u00a0 \u00a0 playbook_execution_mode: ALWAYS_CLIENT_EXECUTION\u00a0 \u00a0 }\u00a0 }\u00a0 ...}\n```\nThe process is as follows:\n- Your client code sends a detect intent request that specifies client execution.\n- The playbook agent detects that a tool is required, and the detect intent response contains the name of the tool along with input arguments. This session is paused until another detect intent request is received with the tool result.\n- Your client code calls the tool.\n- Your client code sends another detect intent request that provides the tool result as output arguments.", "guide": "Dialogflow"}