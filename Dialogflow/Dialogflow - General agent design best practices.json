{"title": "Dialogflow - General agent design best practices", "url": "https://cloud.google.com/dialogflow/cx/docs/concept/agent-design", "abstract": "# Dialogflow - General agent design best practices\nThis guide provides general best practices for designing all types of agents.\nYou should also see the [voice agent design](/dialogflow/cx/docs/concept/voice-agent-design) guide specifically for designing voice agents, and the [best practices](/dialogflow/cx/docs/concept/best-practices) guide for using the Dialogflow service.\n", "content": "## General advice\n### Build agents iteratively\nIf your agent will be large or complex, start by building a dialog that only addresses the top level requests. Once the basic structure is established, iterate on the conversation paths to ensure you're covering all of the possible routes an end-user may take.\nWhile your agent evolves, consider using the [test cases](#test) feature for test driven development.\n### Prebuilt agents\nDialogflow offers agent templates to help you get started. [Prebuilt agents](/dialogflow/cx/docs/concept/agents-prebuilt) cover common use-cases like financial services, telecommunications, and travel. These agents come with intents and entities to cover the most common user queries. Add routes and fulfillment specific to your business, and you'll quickly build a functioning agent.\n## Integrations and connecting your services\nThere are multiple ways to integrate with Dialogflow agents. This section provides best practices for choosing how to integrate.\n### Integrations\nDialogflow [integrations](/dialogflow/cx/docs/concept/integration) provide a ready-to-use user interface for your agent. If you use an integration, you do not need to directly call the Dialogflow API, as integrations handle this for you. These integrations can provide a text agent that you can embed on your website, connect with other messaging platforms, or provide a telephony interface.\n### Dialogflow API\nIf none of the ready-to-use integrations are suitable, or you would like to customize the interface for your system, you can [use the Dialogflow API directly](/dialogflow/cx/docs/reference/api-overview) . With this approach, you will need to implement the user interface for your agent, or make use of an existing user interface.\n### Webhooks\nUnless your agent can be completely defined with static data, you need to use [webhooks](/dialogflow/cx/docs/concept/webhook) to connect your service and provide an agent that can handle dynamic scenarios. This applies whether you are using integrations or the Dialogflow API.\n## Agent resources\nDialogflow agent resources can be used in many ways to achieve a desired result. This section provides advice for choosing the right resources for the right scenarios.\n### Flows and pages\n[Flows](/dialogflow/cx/docs/concept/flow) and [pages](/dialogflow/cx/docs/concept/page) provide structure to your agent. You can think of pages as nodes in a state machine, and flows as groups of related pages. You control transitions between nodes with [state handlers](/dialogflow/cx/docs/concept/handler) , which are called when an intent is matched, a condition is met, or an event is invoked.\nA simple agent may work fine with a single flow, but complex agents are almost always better designed with multiple flows. Each flow should represent a high level topic for your agent, where each page associated with the flow helps to handle the topic. In addition, each flow can have some of its own settings, and it can be [owned](/dialogflow/cx/docs/concept/access-control) by a subset of team members, which helps to divide the work when designing large agents.\nWhen designing a large, complex agent, you need to consider the [\"flows per agent\" and \"pages per flow\" limits](/dialogflow/quotas#count_limits) . These limits help to keep your agent performant.\nIf your agent design has too many flows per agent, combine related topics in a single flow. For example, you could combine the following topics to a single \"Get balance\" flow:\n- Get checking balance\n- Get savings balance\n- Get mortgage balance\n- Get credit balance\nIf your agent design has too many pages per flow, combine related pages and make use of many [routes](/dialogflow/cx/docs/concept/handler#route) per page.\nIf you are still having difficulty with flow and page limits, it may be because you have too much business logic built into the agent itself. Consider moving this logic to webhooks.\nThe following lists the conversation control granularity of agent resources in increasing granularity order:\n- Agents (one agent handles all conversations)\n- Flows (one flow handles one or more related conversation topics)\n- Pages (one page handles one or more related conversation turns)\n- Routes (one route handles a user intent or condition check)\n### Intent parameters versus form parameters\nThe main way in which your system gets structured data from the end-user is with [parameters](/dialogflow/cx/docs/concept/parameter) . You can use parameters for either [intents](/dialogflow/cx/docs/concept/intent) ( [intent parameters](/dialogflow/cx/docs/concept/parameter#intent) ) or [pages](/dialogflow/cx/docs/concept/page) ( [form parameters](/dialogflow/cx/docs/concept/parameter#form) ).\nThe main purpose of some pages is to collect specific information from the end-user. For example, a page may be designed to collect the end-user's contact information. In this case, you should always use form parameters to collect this information.\nIn some cases, you may want to capture end-user information while transitioning from one page to another. For example, if the end-user requests a particular product at the beginning of the conversation, you want to capture the desired product while transitioning to the appropriate order page. In this case, use intent parameters as part of [intent routes](/dialogflow/cx/docs/concept/handler#route) .\nThere are also situations in which using both intent parameters and form parameters is ideal. For example, if the end-user requests a small shirt at the beginning of the conversation, you want to capture the desired size parameter (small) while transitioning to the shirt order page. The shirt order page may ask for additional information, like the desired color. The shirt order page should have form parameters for size and color. In this example, the size parameter has already been provided and is [propagated](/dialogflow/cx/docs/concept/parameter#prop) , so the agent will only request the color. However, other conversations may follow a different path, where the end-user has not provided the desired size when the shirt order page becomes active. By defining this parameter in both ways, your agent is more flexible with how it extracts the information.\n### Routes and route groups\nIf you want to transition to another page, queue a response message, or call a webhook when an [intent](/dialogflow/cx/docs/concept/intent) is matched or a [condition](/dialogflow/cx/docs/reference/condition) is met, use [routes](/dialogflow/cx/docs/concept/handler#route) .\nIf you find yourself using the same set of routes on multiple pages, use [route groups](/dialogflow/cx/docs/concept/handler#route-group) . This will avoid unnecessary duplication in your agent design.\n### Intent reuse\nIf you find yourself defining multiple intents with similar training phrases, consider reusing intents across multiple pages. Ideally, you should define some general purpose intents that are used in many pages, and some specific intents that are only used in a single page. This will avoid unnecessary duplication in your agent design.\nFor example, confirmation intents are typically best defined as reusable intents. A `confirmation.yes` intent could have training phrases like:\n- yes\n- yeah\n- yep\n- okay\n- yes I do\n- you bet\n- absolutely\n- yes please\nA `confirmation.no` intent could have training phrases like:\n- no\n- nah\n- nope\n- no way\n- not for me\n- absolutely not\n- no thank you\nThese reusable confirmation intents can be used in many scenarios for your agent.\nIn some cases, you should also consider creating specialized confirmation intents. For example, when confirming an order, you may want to have a specialized `order.confirmation.yes` intent with training phrases like:\n- the order looks good to me\n- I accept this order\nAnd, a specialized `order.confirmation.no` intent with training phrases like:\n- I do not want this order\n- I do not accept this order\nWhen your order confirmation page is active, intent routes for all four of these intents should be in scope. This ensures that any generic or specific confirmation from the end-user will get handled appropriately.\n### Default negative intent\nYou should populate the [default negative intent](/dialogflow/cx/docs/concept/intent#negative) with phrases that your end-users might say, but should not match any intent in your agent.\n### Fulfillment\nThere are many options for using [fulfillment](/dialogflow/cx/docs/concept/fulfillment) to respond to the end-user. During a conversation turn, the agent can append multiple messages to the response queue, and the concatenated queue is sent to the end-user at the end of the conversation turn. This section describes each option for creating the individual messages.\n- [Page entry fulfillment](/dialogflow/cx/docs/concept/page#use) : This fulfillment is called when the page initially becomes active. It is useful when you want a message that describes the purpose of the page, and it should only be said once while the page is active. For example:- What do you want to know about your checking account?\n- What type of product would you like to purchase?\n- I need to collect some information about the shirt you want to order.\n- [Routes](/dialogflow/cx/docs/concept/handler#route) : This fulfillment is called when either an intent route or a condition route with fulfillment is called. This is useful when you want a message that responds to the end-user about the intent match, the satisfied condition (which may be a [form filling completion condition](/dialogflow/cx/docs/concept/parameter#form-ref) ), or the transition. For example:- Yes, your international plan includes Japan. (intent match)\n- Are you sure you would like to purchase 300 shirts? ( [comparison condition](/dialogflow/cx/docs/reference/condition#comp) met)\n- Okay, your appointment is for 7 AM tomorrow morning. (form filling completion)\n- Okay, let's talk about aardvarks now. (transition)\n- [Event handlers](/dialogflow/cx/docs/concept/handler#event) : This fulfillment is called when an event is invoked. It is useful when you want a message that responds to the event. For example:- The stock you are considering for purchase has just increased in value by 10%. (custom event)\n- Can you rephrase that? ( [no-match event](/dialogflow/cx/docs/concept/handler#event-built-in) )\n- [Initial prompts for forms](/dialogflow/cx/docs/concept/parameter#form) : This fulfillment is called when the agent performs form filling. These messages should ask the end-user a specific question. Each form parameter has its own initial prompt fulfillment. For example:- What size shirt would you like?\n- What color shirt would you like?\n- [Reprompt handlers for forms](/dialogflow/cx/docs/concept/parameter#form-reprompt) : This fulfillment is called when the agent is performing form filling, and it does not understand the end-user selection for the current parameter. This fulfillment is only necessary if you would like a reprompt message to be different than the initial prompt message. If no reprompt handlers exist, the agent will just use the initial prompt as the reprompt message. For example:- I do not understand. Can you please supply a valid color for the shirt?\n## Naming\nThis section provides advice for naming agent resources.\n### Intent naming\nIf your agent has many [intents](/dialogflow/cx/docs/concept/intent) , you should consider a naming scheme that helps you keep them organized. It is common to segment intent names with punctuation, where the specificity increases from left to right. In addition, an intent name should reflect the end-user's intention for a conversational turn.\nThere are many good naming schemes, but here is one example:\n- phone-service.order.cancel\n- phone-service.order.create\n- phone-service.order.change\n- tv-service.order.cancel\n- tv-service.order.create\n- tv-service.order.change\n- account.balance.get\n- account.balance.pay\n- account.address.get\n- account.address.update## Transitions\n[Transitions defined in state handlers](/dialogflow/cx/docs/concept/handler) provide control over the conversation by changing the active page. This section provides advice for organizing your agent transitions.\n### Complimentary transitions\nWhen defining a route that triggers a transition, consider that there may be a complementary or inverse route.\nFor example:\n- If you have an intent route for **confirmation.yes** , consider defining another route for **confirmation.no** .\n- If you define a condition route with a boolean`=`operator, consider defining another route that uses`!=`.## Handling end-user input\nThis section provides guidelines for intents and training phrases, so your agent can optimally handle and process end-user input.\n### Define at least 20 training phrases\nYou should have at least 20 [training phrases](/dialogflow/cx/docs/concept/intent#tp) for every intent. Otherwise, the NLU model may not have enough information to appropriately match your intent. This is a bare minimum guideline. Ideally, you should define more, especially for [head intents](/dialogflow/cx/docs/concept/intent#head) of large agents, where roughly 50 is desirable.\n### Be aware of intent bias\nWhen one or more intents have significantly more training phrases than other intents, this causes the NLU model to bias in favor of the larger intents due to [imbalanced data](https://developers.google.com/machine-learning/data-prep/construct/sampling-splitting/imbalanced-data) . This intent bias can happen when the quantity of training phrases differs by an order of magnitude or more.\nIn some cases, this is desired behavior, because you might define some intents that should be matched more often than others, because they correspond to end-user inputs more frequently observed in live traffic.\nIn other cases, this behavior may be undesirable, because you do not want a bias in favor of these larger intents. If this is the case, reduce the number of training phrases for these larger intents to be of the same order of magnitude as other intents. For example:\n| Intent A training phrases | Intent B training phrases | Bias for intent B |\n|----------------------------:|----------------------------:|:--------------------|\n|       20 |       50 | No     |\n|       20 |       200 | Borderline   |\n|       20 |      2000 | Yes     |\n### Entity use and training phrase quantity\nFor all entity types used in an intent:\n- Annotate every example of the entity types.\n- For each of the entity types, provide at least five training phrases containing annotated examples.\n- Provide at least three times as many training phrases as entity types. For example, if you use 10 different entity types for annotations in an intent, you should have at least 30 training phrases.\n### Training phrases should be natural\nTraining phrases should be conversational and natural; they should match what people actually say. Whenever possible, use end-user inputs that have occurred in production as your training data, paying special attention to those that are most common.\n### Necessary training phrase variety\nInclude variations of questions, commands, verbs, and synonyms for common nouns to ensure your phrases cover a broad spectrum of possible requests.\nIt is best to include some shorter phrases like \"pay my bill\", as well as longer phrases and sentences like \"I just got something in the mail that says I need to pay my statement balance\". There is no recommended proportion of short to long phrases, but you should base this on actual end-user inputs sent to your agent in production.\nDefining training phrases that vary in length, phrasing, and sentence structure is important to ensure good training for your agent. It is not necessary to add variety for variety's sake, but it is necessary to provide enough variety that the NLU model can successfully detect the end-user's intent from a wide range of end-user inputs. If you don't have sufficient variety, there is a danger of overfitting. In other words, there is a danger that the model will be too closely tied to the particular examples you provide and won't generalize sufficiently to other examples.\n### Capitalization variety\nIn rare cases, you may need to add training phrases that vary only in capitalization. This usually applies to situations when you expect end-users to provide all-uppercase text inputs.\nAlternative approaches could be:\n- Lowering the [ML classification threshold](/dialogflow/cx/docs/concept/agent#settings-ml) \n- Lowercasing end-user inputs before sending them to Dialogflow\n### Unnecessary training phrase variety\nAvoid trivial variation in training phrases, as they provide duplicate information to the NLU model. For example, do not include variants that differ only by:\n- **Capitalization** (except [rare cases](#phrase-capitalization-variety) ): For example, \"Order a ticket\" and \"order a ticket\".\n- **Filler words** : For example, \"okay, order a ticket\" and \"order a ticket\".\n- **Punctuation** : For example, \"can you please help?\" and \"can you please help!?\"\n### Annotation consistency\nThe training phrase part selected for an annotation should include all of, and no more than, the text that is necessary to match an entity. Also, ensure that similar parts of training phrases are annotated for the entire intent.\nFor example, the following table shows good and bad ways to annotate with the `@sys.date` system entity:\n| Good     | Bad      |\n|:------------------------|:------------------------|\n| September 7th departure | September 7th departure |\n| Leaving on July 4  | Leaving on July 4  |\n### Use semantically meaningful annotations for system entities\nThe semantic meaning of a training phrase part selected for an annotation can be affected by the rest of the text in a training phrase. For example:\n| Annotated training phrase   | Semantic meaning of annotated text |\n|:----------------------------------|:-------------------------------------|\n| I am 7 years old     | A person's age      |\n| The contract is valid for 7 years | A time duration      |\nDialogflow's machine learning models consider semantic meaning when matching system entities. The semantic meaning of the training phrase part must match the intended semantic meaning of the system entity.\nFor example, do not use the `@sys.duration` system entity for annotation of the first \"7 years\" example above. The semantic meaning of \"7 years\" does not match a simple time duration. Instead, you should select \"7\" for the annotation and use the `@sys.number` system entity.\n### Define intents to handle non-compliant form filling answers\nConsider defining intents to handle non-compliant form filling answers. For example, your agent may ask \"what's your travel dates?\", followed by the end-user answer of \"I don't know yet\". This answer does not satisfy the form parameter prompt, but if your agent has an intent route in scope that can match this answer, your agent can handle the situation well.\n### Avoid @sys.any\nAvoid using the `@sys.any` system entity type. It should only be used if you have completely exhausted all avenues, including building custom entities. This entity type is very broad and can cause undesired behavior.\nIf you do use this entity type, avoid annotating multiple parts of a single training phrase with this entity type, as this creates an ambiguity, and the agent behavior will be undefined.\nIt is less dangerous to use `@sys.any` with form parameters, because the agent is expecting specific information when prompting for form parameters.\n**Note:** Some system entities are not available when you regionalize your agent deployment, and `@sys.any` is sometimes recommended as a workaround.\n### Annotations should include a variety of entity values\nWhen defining annotated training phrases, you should use a variety of entity value examples in the phrases. You should not consistently use the same entity example for the annotations. The following example shows good and bad annotations for a product entity type:\n| Good     | Bad     |\n|:-----------------------|:-----------------------|\n| I want to buy a shirt | I want to buy a shirt |\n| Order a new hat  | Order a new shirt  |\n| Add a watch to my cart | Add a shirt to my cart |\n### Custom entities should include variety\nCustom entities should cover a broad range of examples. The NLU model will provide variety for grammatical forms, but you must include all possible items.\n### Avoid entities that match aggressively\nDo not define entities that match virtually anything. This degrades the performance and quality of ML. Nearly everything in every training phrase will be evaluated as a possible match.\n### Map and list entities should focus on distinct values\nMap and list entity types should have a limited scope that captures distinct values of one type of information. Keep your entities focused, short, and simple.\nIf your entity values are complicated, it may be because intent training phrases are better suited to your situation. For example, consider end-user input like:\n- \"How can I make an international call with Plan A?\"\n- \"Using international data roaming with Plan B.\"\nDo not create entity types for both the actions and the plans, like the following:\n| Actions entity type     | Plans entity type |\n|:---------------------------------------|:--------------------|\n| \"How can I make an international call\" | \"Plan A\"   |\n| \"Using international data roaming\"  | \"Plan B\"   |\nInstead, you should use training phrases and intent matching to capture the actions and entities to capture the plans.\n### Use regexp entities to capture non-word identifiers\nWhen capturing end-user input that involves non-word identifiers, you should use [regexp entities](/dialogflow/cx/docs/concept/entity-regexp) . For example, to capture product IDs like \"AA-256\" or \"AC-436\", use a regexp entity like \"[A-Z]{2}-\\d{3}\".\n### Avoid nesting composite entities\nDo not use more than one level of nesting in composite entities. Each level of nesting significantly degrades quality.\n### Avoid similar intents\nEach intent should capture the end-user intention. If you define different intents with similar training phrases, matching may be unreliable, because the NLU model cannot determine with sufficient confidence, which intent to match.\nIf two training phrases represent the same intention, they should belong to the same intent. For example, \"change current bill due date\" and \"more time to pay\" should both belong to the same intent, because they are both requesting a due date change. However, \"Can I make an international call with Plan A?\" and \"Can I use international data roaming with Plan A?\" could belong to different intents, because the end-user wants a different thing in each case.\n### Avoid similar entity types\nYou should avoid defining multiple entity types that have similar entity entries, because this can lead to ambiguity for the NLU model.\n### Use no-match events in production to improve your intents\nWhen running your agent in production, it is inevitable that some end-user inputs will result in [no-matches events](/dialogflow/cx/docs/concept/handler#event-built-in) . You can use these opportunities to improve your agent in one of three ways:\n- Add the end-user input as a training phrase to the desired intent. However, this is not always the best option. If you do this many times for the intent, it might lead to [intent bias](#intent-bias) .\n- Cleanup the training phrases for the desired intent, so that they all accurately reflect the intention. In some cases, intents with training phrases that are divergent can prevent matching for the intent.\n- If intents that should not be matched for the end-user input have training phrases that could match the end-user input, delete these training phrases.\n### Avoid special characters\nSpecial characters in training phrases ( `{` , `_` , `#` , `[` , and so on) are ignored. An exception to this is for emoticons, where they work as expected.\n### Avoid filler words\nFiller words are words that you can ignore and still be able to understand the text. For example:\n- please\n- can you please\n- hmmm\n- how about\nIt is unnecessary but harmless to use filler words in training phrases, because these are ignored by the NLU model. However, you should not define training phrases that vary only by filler words.\nNever define entities that are composed of filler words.\n### Experiment with ML settings\nThe [ML settings](/dialogflow/cx/docs/concept/agent#settings-ml) can be used to adjust how end-user input is processed. In most cases, the default settings work well. However, you may want to fine-tune the settings to improve your agent performance.\n## Responding to the end-user\nThis section provides guidelines for using fulfillment to respond to the end-user.\n### Welcome the end-user\nA newly created agent has an automatically created intent route for the [welcome intent](/dialogflow/cx/docs/concept/intent#welcome) . You should edit this route to include a fulfillment message that welcomes the end-user. This message should describe the agent and give the end-user a sense for what it is capable of.\n### Acknowledge end-user information\nIt is often best to repeat information provided by the end-user in responses. This lets the end-user know that the agent is understanding their request.\nWhen an intent is matched, and a transition occurs, let the end-user know that the conversation is progressing based on their request. For example:\n| Dialogue                             | Description                                                                 |\n|:----------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| End-user: I have questions about my checking account. Agent: Okay, what would you like to know about your checking account? | The end-user input resulted in an intent match, and a route was followed which included a fulfillment message and a transition to a page that handles checking account questions. Note that the agent confirms that the end-user wants to know about their checking account. |\nWhen form filling has completed, repeat the data provided by the end-user. For example:\n| Dialogue                           | Description                                      |\n|:-------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| End-user: Tomorrow Agent: Okay, your haircut is scheduled for tomorrow at 7 PM. Can I help you with anything else? | The end-user provided the date form parameter, which was the last form parameter on the active page. The agent confirmed the time and date of a scheduled haircut. |\n### Guide the conversation\nThe agent should always guide the conversation with the end-user. This is easily accomplished by ending each response with a question like:\n- Can I help you with anything else?\n- What do you want to know about beagles?\n- Would you like to cancel or submit that order?\n- What can I help you with today?\n- Are you traveling alone or with somebody?\nWhen defining these questions, be careful to avoid asking multiple questions like:\n- Are you still here? What service are you inquiring about?\n- Do you still want this order? Do you want to add anything?\nThe end-user may respond to just one of the questions, and your agent may not handle that situation correctly.\n## Handling errors and unexpected end-user input\nThis section provides advice on handling errors and unexpected end-user input.\n### Create event handlers for built-in events\nYou should create event handlers for the [built-in events](/dialogflow/cx/docs/concept/handler#event-built-in) as applicable. Handling these events is similar to catching exceptions in software programming. Depending on the situation, you may want to handle the events with parameter-specific event handlers, page-specific event handlers, or flow-specific event handlers.\n### Handle webhook errors\nWhen your webhook service fails, it is important that your agent can gracefully handle the failure. You achieve this by defining event handlers for the webhook-specific [built-in events](/dialogflow/cx/docs/concept/handler#event-built-in) . Here is a recommended approach to handling webhook errors:\n- Do not supply a transition target from the [state handler](/dialogflow/cx/docs/concept/handler) that triggers the [webhook call](/dialogflow/cx/docs/concept/fulfillment#webhook) , otherwise, the webhook error event handler will not be invoked. Instead, set the transition target in the webhook response from the webhook service.\n- Choose a page where an error counter can be initialized to zero. This page should be active before the page that triggers a webhook call. The entry fulfillment for this page should initialize the error counter to `0` using a [fulfillment parameter preset](/dialogflow/cx/docs/concept/fulfillment#param-preset) . For example:| Parameter   | Value |\n|:--------------------|--------:|\n| webhook-error-count |  0 |\n- Create a webhook error page that handles webhook error events:- The entry fulfillment should acknowledge the failure for the end-user, and it should increment an error counter session parameter using a [fulfillment parameter preset](/dialogflow/cx/docs/concept/fulfillment#param-preset) . For example:| Parameter   | Value             |\n|:--------------------|:------------------------------------------------------|\n| webhook-error-count | $sys.func.ADD($session.params.webhook-error-count, 1) |\n- Define a [condition route](/dialogflow/cx/docs/concept/handler#route) that has a condition that the error count is less than the maximum allowed. (for example, `$session.params.webhook-error-count <= 3` ). This route should have fulfillment that notifies the end-user that the agent will retry. This route should have a transition target set to [PREVIOUS_PAGE](/dialogflow/cx/docs/concept/handler#symbolic) , or to any page that can make another attempt to call the webhook.\n- Define a condition route that has a condition that the error count is greater than the maximum allowed (for example, `$session.params.webhook-error-count > 3` ). This route should have fulfillment that notifies the end-user that the agent will no longer retry. This route should have a transition target set to a page that will not trigger webhook retries.\n- The webhook event handler should have a transition target that transitions to the webhook error page.## Tools\nThis section provides advice on using tools to improve agent design.\n### Use the validation tool\nYou should always use the [validation tool](/dialogflow/cx/docs/concept/validation) to check your agent. This tool finds some of the issues described in this guide.\n### Use the test cases feature\nYou should always define [test cases](/dialogflow/cx/docs/concept/test-case) for your agent. These test cases can help prevent regressions while your agent evolves to handle more scenarios.", "guide": "Dialogflow"}