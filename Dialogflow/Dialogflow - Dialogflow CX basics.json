{"title": "Dialogflow - Dialogflow CX basics", "url": "https://cloud.google.com/dialogflow/cx/docs/basics", "abstract": "# Dialogflow - Dialogflow CX basics\nThis document describes the basics of using Dialogflow CX. It provides an overview of the most important concepts.\n", "content": "## Agents\nA [Dialogflow CX agent](/dialogflow/cx/docs/concept/agent) is a virtual agent that handles concurrent conversations with your end-users. It is a natural language understanding module that understands the nuances of human language. Dialogflow translates end-user text or audio during a conversation to structured data that your apps and services can understand. You design and build a Dialogflow agent to handle the types of conversations required for your system.\nA Dialogflow agent is similar to a human call center agent. You train them both to handle expected conversation scenarios, and your training does not need to be overly explicit.\n## Flows\nComplex dialogs often involve multiple conversation topics. For example, a pizza delivery agent may have , , and as distinct topics. Each topic requires multiple conversational turns for an agent to acquire the relevant information from the end-user.\n[Flows](/dialogflow/cx/docs/concept/flow)\n[Default Start Flow](/dialogflow/cx/docs/concept/flow#start)\nDialogflow CX flows serve a similar purpose as sub-agents for [Dialogflow ES mega agents](/dialogflow/docs/agents-mega) . Flows provide better conversation control, and they do not incur additional cost.\n## Pages\nA Dialogflow CX conversation (session) can be described and visualized as a [state machine](https://en.wikipedia.org/wiki/Finite-state_machine) . The states of a CX session are represented by [pages](/dialogflow/cx/docs/concept/page) .\nFor each [flow](/dialogflow/cx/docs/concept/flow) , you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the , the current page is considered , and the flow associated with that page is considered . Every flow has a special [start page](/dialogflow/cx/docs/concept/flow#start-page) . When a flow initially becomes active, the start page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page.\nYou configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For example, you might create the pages (in blue) in the diagram below for a flow of a pizza delivery agent. The node of the diagram represents the start page of the flow. When the flow is complete, it transitions to the flow.\n## Entity types\n[Entity types](/dialogflow/cx/docs/concept/entity)\n[ES entity types](/dialogflow/es/docs/entities-overview)\nDialogflow provides predefined [system entities](/dialogflow/cx/docs/concept/entity-system) that can match many common types of data. For example, there are system entities for matching dates, times, colors, email addresses, and so on. You can also create your own [custom entities](/dialogflow/cx/docs/concept/entity-custom) for matching custom data. For example, you could define a vegetable entity that can match the types of vegetables available for purchase with a grocery store agent.\n## Parameters\n[Parameters](/dialogflow/cx/docs/concept/parameter)\n[entity type](/dialogflow/cx/docs/concept/entity)\nCX parameters are similar to [ES parameters](/dialogflow/docs/intents-actions-parameters) , but the utility and scope has been expanded, and the syntax to reference parameters has changed.\n## Forms\nFor each page, you can define a [form](/dialogflow/cx/docs/concept/parameter#form) , which is a list of parameters that should be collected from the end-user for the page. The agent interacts with the end-user for multiple conversation turns, until it has collected all of the required , which are also known as . The agent collects these parameters in the order defined on the page. For each required form parameter, you also provide that the agent uses to request that information from the end-user. This process is called .\nFor example, you might create a form that collects the end-user's name and telephone number for a `Collect Customer Info` page.\nCX form filling is similar to [ES slot filling](/dialogflow/docs/intents-actions-parameters#required) .\n## Intents\nAn [intent](/dialogflow/cx/docs/concept/intent) categorizes an end-user's intention for one conversation turn. Compared to [ES intents](/dialogflow/docs/intents-overview) , CX intents have been simplified to make them a more reusable resource.\nAn intent contains the following data:\n| Term    | Definition                                                                                |\n|:-----------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Display name  | Name displayed on the console for the intent.                                                                       |\n| Labels   | Labels that help categorize intents. For example: head intent.                                                                   |\n| Training phrases | Training phrases are example phrases for what end-users might type or say, known as end-user input. When end-user input resembles one of these phrases, Dialogflow matches the intent. You don't have to define every possible example, because Dialogflow's built-in machine learning expands on your list with other, similar phrases. |\n| Parameters  | You define your training phrases to use parameters to extract values from specific parts of the end-user input.                                                       |\n## Webhook\n[Webhooks](/dialogflow/cx/docs/concept/webhook)\nA webhook can either be a or a . With a standard webhook, the request and response fields are defined by Dialogflow. With a flexible webhook, you define the request and response fields.\n## Fulfillment\nFor an agent's conversational turn, the agent must respond to the end-user with an answer to a question, a query for information, or session termination. Your agent may also need to contact your service to generate dynamic responses or take actions for a turn. [Fulfillment](/dialogflow/cx/docs/concept/fulfillment) is used to accomplish all of this.\nA fulfillment may contain any of the following:\n- Static response messages.\n- Webhook calls for dynamic responses and/or to take actions.\n- Parameter presets to set or override parameter values.\nDuring an agent's turn, it is possible (and sometimes desirable) to call multiple fulfillments, each of which may generate a response message. Dialogflow maintains these responses in a . Once the agent's turn is over, Dialogflow sends the ordered responses to the end-user.\n[ES fulfillment](/dialogflow/docs/fulfillment-overview) is limited to connecting a webhook service. The scope of fulfillment has been increased for CX, so it now covers all types of prompts and responses.\n## State handlers\n[State handlers](/dialogflow/cx/docs/concept/handler)\n| Term      | Definition                                                 |\n|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Handler requirements  | These are the requirements that must be satisfied for the handler to have any effect on the session. A handler is said to be called when it satisfies its requirements and affects the session in some way. |\n| Handler fulfillment  | If a handler is called, an optional fulfillment is used to create responses for end-users. These responses are either defined in static agent data or retrieved dynamically from your webhook service.  |\n| Handler transition target | If a handler is called, an optional transition target is used to change the current page. The next page can only be a flow start page or a page within the currently active flow.       |\nThere are two types of state handlers with differing handler requirements:\n| Term   | Definition                                                               |\n|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Routes   | Routes are called when an end-user input matches an intent and/or some condition on the session status is met. A route with an intent requirement is also called an intent route. A route with only a condition requirement is also called a condition route.   |\n| Event handlers | Event handlers are called when an event is invoked. Some built-in events are triggered when unexpected end-user input is received, or when a webhook error occurs. You can also define custom events that you invoke when something happens outside the conversation. |\nThere are three steps to processing a state handler:\n| Term   | Definition                                                                            |\n|:--------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1. Scope  | A handler must be in scope to have any effect on the session. The scope is determined by whether a handler is applied to a flow, a page, or a form parameter; and by whether the associated flow is active, the associated page is active, or the agent is currently attempting to fill the associated form parameter. |\n| 2. Evaluation | Each handler in scope is evaluated in order. If a handler's requirements are met, it passes evaluation.                                                    |\n| 3. Call  | If a handler is in scope and passes evaluation, it is called. Any associated fulfillment is called, and any associated transition target is applied to the session.                                     |\n## Regionalization and location settings\nWhen you create an agent, you must specify a [region](/dialogflow/cx/docs/concept/region#avail) as the agent's location. Requests sent to your agent are handled by Google services in this region and Dialogflow keeps [data-at-rest](https://en.wikipedia.org/wiki/Data_at_rest) physically within the geographical [region or location](/about/locations) . For the best performance, you should choose a region that is near your services and end-users.\nOnce an agent is created, its location cannot change. In order to change an agent's location, you must [export and restore](/dialogflow/cx/docs/concept/agent#export) to a new agent with a different location.\nEach location has associated settings that apply across your project. In most cases, you do not need to edit these location settings, and the default settings will work well. If your system requires [customer-managed encryption keys](/dialogflow/cx/docs/concept/cmek) (often required by government entities or regulated industries), read more about [location settings](/dialogflow/cx/docs/concept/region#location-settings) .\n## Console\nDialogflow provides a web user interface called the Dialogflow CX Console ( [visit documentation](/dialogflow/cx/docs/concept/console) , [open console](https://dialogflow.cloud.google.com/cx/projects) ). You use this console to create, build, and test CX agents. The CX Console has a similar purpose as the [ES Console](/dialogflow/docs/console) , but the CX Console user interface is much more visual. It graphs each flow as a conversational state machine diagram, which makes complex agents easier to design and understand.\nThe Dialogflow CX Console is different from the Google Cloud Platform (GCP) Console ( [visit documentation](https://support.google.com/cloud/answer/3465889?hl=en&ref_topic=3340599) , [open console](https://console.cloud.google.com/) ). The Dialogflow CX Console is used to manage Dialogflow CX agents, while the GCP Console is used to manage GCP-specific Dialogflow CX settings (for example, billing) and other GCP resources.\nIn most cases you should use the Dialogflow CX Console to build agents, but you can also use the Dialogflow CX API to build agents for advanced scenarios.\n## Integrations\nDialogflow CX currently provides several built-in [integrations](/dialogflow/cx/docs/concept/integration) with other conversation platforms. These integrations provide a user interface to the end-user, and they call the Dialogflow API for you. All you need to do is build your agent and optionally implement a [webhook](/dialogflow/cx/docs/concept/webhook) service. Each integration handles interactions in a platform-specific way, so see the specific integration documentation for details.\n## Interactions\nFor each conversational turn, an takes place. During an interaction, an end-user sends input to Dialogflow, and Dialogflow sends a response. You have two options when implementing your system to handle interactions: using the API or using an integration.\nWhen [using the API](/dialogflow/cx/docs/quick/api) , your system needs to handle the following:\n- Build an agent.\n- Provide a user interface for end-users.\n- Call the Dialogflow API for each conversational turn to send end-user input to the API.\n- Unless your agent responses are purely static (uncommon), you need to host a [webhook service](/dialogflow/cx/docs/concept/webhook) to handle webhook-enabled [fulfillment](/dialogflow/cx/docs/concept/fulfillment) .\nWhen using an [integration](/dialogflow/cx/docs/concept/integration) , your system only needs to handle the following:\n- Build an agent.\n- Optionally implement a webhook service.\nThe following diagram shows the steps that take place for one conversational turn of a session.\n**Note:** Communications between your systems and integrations, and Dialogflow are [encrypted in transit](/docs/security/encryption-in-transit) . Also, Google internal component communications are encrypted using [Application Layer Transport Security (ALTS)](/docs/security/encryption-in-transit/application-layer-transport-security) .- The end-user types or says something, known as.\n- Your user interface or integration system receives the input and forwards it to the Dialogflow API in a detect intent request.\n- The Dialogflow API receives the detect intent request. It matches the input to an intent or form parameter, sets parameters as needed, and updates session state. If it needs to call a webhook-enabled fulfillment, it sends a webhook request to your webhook service, otherwise, go to step 6.\n- Your webhook service receives the webhook request. Your service takes any actions necessary, like calling external APIs, querying or updating a database, etc.\n- Your webhook service builds a response and sends a webhook response back to Dialogflow.\n- Dialogflow creates a detect intent response. If a webhook was called, it uses the response provided in the webhook response. If no webhook was called, it uses the static response defined in the agent. Dialogflow sends a detect intent response to your user interface or integration system.\n- Your user interface or integration system receives the detect intent response and forwards the text or audio response to the end-user.\n- The end-user sees or hears the response.", "guide": "Dialogflow"}