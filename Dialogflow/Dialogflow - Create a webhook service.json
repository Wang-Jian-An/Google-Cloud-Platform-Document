{"title": "Dialogflow - Create a webhook service", "url": "https://cloud.google.com/dialogflow/cx/docs/tutorials/deploy/webhook", "abstract": "# Dialogflow - Create a webhook service\nThe prebuilt agent you created in the last step requires a [webhook](/dialogflow/cx/docs/concept/webhook) . [Cloud Functions](/functions/docs) are used to host the webhook in this tutorial due to their simplicity, but there are many other ways that you could host a webhook service. The example also uses the Go programming language, but you can use any [language supported by Cloud Functions](/functions/docs/concepts/exec) .\n", "content": "## Create the Function\nCloud Functions can be created with the Google Cloud console ( [visit documentation](https://support.google.com/cloud/answer/3465889?ref_topic=3340599) , [open console](https://console.cloud.google.com/) ). To create a function for this tutorial:\n- It is important that your Dialogflow agent and the function are both in the same project. This is the easiest way for Dialogflow to have [secure access to your function](/dialogflow/cx/docs/concept/webhook#gcf) . Before creating the function, select your project from the Google Cloud console. [Go to project selector](https://console.cloud.google.com/projectselector2/home/dashboard) \n- Open the Cloud Functions overview page. [Go to Cloud Functions overview](https://console.cloud.google.com/functions/list) \n- Click **Create Function** , and set the following fields:- **Environment** : 1st gen\n- **Function name** : tutorial-telecommunications-webhook\n- **Region** : If you specified a region for your agent, use the same region.\n- **HTTP Trigger type** : HTTP\n- **URL** : Click the copy button here and save the value. You will need this URL when configuring the webhook.\n- **Authentication** : Require authentication\n- **Require HTTPS** : checked\n- Click **Save** .\n- Click **Next** (You do not need special runtime, build, connections, or security settings).\n- Set the following fields:- **Runtime** : Select the latest Go runtime.\n- **Source code** : Inline Editor\n- **Entry point** : HandleWebhookRequest\n- Replace the code with the following:```\npackage cxtwhimport (\u00a0 \u00a0 \u00a0 \u00a0 \"context\"\u00a0 \u00a0 \u00a0 \u00a0 \"encoding/json\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"log\"\u00a0 \u00a0 \u00a0 \u00a0 \"net/http\"\u00a0 \u00a0 \u00a0 \u00a0 \"os\"\u00a0 \u00a0 \u00a0 \u00a0 \"strings\"\u00a0 \u00a0 \u00a0 \u00a0 \"cloud.google.com/go/spanner\"\u00a0 \"google.golang.org/grpc/codes\")// client is a Spanner client, created only once to avoid creation// for every request.// See: https://cloud.google.com/functions/docs/concepts/go-runtime#one-time_initializationvar client *spanner.Clientfunc init() {\u00a0 \u00a0 \u00a0 \u00a0 // If using a database, these environment variables will be set.\u00a0 \u00a0 \u00a0 \u00a0 pid := os.Getenv(\"PROJECT_ID\")\u00a0 \u00a0 \u00a0 \u00a0 iid := os.Getenv(\"SPANNER_INSTANCE_ID\")\u00a0 \u00a0 \u00a0 \u00a0 did := os.Getenv(\"SPANNER_DATABASE_ID\")\u00a0 \u00a0 \u00a0 \u00a0 if pid != \"\" && iid != \"\" && did != \"\" {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 db := fmt.Sprintf(\"projects/%s/instances/%s/databases/%s\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pid, iid, did)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Creating Spanner client for %s\", db)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var err error\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Use the background context when creating the client,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // but use the request context for calls to the client.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // See: https://cloud.google.com/functions/docs/concepts/go-runtime#contextcontext\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 client, err = spanner.NewClient(context.Background(), db)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Fatalf(\"spanner.NewClient: %v\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }}type fulfillmentInfo struct {\u00a0 \u00a0 \u00a0 \u00a0 Tag string `json:\"tag\"`}type sessionInfo struct {\u00a0 \u00a0 \u00a0 \u00a0 Session \u00a0 \u00a0string \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 `json:\"session\"`\u00a0 \u00a0 \u00a0 \u00a0 Parameters map[string]interface{} `json:\"parameters\"`}type text struct {\u00a0 \u00a0 \u00a0 \u00a0 Text []string `json:\"text\"`}type responseMessage struct {\u00a0 \u00a0 \u00a0 \u00a0 Text text `json:\"text\"`}type fulfillmentResponse struct {\u00a0 \u00a0 \u00a0 \u00a0 Messages []responseMessage `json:\"messages\"`}// webhookRequest is used to unmarshal a WebhookRequest JSON object. Note that// not all members need to be defined--just those that you need to process.// As an alternative, you could use the types provided by the Dialogflow protocol buffers:// https://pkg.go.dev/google.golang.org/genproto/googleapis/cloud/dialogflow/cx/v3#WebhookRequesttype webhookRequest struct {\u00a0 \u00a0 \u00a0 \u00a0 FulfillmentInfo fulfillmentInfo `json:\"fulfillmentInfo\"`\u00a0 \u00a0 \u00a0 \u00a0 SessionInfo \u00a0 \u00a0 sessionInfo \u00a0 \u00a0 `json:\"sessionInfo\"`}// webhookResponse is used to marshal a WebhookResponse JSON object. Note that// not all members need to be defined--just those that you need to process.// As an alternative, you could use the types provided by the Dialogflow protocol buffers:// https://pkg.go.dev/google.golang.org/genproto/googleapis/cloud/dialogflow/cx/v3#WebhookResponsetype webhookResponse struct {\u00a0 \u00a0 \u00a0 \u00a0 FulfillmentResponse fulfillmentResponse `json:\"fulfillmentResponse\"`\u00a0 \u00a0 \u00a0 \u00a0 SessionInfo \u00a0 \u00a0 \u00a0 \u00a0 sessionInfo \u00a0 \u00a0 \u00a0 \u00a0 `json:\"sessionInfo\"`}// detectCustomerAnomaly handles same-named tag.func detectCustomerAnomaly(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error) {\u00a0 \u00a0 \u00a0 \u00a0 // Create session parameters that are populated in the response.\u00a0 \u00a0 \u00a0 \u00a0 // This example hard codes values, but a real system\u00a0 \u00a0 \u00a0 \u00a0 // might look up this value in a database.\u00a0 \u00a0 \u00a0 \u00a0 p := map[string]interface{}{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"anomaly_detect\": \u00a0 \u00a0 \u00a0 \u00a0\"false\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"purchase\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"device protection\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"purchase_amount\": \u00a0 \u00a0 \u00a0 \"12.25\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"bill_without_purchase\": \"54.34\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"total_bill\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"66.59\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"first_month\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"January 1\",\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Build and return the response.\u00a0 \u00a0 \u00a0 \u00a0 response := webhookResponse{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SessionInfo: sessionInfo{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parameters: p,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return response, nil}// validatePhoneLine handles same-named tag.func validatePhoneLine(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error) {\u00a0 \u00a0 \u00a0 \u00a0 // Create session parameters that are populated in the response.\u00a0 \u00a0 \u00a0 \u00a0 // This example hard codes values, but a real system\u00a0 \u00a0 \u00a0 \u00a0 // might look up this value in a database.\u00a0 \u00a0 \u00a0 \u00a0 p := map[string]interface{}{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"domestic_coverage\": \u00a0 \"true\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"phone_line_verified\": \"true\",\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Build and return the response.\u00a0 \u00a0 \u00a0 \u00a0 response := webhookResponse{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SessionInfo: sessionInfo{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parameters: p,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return response, nil}// cruisePlanCoverage handles same-named tag.func cruisePlanCoverage(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error) {\u00a0 \u00a0 \u00a0 \u00a0 // Get the existing parameter values\u00a0 \u00a0 \u00a0 \u00a0 port := request.SessionInfo.Parameters[\"destination\"].(string)\u00a0 \u00a0 \u00a0 \u00a0 port = strings.ToLower(port)\u00a0 \u00a0 \u00a0 \u00a0 // Check if the port is covered\u00a0 \u00a0 \u00a0 \u00a0 covered := \"false\"\u00a0 \u00a0 \u00a0 \u00a0 if client != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // A Spanner client exists, so access the database.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // See: https://pkg.go.dev/cloud.google.com/go/spanner#ReadOnlyTransaction.ReadRow\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 row, err := client.Single().ReadRow(ctx,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"Destinations\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 spanner.Key{port},\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 []string{\"Covered\"})\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if spanner.ErrCode(err) == codes.NotFound {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Port %s not found\", port)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return webhookResponse{}, err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // A row was returned, so check the value\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var c bool\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err := row.Column(0, &c)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return webhookResponse{}, err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if c {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 covered = \"true\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // No Spanner client exists, so use hardcoded list of ports.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 coveredPorts := map[string]bool{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"anguilla\": true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"canada\": \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"mexico\": \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _, ok := coveredPorts[port]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ok {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 covered = \"true\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Create session parameters that are populated in the response.\u00a0 \u00a0 \u00a0 \u00a0 // This example hard codes values, but a real system\u00a0 \u00a0 \u00a0 \u00a0 // might look up this value in a database.\u00a0 \u00a0 \u00a0 \u00a0 p := map[string]interface{}{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"port_is_covered\": covered,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Build and return the response.\u00a0 \u00a0 \u00a0 \u00a0 response := webhookResponse{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SessionInfo: sessionInfo{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parameters: p,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return response, nil}// internationalCoverage handles same-named tag.func internationalCoverage(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error) {\u00a0 \u00a0 \u00a0 \u00a0 // Get the existing parameter values\u00a0 \u00a0 \u00a0 \u00a0 destination := request.SessionInfo.Parameters[\"destination\"].(string)\u00a0 \u00a0 \u00a0 \u00a0 destination = strings.ToLower(destination)\u00a0 \u00a0 \u00a0 \u00a0 // Hardcoded list of covered international monthly destinations\u00a0 \u00a0 \u00a0 \u00a0 coveredMonthly := map[string]bool{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"anguilla\": \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"australia\": true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"brazil\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"canada\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"chile\": \u00a0 \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"england\": \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"france\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"india\": \u00a0 \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"japan\": \u00a0 \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"mexico\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"singapore\": true,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Hardcoded list of covered international daily destinations\u00a0 \u00a0 \u00a0 \u00a0 coveredDaily := map[string]bool{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"brazil\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"canada\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"chile\": \u00a0 \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"england\": \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"france\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"india\": \u00a0 \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"japan\": \u00a0 \u00a0 true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"mexico\": \u00a0 \u00a0true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"singapore\": true,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Check coverage\u00a0 \u00a0 \u00a0 \u00a0 coverage := \"neither\"\u00a0 \u00a0 \u00a0 \u00a0 _, monthly := coveredMonthly[destination]\u00a0 \u00a0 \u00a0 \u00a0 _, daily := coveredDaily[destination]\u00a0 \u00a0 \u00a0 \u00a0 if monthly && daily {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 coverage = \"both\"\u00a0 \u00a0 \u00a0 \u00a0 } else if monthly {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 coverage = \"monthly_only\"\u00a0 \u00a0 \u00a0 \u00a0 } else if daily {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 coverage = \"daily_only\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Create session parameters that are populated in the response.\u00a0 \u00a0 \u00a0 \u00a0 // This example hard codes values, but a real system\u00a0 \u00a0 \u00a0 \u00a0 // might look up this value in a database.\u00a0 \u00a0 \u00a0 \u00a0 p := map[string]interface{}{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"coverage\": coverage,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Build and return the response.\u00a0 \u00a0 \u00a0 \u00a0 response := webhookResponse{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SessionInfo: sessionInfo{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parameters: p,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return response, nil}// cheapestPlan handles same-named tag.func cheapestPlan(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error) {\u00a0 \u00a0 \u00a0 \u00a0 // Create session parameters that are populated in the response.\u00a0 \u00a0 \u00a0 \u00a0 // This example hard codes values, but a real system\u00a0 \u00a0 \u00a0 \u00a0 // might look up this value in a database.\u00a0 \u00a0 \u00a0 \u00a0 p := map[string]interface{}{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"monthly_cost\": \u00a0 70,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"daily_cost\": \u00a0 \u00a0 100,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"suggested_plan\": \"monthly\",\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Build and return the response.\u00a0 \u00a0 \u00a0 \u00a0 response := webhookResponse{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SessionInfo: sessionInfo{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parameters: p,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return response, nil}// Define a type for handler functions.type handlerFn func(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error)// Create a map from tag to handler function.var handlers map[string]handlerFn = map[string]handlerFn{\u00a0 \u00a0 \u00a0 \u00a0 \"detectCustomerAnomaly\": detectCustomerAnomaly,\u00a0 \u00a0 \u00a0 \u00a0 \"validatePhoneLine\": \u00a0 \u00a0 validatePhoneLine,\u00a0 \u00a0 \u00a0 \u00a0 \"cruisePlanCoverage\": \u00a0 \u00a0cruisePlanCoverage,\u00a0 \u00a0 \u00a0 \u00a0 \"internationalCoverage\": internationalCoverage,\u00a0 \u00a0 \u00a0 \u00a0 \"cheapestPlan\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0cheapestPlan,}// handleError handles internal errors.func handleError(w http.ResponseWriter, err error) {\u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"ERROR: %v\", err)\u00a0 \u00a0 \u00a0 \u00a0 http.Error(w,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Sprintf(\"ERROR: %v\", err),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 http.StatusInternalServerError)}// HandleWebhookRequest handles WebhookRequest and sends the WebhookResponse.func HandleWebhookRequest(w http.ResponseWriter, r *http.Request) {\u00a0 \u00a0 \u00a0 \u00a0 var request webhookRequest\u00a0 \u00a0 \u00a0 \u00a0 var response webhookResponse\u00a0 \u00a0 \u00a0 \u00a0 var err error\u00a0 \u00a0 \u00a0 \u00a0 // Read input JSON\u00a0 \u00a0 \u00a0 \u00a0 if err = json.NewDecoder(r.Body).Decode(&request); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 handleError(w, err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Request: %+v\", request)\u00a0 \u00a0 \u00a0 \u00a0 // Get the tag from the request, and call the corresponding\u00a0 \u00a0 \u00a0 \u00a0 // function that handles that tag.\u00a0 \u00a0 \u00a0 \u00a0 tag := request.FulfillmentInfo.Tag\u00a0 \u00a0 \u00a0 \u00a0 if fn, ok := handlers[tag]; ok {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 response, err = fn(r.Context(), request)\u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err = fmt.Errorf(\"Unknown tag: %s\", tag)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 handleError(w, err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Response: %+v\", response)\u00a0 \u00a0 \u00a0 \u00a0 // Send response\u00a0 \u00a0 \u00a0 \u00a0 if err = json.NewEncoder(w).Encode(&response); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 handleError(w, err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 \u00a0 \u00a0 }}\n```\n- Click **Deploy** .\n- Wait until the status indicator shows that the function has successfully deployed. While waiting, examine the code you just deployed.## Configure the webhook for your agent\nNow that the webhook exists as a service, you will associate this webhook with your agent. To configure the webhook for your agent:\n- Open the [Dialogflow CX Console](https://dialogflow.cloud.google.com/cx/projects) .\n- Choose your Google Cloud project.\n- Select your agent.\n- Select the **Manage** tab.\n- Click **Webhooks** .\n- Click the existing webhook (created by the prebuilt agent).\n- Update the **Webhook URL** to the webhook URL you saved when creating the function.\n- Set the **Subtype** to Standard.\n- Click **Save** .## Try the agent\nYour agent is now ready to try. Click the **Test Agent** button to open the simulator. Attempt to have the following conversation with the agent:\n| Conversational turn | You       | Agent                                                |\n|----------------------:|:----------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|      1 | Hello      | Hi! I'm the virtual telecommunications agent. I can help you resolve billing and plan questions, troubleshoot, and add travel and cruise plans. How can I assist you today?       |\n|      2 | I want to add a cruise plan | Let me take a look for you. What is your phone number with us?                                  |\n|      3 | 123-123-1234    | How many days is your cruise?                                          |\n|      4 | 7       | Option 1 includes talk and text. It costs $[XX]/day. More info here [URL]. Option 2 includes talk, text and data. It costs $[XX]/day. More info here [URL]. Which cruise plan would you like to add? |\n|      5 | Option 1     | Got it. I've added that plan to your account. While on your cruise, you may also need coverage on land. What port will you be stopping at?               |\n|      6 | Mexico      | And, how many days are you spending there?                                       |\n|      7 | 3       | Great news! Mexico has free coverage on land. You're all set. Is there anything else I can help you with today?                      |\nThis particular conversation was managed by the `Cruise Plan` flow.\nAt conversational turn #6, you provided \"Mexico\" as your destination port. The destination port and the number of days there are captured as the `destination` and `trip_duration` form parameters of the `Collect Port` page. Browse your agent to find these parameter definitions.\nIn the `Collect Port` page, there is a condition route for form completion: `$page.params.status = \"FINAL\"` . Once the two form parameters have been provided, this route is called. This route calls your webhook and provides the `cruisePlanCoverage` tag to your webhook. If you examine the webhook code above, you see that this tag triggers the same named function to be called.\nThis function determines whether the provided destination is covered by the plan. The function checks whether specific environment variables are set with information for connecting to the database. If these environment variables are not set, the function uses a hardcoded list of destinations. In upcoming steps, you will alter the environment for the function so that it retrieves data from a database in order to validate plan coverage for destinations.\n## Troubleshooting\nThe webhook code includes logging statements. If you are having issues, try [viewing the logs](/functions/docs/monitoring/logging) for your function.\n## More information\nFor more information about the steps above, see:\n- [Cloud Functions Go quickstart](/functions/docs/console-quickstart-1st-gen)", "guide": "Dialogflow"}