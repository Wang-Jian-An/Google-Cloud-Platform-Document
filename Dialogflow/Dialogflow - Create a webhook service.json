{"title": "Dialogflow - Create a webhook service", "url": "https://cloud.google.com/dialogflow/es/docs/tutorials/deploy/webhook", "abstract": "# Dialogflow - Create a webhook service\nThe prebuilt agent you created in the last step cannot provide dynamic data like account balances, because everything is hardcoded into the agent. In this step of the tutorial, you will create a [webhook](/dialogflow/es/docs/fulfillment-overview) that can provide dynamic data to the agent. [Cloud Functions](/functions/docs) are used to host the webhook in this tutorial due to their simplicity, but there are many other ways that you could host a webhook service. The example also uses the Go programming language, but you can use any [language supported by Cloud Functions](/functions/docs/concepts/exec) .\n", "content": "## Create the Function\nCloud Functions can be created with the Google Cloud console ( [visit documentation](https://support.google.com/cloud/answer/3465889?ref_topic=3340599) , [open console](https://console.cloud.google.com/) ). To create a function for this tutorial:\n- It is important that your Dialogflow agent and the function are both in the same project. This is the easiest way for Dialogflow to have [secure access to your function](/dialogflow/es/docs/fulfillment-webhook#gcf) . Before creating the function, select your project from the Google Cloud console. [Go to project selector](https://console.cloud.google.com/projectselector2/home/dashboard) \n- Open the Cloud Functions overview page. [Go to Cloud Functions overview](https://console.cloud.google.com/functions/list) \n- Click **Create Function** , and set the following fields:- **Environment** : 1st gen\n- **Function name** : tutorial-banking-webhook\n- **Region** : If you specified a region for your agent, use the same region.\n- **HTTP Trigger type** : HTTP\n- **URL** : Click the copy button here and save the value. You will need this URL when configuring the webhook.\n- **Authentication** : Require authentication\n- **Require HTTPS** : checked\n- Click **Save** .\n- Click **Next** (You do not need special runtime, build, connections, or security settings).\n- Set the following fields:- **Runtime** : Select the latest Go runtime.\n- **Source code** : Inline Editor\n- **Entry point** : HandleWebhookRequest\n- Replace the code with the following:```\npackage estwhimport (\u00a0 \u00a0 \u00a0 \u00a0 \"context\"\u00a0 \u00a0 \u00a0 \u00a0 \"encoding/json\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"log\"\u00a0 \u00a0 \u00a0 \u00a0 \"net/http\"\u00a0 \u00a0 \u00a0 \u00a0 \"os\"\u00a0 \u00a0 \u00a0 \u00a0 \"strings\"\u00a0 \u00a0 \u00a0 \u00a0 \"cloud.google.com/go/spanner\"\u00a0 \"google.golang.org/grpc/codes\")// client is a Spanner client, created only once to avoid creation// for every request.// See: https://cloud.google.com/functions/docs/concepts/go-runtime#one-time_initializationvar client *spanner.Clientfunc init() {\u00a0 \u00a0 \u00a0 \u00a0 // If using a database, these environment variables will be set.\u00a0 \u00a0 \u00a0 \u00a0 pid := os.Getenv(\"PROJECT_ID\")\u00a0 \u00a0 \u00a0 \u00a0 iid := os.Getenv(\"SPANNER_INSTANCE_ID\")\u00a0 \u00a0 \u00a0 \u00a0 did := os.Getenv(\"SPANNER_DATABASE_ID\")\u00a0 \u00a0 \u00a0 \u00a0 if pid != \"\" && iid != \"\" && did != \"\" {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 db := fmt.Sprintf(\"projects/%s/instances/%s/databases/%s\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pid, iid, did)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Creating Spanner client for %s\", db)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var err error\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Use the background context when creating the client,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // but use the request context for calls to the client.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // See: https://cloud.google.com/functions/docs/concepts/go-runtime#contextcontext\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 client, err = spanner.NewClient(context.Background(), db)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Fatalf(\"spanner.NewClient: %v\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }}type queryResult struct {\u00a0 \u00a0 \u00a0 \u00a0 Action \u00a0 \u00a0 string \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 `json:\"action\"`\u00a0 \u00a0 \u00a0 \u00a0 Parameters map[string]interface{} `json:\"parameters\"`}type text struct {\u00a0 \u00a0 \u00a0 \u00a0 Text []string `json:\"text\"`}type message struct {\u00a0 \u00a0 \u00a0 \u00a0 Text text `json:\"text\"`}// webhookRequest is used to unmarshal a WebhookRequest JSON object. Note that// not all members need to be defined--just those that you need to process.// As an alternative, you could use the types provided by// the Dialogflow protocol buffers:// https://godoc.org/google.golang.org/genproto/googleapis/cloud/dialogflow/v2#WebhookRequesttype webhookRequest struct {\u00a0 \u00a0 \u00a0 \u00a0 Session \u00a0 \u00a0 string \u00a0 \u00a0 \u00a0`json:\"session\"`\u00a0 \u00a0 \u00a0 \u00a0 ResponseID \u00a0string \u00a0 \u00a0 \u00a0`json:\"responseId\"`\u00a0 \u00a0 \u00a0 \u00a0 QueryResult queryResult `json:\"queryResult\"`}// webhookResponse is used to marshal a WebhookResponse JSON object. Note that// not all members need to be defined--just those that you need to process.// As an alternative, you could use the types provided by// the Dialogflow protocol buffers:// https://godoc.org/google.golang.org/genproto/googleapis/cloud/dialogflow/v2#WebhookResponsetype webhookResponse struct {\u00a0 \u00a0 \u00a0 \u00a0 FulfillmentMessages []message `json:\"fulfillmentMessages\"`}// accountBalanceCheck handles the similar named actionfunc accountBalanceCheck(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error) {\u00a0 \u00a0 \u00a0 \u00a0 account := request.QueryResult.Parameters[\"account\"].(string)\u00a0 \u00a0 \u00a0 \u00a0 account = strings.ToLower(account)\u00a0 \u00a0 \u00a0 \u00a0 var table string\u00a0 \u00a0 \u00a0 \u00a0 if account == \"savings account\" {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 table = \"Savings\"\u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 table = \"Checking\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 s := \"Your balance is $0\"\u00a0 \u00a0 \u00a0 \u00a0 if client != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // A Spanner client exists, so access the database.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // See: https://pkg.go.dev/cloud.google.com/go/spanner#ReadOnlyTransaction.ReadRow\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 row, err := client.Single().ReadRow(ctx,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 table,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 spanner.Key{1}, // The account ID\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 []string{\"Balance\"})\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if spanner.ErrCode(err) == codes.NotFound {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Account %d not found\", 1)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return webhookResponse{}, err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // A row was returned, so check the value\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var balance int64\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err := row.Column(0, &balance)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return webhookResponse{}, err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 s = fmt.Sprintf(\"Your balance is $%.2f\", float64(balance)/100.0)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 response := webhookResponse{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 FulfillmentMessages: []message{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Text: text{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Text: []string{s},\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return response, nil}// Define a type for handler functions.type handlerFn func(ctx context.Context, request webhookRequest) (\u00a0 \u00a0 \u00a0 \u00a0 webhookResponse, error)// Create a map from action to handler function.var handlers map[string]handlerFn = map[string]handlerFn{\u00a0 \u00a0 \u00a0 \u00a0 \"account.balance.check\": accountBalanceCheck,}// handleError handles internal errors.func handleError(w http.ResponseWriter, err error) {\u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"ERROR: %v\", err)\u00a0 \u00a0 \u00a0 \u00a0 http.Error(w,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Sprintf(\"ERROR: %v\", err),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 http.StatusInternalServerError)}// HandleWebhookRequest handles WebhookRequest and sends the WebhookResponse.func HandleWebhookRequest(w http.ResponseWriter, r *http.Request) {\u00a0 \u00a0 \u00a0 \u00a0 var request webhookRequest\u00a0 \u00a0 \u00a0 \u00a0 var response webhookResponse\u00a0 \u00a0 \u00a0 \u00a0 var err error\u00a0 \u00a0 \u00a0 \u00a0 // Read input JSON\u00a0 \u00a0 \u00a0 \u00a0 if err = json.NewDecoder(r.Body).Decode(&request); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 handleError(w, err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Request: %+v\", request)\u00a0 \u00a0 \u00a0 \u00a0 // Get the action from the request, and call the corresponding\u00a0 \u00a0 \u00a0 \u00a0 // function that handles that action.\u00a0 \u00a0 \u00a0 \u00a0 action := request.QueryResult.Action\u00a0 \u00a0 \u00a0 \u00a0 if fn, ok := handlers[action]; ok {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 response, err = fn(r.Context(), request)\u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 err = fmt.Errorf(\"Unknown action: %s\", action)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 handleError(w, err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 log.Printf(\"Response: %+v\", response)\u00a0 \u00a0 \u00a0 \u00a0 // Send response\u00a0 \u00a0 \u00a0 \u00a0 if err = json.NewEncoder(w).Encode(&response); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 handleError(w, err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 \u00a0 \u00a0 }}\n```\n- Click **Deploy** .\n- Wait until the status indicator shows that the function has successfully deployed. While waiting, examine the code you just deployed.## Configure the webhook for your agent\nNow that the webhook exists as a service, you need to associate this webhook with your agent. This is done via fulfillment. To enable and manage fulfillment for your agent:\n- Go to the [Dialogflow ES Console](https://dialogflow.cloud.google.com) .\n- Select the pre-built agent you just created.\n- Select **Fulfillment** in the left sidebar menu.\n- Toggle the **Webhook** field to **Enabled** .\n- Provide the URL that you copied from above. Leave all other fields blank.\n- Click **Save** at the bottom of the page.Now that fulfillment is enabled for the agent, you need to enable fulfillment for an intent:\n- Select **Intents** in the left sidebar menu.\n- Select the **account.balance.check** intent.\n- Scroll down to the **Fulfillment** section.\n- Toggle **Enable webhook call for this intent** to on.\n- Click **Save** .## Try the agent\nYour agent is now ready to try. Click the **Test Agent** button to open the simulator. Attempt to have the following conversation with the agent:\n| Conversational turn | You        | Agent               |\n|----------------------:|:----------------------------------|:---------------------------------------------------------------|\n|      1 | Hello        | Hello, thanks for choosing ACME Bank.       |\n|      2 | I want to know my account balance | What account do you want the balance for: savings or checking? |\n|      3 | Checking       | Here's your latest balance: $0.00        |\nAt conversational turn #3, you supplied \"checking\" as the account type. The **account.balance.check** intent has a parameter called **account** . This parameter is set to \"checking\" in this conversation. The intent also has an action value of \"account.balance.check\". The webhook service is called, and it is passed the parameter and action values.\nIf you examine the webhook code above, you see that this action triggers a similar named function to be called. The function determines the account balance. The function checks whether specific environment variables are set with information for connecting to the database. If these environment variables are not set, the function uses a hardcoded account balance. In upcoming steps, you will alter the environment for the function so that it retrieves data from a database.\n## Troubleshooting\nThe webhook code includes logging statements. If you are having issues, try [viewing the logs](/functions/docs/monitoring/logging) for your function.\n## More information\nFor more information about the steps above, see:\n- [Cloud Functions Go quickstart](/functions/docs/console-quickstart-1st-gen)", "guide": "Dialogflow"}