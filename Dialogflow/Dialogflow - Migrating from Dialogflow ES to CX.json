{"title": "Dialogflow - Migrating from Dialogflow ES to CX", "url": "https://cloud.google.com/dialogflow/cx/docs/how/migrate", "abstract": "# Dialogflow - Migrating from Dialogflow ES to CX\nDialogflow CX agents provide you with [more powerful conversation controls and tools](/dialogflow/docs/editions#agent-types) than Dialogflow ES agents. If your Dialogflow ES agent handles complex conversations, you should consider migrating to Dialogflow CX.\nThis guide describes how to migrate an agent from Dialogflow ES to Dialogflow CX. These two agent types have many fundamental differences, so there is no straightforward way to perform this migration.\nIf you use this guide for a migration, please provide positive or negative feedback by clicking the **Send feedback** button above. We will use this feedback to improve this guide over time.\nAt a high level, the recommended process is an automated/manual hybrid process. You will use a tool that reads some of your Dialogflow ES agent data, writes that data to your Dialogflow CX agent, and captures a TODO list. You then re-create your complete CX agent using best practices, the TODO list, and the data that was migrated by the tool.\n", "content": "## Understand Dialogflow CX\nBefore attempting this migration, you should have a solid understanding of how Dialogflow CX works. You can start here:\n- [Basics](/dialogflow/cx/docs/basics) \n- [Introduction videos](/dialogflow/cx/docs/video) \n- [Quickstarts](/dialogflow/cx/docs/quick) \nYou should also read through additional concept documents that have features you are likely to need in your new agent. Focus on the following:\n- [Console overview](/dialogflow/cx/docs/concept/console) \n- [Agents](/dialogflow/cx/docs/concept/agent) \n- [Flows](/dialogflow/cx/docs/concept/flow) \n- [Pages](/dialogflow/cx/docs/concept/page) \n- [State handlers](/dialogflow/cx/docs/concept/handler) \n- [Intents](/dialogflow/cx/docs/concept/intent) \n- [Parameters](/dialogflow/cx/docs/concept/parameter) \n- [Fulfillments](/dialogflow/cx/docs/concept/fulfillment) \n- [Webhooks](/dialogflow/cx/docs/concept/webhook) ## Understand ES/CX differences\nThis section lists the most important differences between Dialogflow ES and CX. When performing manual migration steps later, you should refer to this section for guidance.\n### Structure and conversation path control\nES provides the following for structure and conversation path control:\n- [Intents](/dialogflow/cx/docs/concept/intent) are used as the building blocks of the agent. At any point in the conversation, an intent is matched, and in a sense, each intent is a node for the conversation.\n- [Context](/dialogflow/es/docs/contexts-overview) is used to control the conversation. Context is used to control which intents can be matched at any given time. Context expires after a certain number of conversational turns, so this type of control can be inaccurate for long conversations.\nCX provides a hierarchy of structure resources and more precise controls over the conversation path:\n- [Pages](/dialogflow/cx/docs/concept/page) are graph nodes for the conversation. CX conversations are similar to state machines. At any given point in the conversation, one page is active. Based on end-user input or events, the conversation may transition to another page. It is common for a page to remain active for multiple conversational turns.\n- [Flows](/dialogflow/cx/docs/concept/flow) are groups of related pages. Each flow should handle a high-level conversation topic.\n- [State handlers](/dialogflow/cx/docs/concept/handler) are used to control transitions and responses. There are three types of state handlers:- **Intent route** : contains an intent that must be matched, optional responses, and optional page transition.\n- **Condition route** : contains a condition that must be met, optional responses, and optional page transition.\n- **Event handler** : contains an event name that must be invoked, optional responses, and optional page transition.\n- [Scope](/dialogflow/cx/docs/concept/handler#scope) is used to control whether a state handler can be called. Most handlers are associated with a page or entire flow. If the associated page or flow is active, then the handler is in scope, and it can be called. A CX intent route in scope is similar to an ES intent with an input context that is active.\nWhen designing the flows and pages of your agent, be sure to understand the advice the [flow section of the agent design guide](/dialogflow/cx/docs/concept/agent-design#flow-page) .\n### Form filling\nES uses [slot filling](/dialogflow/es/docs/intents-actions-parameters#required) to collect required parameters from the end-user:\n- These parameters are intent parameters marked as required.\n- The intent continues being matched until all required parameters are collected.\n- You can define a prompt asking the end-user to provide a value.\nCX uses [form filling](/dialogflow/cx/docs/concept/parameter#form) to collect required parameters from the end-user:\n- These parameters are associated with a page and are collected while the page is active.\n- You use condition routes for pages to determine that [form filling is complete](/dialogflow/cx/docs/concept/parameter#form-ref) . These condition routes typically transition to another page.\n- You can define a prompt, as well as [re-prompt handlers](/dialogflow/cx/docs/concept/parameter#form-reprompt) to gracefully handle multiple attempts to collect a value.\n### Transitions\nES automatically transitions from one intent to the next when end-user input is matched to an intent. This match can only occur for intents that have no input context or intents that have an active input context.\nCX transitions from one page to the next when a state handler in scope satisfies its requirements and provides a transition target. Using these transitions, you can reliably guide end-users through conversations. There are multiple ways to control these transitions:\n- Intent matching can trigger an intent route.\n- Satisfying a condition can trigger a condition route.\n- Invocation of an event can trigger an event handler.\n- Re-prompt handlers can cause a transition when the end-user fails to provide a value after multiple attempts.\n- You can use [symbolic transition targets](/dialogflow/cx/docs/concept/handler#symbolic) for transition targets.\n### Agent responses\nES agent responses are sent to the end-user when an intent is matched:\n- The agent can select one message for the response from a list of possible responses.\n- Responses can be platform-specific, which can use [rich response formats](/dialogflow/es/docs/intents-rich-messages) .\n- Responses can be driven by webhooks.\nCX agent responses are sent to the end-user when [fulfillment](/dialogflow/cx/docs/concept/fulfillment) is called. Unlike ES fulfillment, which always involves a webhook, CX fulfillment may or may not involve calling a webhook, depending on whether the fulfillment resource has a webhook configured. Both static and dynamic responses based on webhook responses are controlled by fulfillment. There are multiple ways to create agent responses:\n- Fulfillment can be provided to any type of state handler.\n- Multiple responses can be concatenated during a conversational turn via the [response queue](/dialogflow/cx/docs/concept/fulfillment#queue) . This feature can simplify your agent design in some cases.\n- CX does not support built-in platform-specific responses. However, it provides [multiple response types](/dialogflow/cx/docs/concept/fulfillment#static) , including a custom payload which can be used for platform-specific responses.\n### Parameters\n[ES parameters](/dialogflow/es/docs/intents-actions-parameters) have the following characteristics:\n- Defined only in intents.\n- Set by end-user input, events, webhooks, and API calls.\n- Referenced in responses, parameter prompts, webhook code, and [parameter values](/dialogflow/es/docs/intents-actions-parameters#valfield) :- Basic reference format is`$parameter-name`.\n- References support`.original`,`.partial`, and`.recent`suffix syntax.\n- References can specify the active context:`#context-name.parameter-name`.\n- References can specify event parameters:`#event-name.parameter-name`.[CX parameters](/dialogflow/cx/docs/concept/parameter) have the following characteristics:\n- Defined in intents and page forms.\n- Intent and form parameters are [propagated to session parameters](/dialogflow/cx/docs/concept/parameter#prop) , where they are available for referencing for the duration of the session.\n- Set by end-user input, webhooks, [fulfillment parameter preset](/dialogflow/cx/docs/concept/fulfillment#param-preset) , and API calls.\n- Referenced in responses, parameter prompts, re-prompt handlers, parameter presets, and webhook code:- Reference format is`$session.params.parameter-id`for session parameters and`$intent.params.parameter-id`for intent parameters.\n- Intent parameter references support`.original`and`.resolved`suffix syntax. Session parameters do not support this syntax.\n### System entities\nES supports many [system entities](/dialogflow/es/docs/reference/system-entities) .\nCX supports many of the same [system entities](/dialogflow/cx/docs/reference/system-entities) , but there are some differences. When migrating, verify that system entities you are using in ES are also supported by CX for the same language. If not, you should create custom entities for these.\n### Events\n[ES events](/dialogflow/es/docs/events-overview) have the following characteristics:\n- Can be invoked from API calls or webhooks to match an intent.\n- Can set parameters.\n- A small number of events are invoked by integration platforms.\n[CX events](/dialogflow/cx/docs/concept/handler#event) have the following characteristics:\n- Can be invoked from API calls or webhooks to call an event handler.\n- Cannot set parameters.\n- Many built-in events can be used for handling lack of end-user input, unrecognized end-user input, parameters invalidated by a webhook, and webhook errors.\n- Invocations can be controlled by the same [scoping rules](/dialogflow/cx/docs/concept/handler#scope) as other state handlers.\n### Built-in intents\nES supports the following built-in intents:\n- [Welcome intent](/dialogflow/es/docs/intents-default#welcome) \n- [Fallback intents](/dialogflow/es/docs/intents-default#fallback) \n- [Predefined follow-up intents](/dialogflow/es/docs/reference/follow-up-intent-expressions) \nThe following describes the CX support for built-in intents:\n- [Welcome intents](/dialogflow/cx/docs/concept/intent#welcome) are supported.\n- Fallback intents are not provided. Use the [no-match](/dialogflow/cx/docs/concept/handler#event-built-in) events in event handlers instead.\n- For negative examples, use the [default negative intent](/dialogflow/cx/docs/concept/intent#negative) .\n- Predefined follow-up intents are not provided. You must create these intents as required by your agent. For example, you will likely need to create an intent to handle negative answers to an agent question (\"no\", \"no thanks\", \"no I don't\", and so on). CX intents are reusable across your agent, so you only need to define these once. Using different intent routes for these common intents, in different scopes, gives you much better control over the conversation.\n### Webhooks\n[ES webhooks](/dialogflow/es/docs/fulfillment-webhook) have the following characteristics:\n- You can configure one webhook service for the agent.\n- Each intent can be marked as using the webhook.\n- There is no built-in support for handling webhook errors.\n- Intent actions or intent names are used by webhooks to determine where in the agent it was called from.\n- The console provides the [inline editor](/dialogflow/es/docs/fulfillment-inline-editor) .\n[CX webhooks](/dialogflow/cx/docs/concept/webhook) have the following characteristics:\n- You can configure multiple webhook services for the agent.\n- Each fulfillment can optionally specify a webhook call.\n- There is built-in support for [webhook error handling](/dialogflow/cx/docs/concept/webhook#errors) .\n- A CX fulfillment webhook contains a [tag](/dialogflow/cx/docs/concept/fulfillment#webhook) . This tag is similar to an ES action, but it is only used when calling webhooks. The webhook service can use these tags to determine where in the agent it was called from.\n- The console does not have a built-in webhook code editor. It is common to use [Cloud Functions](/dialogflow/cx/docs/concept/webhook#gcf) , but there are many options.\nWhen migrating to CX, you will need to change your webhook code, as the request and response properties are different.\n### Integrations\n[ES integrations](/dialogflow/es/docs/integrations) and [CX integrations](/dialogflow/cx/docs/concept/integration) support different platforms. For platforms that are supported by both agent types, there may be differences in configuration.\nIf the ES integration you were using is not supported by CX, you may need to switch platforms or implement the integration yourself.\n### More CX-only features\nThere are many other features only provided by CX. You should consider using these features while migrating. For example:\n- [Advanced NLU](/dialogflow/cx/docs/concept/agent#settings-ml) \n- [Advanced speech settings](/dialogflow/cx/docs/concept/agent#settings-speech) (end of speech sensitivity, no speech timeout, and so on)\n- [Change history](/dialogflow/cx/docs/concept/change-history) \n- [Conditional logic](/dialogflow/cx/docs/concept/handler#cond) \n- [DTMF input for telephony integrations](/dialogflow/cx/docs/concept/parameter#dtmf) \n- [Environment-specific webhooks](/dialogflow/cx/docs/concept/webhook#environment-specific) \n- [Experiments](/dialogflow/cx/docs/concept/experiments) \n- [Route groups](/dialogflow/cx/docs/concept/handler#route-group) \n- [Search agent data](/dialogflow/cx/docs/concept/search) \n- [Security settings](/dialogflow/cx/docs/concept/security-settings) (redaction and data retention)\n- [System functions for advanced responses and conditions](/dialogflow/cx/docs/reference/system-functions) \n- [Test cases](/dialogflow/cx/docs/concept/test-case) \n- [Validation of agent data](/dialogflow/cx/docs/concept/validation) ## Best practices\nBefore migrating, familiarize yourself with [CX agent design best practices](/dialogflow/cx/docs/concept/agent-design) . Many of these CX best practices are similar to ES best practices, but some are unique to CX.\n## About the migration tool\nThe migration tool copies the bulk of the ES data to your CX agent, and it writes to a TODO file with a list of items that must be manually migrated. The tool only copies custom entity types and intent training phrases. You should consider customizing this tool for your specific needs.\n### Migration tool code\nHere is the code for the tool. You should review the code for this tool, so you understand what it does. You may want to change this code to handle specific situations in your agent. In steps below, you will execute this tool.\n```\n// Package main implements the ES to CX migration tool.package mainimport (\u00a0 \u00a0 \u00a0 \u00a0 \"context\"\u00a0 \u00a0 \u00a0 \u00a0 \"encoding/csv\"\u00a0 \u00a0 \u00a0 \u00a0 \"flag\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"os\"\u00a0 \u00a0 \u00a0 \u00a0 \"strings\"\u00a0 \u00a0 \u00a0 \u00a0 \"time\"\u00a0 \u00a0 \u00a0 \u00a0 v2 \"cloud.google.com/go/dialogflow/apiv2\"\u00a0 \u00a0 \u00a0 \u00a0 proto2 \"cloud.google.com/go/dialogflow/apiv2/dialogflowpb\"\u00a0 \u00a0 \u00a0 \u00a0 v3 \"cloud.google.com/go/dialogflow/cx/apiv3\"\u00a0 \u00a0 \u00a0 \u00a0 proto3 \"cloud.google.com/go/dialogflow/cx/apiv3/cxpb\"\u00a0 \u00a0 \u00a0 \u00a0 \"google.golang.org/api/iterator\"\u00a0 \u00a0 \u00a0 \u00a0 \"google.golang.org/api/option\")// Commandline flagsvar v2Project *string = flag.String(\"es-project-id\", \"\", \"ES project\")var v3Project *string = flag.String(\"cx-project-id\", \"\", \"CX project\")var v2Region *string = flag.String(\"es-region-id\", \"\", \"ES region\")var v3Region *string = flag.String(\"cx-region-id\", \"\", \"CX region\")var v3Agent *string = flag.String(\"cx-agent-id\", \"\", \"CX region\")var outFile *string = flag.String(\"out-file\", \"\", \"Output file for CSV TODO items\")var dryRun *bool = flag.Bool(\"dry-run\", false, \"Set true to skip CX agent writes\")// Map from entity type display name to fully qualified name.var entityTypeShortToLong = map[string]string{}// Map from ES system entity to CX system entityvar convertSystemEntity = map[string]string{\u00a0 \u00a0 \u00a0 \u00a0 \"sys.address\": \u00a0 \u00a0 \u00a0 \u00a0 \"sys.address\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.any\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sys.any\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.cardinal\": \u00a0 \u00a0 \u00a0 \u00a0\"sys.cardinal\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.color\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sys.color\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.currency-name\": \u00a0 \"sys.currency-name\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.date\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"sys.date\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.date-period\": \u00a0 \u00a0 \"sys.date-period\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.date-time\": \u00a0 \u00a0 \u00a0 \"sys.date-time\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.duration\": \u00a0 \u00a0 \u00a0 \u00a0\"sys.duration\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.email\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sys.email\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.flight-number\": \u00a0 \"sys.flight-number\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-city-gb\": \u00a0 \u00a0 \"sys.geo-city\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-city-us\": \u00a0 \u00a0 \"sys.geo-city\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-city\": \u00a0 \u00a0 \u00a0 \u00a0\"sys.geo-city\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-country\": \u00a0 \u00a0 \"sys.geo-country\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-state\": \u00a0 \u00a0 \u00a0 \"sys.geo-state\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-state-us\": \u00a0 \u00a0\"sys.geo-state\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.geo-state-gb\": \u00a0 \u00a0\"sys.geo-state\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.given-name\": \u00a0 \u00a0 \u00a0\"sys.given-name\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.language\": \u00a0 \u00a0 \u00a0 \u00a0\"sys.language\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.last-name\": \u00a0 \u00a0 \u00a0 \"sys.last-name\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.street-address\": \u00a0\"sys.location\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.location\": \u00a0 \u00a0 \u00a0 \u00a0\"sys.location\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.number\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"sys.number\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.number-integer\": \u00a0\"sys.number-integer\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.number-sequence\": \"sys.number-sequence\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.ordinal\": \u00a0 \u00a0 \u00a0 \u00a0 \"sys.ordinal\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.percentage\": \u00a0 \u00a0 \u00a0\"sys.percentage\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.person\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"sys.person\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.phone-number\": \u00a0 \u00a0\"sys.phone-number\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.temperature\": \u00a0 \u00a0 \"sys.temperature\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.time\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"sys.time\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.time-period\": \u00a0 \u00a0 \"sys.time-period\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.unit-currency\": \u00a0 \"sys.unit-currency\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.url\": \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"sys.url\",\u00a0 \u00a0 \u00a0 \u00a0 \"sys.zip-code\": \u00a0 \u00a0 \u00a0 \u00a0\"sys.zip-code\",}// Issues found for the CSV outputvar issues = [][]string{\u00a0 \u00a0 \u00a0 \u00a0 {\"Field\", \"Issue\"},}// logIssue logs an issue for the CSV outputfunc logIssue(field string, issue string) {\u00a0 \u00a0 \u00a0 \u00a0 issues = append(issues, []string{field, issue})}// convertEntityType converts an ES entity type to CXfunc convertEntityType(et2 *proto2.EntityType) *proto3.EntityType {\u00a0 \u00a0 \u00a0 \u00a0 var kind3 proto3.EntityType_Kind\u00a0 \u00a0 \u00a0 \u00a0 switch kind2 := et2.Kind; kind2 {\u00a0 \u00a0 \u00a0 \u00a0 case proto2.EntityType_KIND_MAP:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 kind3 = proto3.EntityType_KIND_MAP\u00a0 \u00a0 \u00a0 \u00a0 case proto2.EntityType_KIND_LIST:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 kind3 = proto3.EntityType_KIND_LIST\u00a0 \u00a0 \u00a0 \u00a0 case proto2.EntityType_KIND_REGEXP:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 kind3 = proto3.EntityType_KIND_REGEXP\u00a0 \u00a0 \u00a0 \u00a0 default:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 kind3 = proto3.EntityType_KIND_UNSPECIFIED\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 var expansion3 proto3.EntityType_AutoExpansionMode\u00a0 \u00a0 \u00a0 \u00a0 switch expansion2 := et2.AutoExpansionMode; expansion2 {\u00a0 \u00a0 \u00a0 \u00a0 case proto2.EntityType_AUTO_EXPANSION_MODE_DEFAULT:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 expansion3 = proto3.EntityType_AUTO_EXPANSION_MODE_DEFAULT\u00a0 \u00a0 \u00a0 \u00a0 default:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 expansion3 = proto3.EntityType_AUTO_EXPANSION_MODE_UNSPECIFIED\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 et3 := &proto3.EntityType{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 DisplayName: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 et2.DisplayName,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Kind: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0kind3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AutoExpansionMode: \u00a0 \u00a0 expansion3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 EnableFuzzyExtraction: et2.EnableFuzzyExtraction,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 for _, e2 := range et2.Entities {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 et3.Entities = append(et3.Entities, &proto3.EntityType_Entity{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Value: \u00a0 \u00a0e2.Value,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Synonyms: e2.Synonyms,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return et3}// convertParameterEntityType converts a entity type found in parametersfunc convertParameterEntityType(intent string, parameter string, t2 string) string {\u00a0 \u00a0 \u00a0 \u00a0 if len(t2) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return \"\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 t2 = t2[1:] // remove @\u00a0 \u00a0 \u00a0 \u00a0 if strings.HasPrefix(t2, \"sys.\") {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if val, ok := convertSystemEntity[t2]; ok {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 t2 = val\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 t2 = \"sys.any\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent+\">.Parameter<\"+parameter+\">\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent parameter uses a system entity not supported by CX English agents. See the migration guide for advice. System entity: \"+t2)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Sprintf(\"projects/-/locations/-/agents/-/entityTypes/%s\", t2)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return entityTypeShortToLong[t2]}// convertIntent converts an ES intent to CXfunc convertIntent(intent2 *proto2.Intent) *proto3.Intent {\u00a0 \u00a0 \u00a0 \u00a0 if intent2.DisplayName == \"Default Fallback Intent\" ||\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 intent2.DisplayName == \"Default Welcome Intent\" {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return nil\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 intent3 := &proto3.Intent{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 DisplayName: intent2.DisplayName,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // WebhookState\u00a0 \u00a0 \u00a0 \u00a0 if intent2.WebhookState != proto2.Intent_WEBHOOK_STATE_UNSPECIFIED {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.WebhookState\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent has webhook enabled. You must configure this in your CX agent.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // IsFallback\u00a0 \u00a0 \u00a0 \u00a0 if intent2.IsFallback {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.IsFallback\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent is a fallback intent. CX does not support this. Use no-match events instead.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // MlDisabled\u00a0 \u00a0 \u00a0 \u00a0 if intent2.MlDisabled {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.MlDisabled\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent has ML disabled. CX does not support this.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // LiveAgentHandoff\u00a0 \u00a0 \u00a0 \u00a0 if intent2.LiveAgentHandoff {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.LiveAgentHandoff\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent uses live agent handoff. You must configure this in a fulfillment.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // EndInteraction\u00a0 \u00a0 \u00a0 \u00a0 if intent2.EndInteraction {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.EndInteraction\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent uses end interaction. CX does not support this.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // InputContextNames\u00a0 \u00a0 \u00a0 \u00a0 if len(intent2.InputContextNames) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.InputContextNames\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent uses context. See the migration guide for alternatives.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Events\u00a0 \u00a0 \u00a0 \u00a0 if len(intent2.Events) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Events\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent uses events. Use event handlers instead.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // TrainingPhrases\u00a0 \u00a0 \u00a0 \u00a0 var trainingPhrases3 []*proto3.Intent_TrainingPhrase\u00a0 \u00a0 \u00a0 \u00a0 for _, tp2 := range intent2.TrainingPhrases {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if tp2.Type == proto2.Intent_TrainingPhrase_TEMPLATE {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.TrainingPhrases\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent has a training phrase that uses a template (@...) training phrase type. CX does not support this.\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var parts3 []*proto3.Intent_TrainingPhrase_Part\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for _, part2 := range tp2.Parts {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 parts3 = append(parts3, &proto3.Intent_TrainingPhrase_Part{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Text: \u00a0 \u00a0 \u00a0 \u00a0part2.Text,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ParameterId: part2.Alias,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 trainingPhrases3 = append(trainingPhrases3, &proto3.Intent_TrainingPhrase{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parts: \u00a0 \u00a0 \u00a0 parts3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 RepeatCount: 1,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 intent3.TrainingPhrases = trainingPhrases3\u00a0 \u00a0 \u00a0 \u00a0 // Action\u00a0 \u00a0 \u00a0 \u00a0 if len(intent2.Action) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Action\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent sets the action field. Use a fulfillment webhook tag instead.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // OutputContexts\u00a0 \u00a0 \u00a0 \u00a0 if len(intent2.OutputContexts) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.OutputContexts\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent uses context. See the migration guide for alternatives.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // ResetContexts\u00a0 \u00a0 \u00a0 \u00a0 if intent2.ResetContexts {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.ResetContexts\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent uses context. See the migration guide for alternatives.\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Parameters\u00a0 \u00a0 \u00a0 \u00a0 var parameters3 []*proto3.Intent_Parameter\u00a0 \u00a0 \u00a0 \u00a0 for _, p2 := range intent2.Parameters {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if len(p2.Value) > 0 && p2.Value != \"$\"+p2.DisplayName {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Parameters<\"+p2.DisplayName+\">.Value\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This field is not set to $parameter-name. This feature is not supported by CX. See: https://cloud.google.com/dialogflow/es/docs/intents-actions-parameters#valfield.\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if len(p2.DefaultValue) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Parameters<\"+p2.DisplayName+\">.DefaultValue\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent parameter is using a default value. CX intent parameters do not support default values, but CX page form parameters do. This parameter should probably become a form parameter.\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if p2.Mandatory {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Parameters<\"+p2.DisplayName+\">.Mandatory\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent parameter is marked as mandatory. CX intent parameters do not support mandatory parameters, but CX page form parameters do. This parameter should probably become a form parameter.\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for _, prompt := range p2.Prompts {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Parameters<\"+p2.DisplayName+\">.Prompts\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent parameter has a prompt. Use page form parameter prompts instead. Prompt: \"+prompt)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if len(p2.EntityTypeDisplayName) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p2.EntityTypeDisplayName = \"@sys.any\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Parameters<\"+p2.DisplayName+\">.EntityTypeDisplayName\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent parameter does not have an entity type. CX requires an entity type for all parameters..\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 parameters3 = append(parameters3, &proto3.Intent_Parameter{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Id: \u00a0 \u00a0 \u00a0 \u00a0 p2.DisplayName,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 EntityType: convertParameterEntityType(intent2.DisplayName, p2.DisplayName, p2.EntityTypeDisplayName),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IsList: \u00a0 \u00a0 p2.IsList,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 //fmt.Printf(\"Converted parameter: %+v\\n\", parameters3[len(parameters3)-1])\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 intent3.Parameters = parameters3\u00a0 \u00a0 \u00a0 \u00a0 // Messages\u00a0 \u00a0 \u00a0 \u00a0 for _, message := range intent2.Messages {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 m, ok := message.Message.(*proto2.Intent_Message_Text_)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if ok {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for _, t := range m.Text.Text {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 warnings := \"\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if strings.Contains(t, \"#\") {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 warnings += \" This message may contain a context parameter reference, but CX does not support this.\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if strings.Contains(t, \".original\") {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 warnings += \" This message may contain a parameter reference suffix of '.original', But CX only supports this for intent parameters (not session parameters).\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if strings.Contains(t, \".recent\") {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 warnings += \" This message may contain a parameter reference suffix of '.recent', but CX does not support this.\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if strings.Contains(t, \".partial\") {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 warnings += \" This message may contain a parameter reference suffix of '.partial', but CX does not support this.\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Messages\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent has a response message. Use fulfillment instead.\"+warnings+\" Message: \"+t)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Messages\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent has a non-text response message. See the rich response message information in the migration guide.\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if message.Platform != proto2.Intent_Message_PLATFORM_UNSPECIFIED {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 logIssue(\"Intent<\"+intent2.DisplayName+\">.Platform\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"This intent has a message with a non-default platform. See the migration guide for advice.\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return intent3}// migrateEntities migrates ES entities to your CX agentfunc migrateEntities(ctx context.Context) error {\u00a0 \u00a0 \u00a0 \u00a0 var err error\u00a0 \u00a0 \u00a0 \u00a0 // Create ES client\u00a0 \u00a0 \u00a0 \u00a0 var client2 *v2.EntityTypesClient\u00a0 \u00a0 \u00a0 \u00a0 options2 := []option.ClientOption{}\u00a0 \u00a0 \u00a0 \u00a0 if len(*v2Region) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 options2 = append(options2,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 option.WithEndpoint(*v2Region+\"-dialogflow.googleapis.com:443\"))\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 client2, err = v2.NewEntityTypesClient(ctx, options2...)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer client2.Close()\u00a0 \u00a0 \u00a0 \u00a0 var parent2 string\u00a0 \u00a0 \u00a0 \u00a0 if len(*v2Region) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 parent2 = fmt.Sprintf(\"projects/%s/agent\", *v2Project)\u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 parent2 = fmt.Sprintf(\"projects/%s/locations/%s/agent\", *v2Project, *v2Region)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Create CX client\u00a0 \u00a0 \u00a0 \u00a0 var client3 *v3.EntityTypesClient\u00a0 \u00a0 \u00a0 \u00a0 options3 := []option.ClientOption{}\u00a0 \u00a0 \u00a0 \u00a0 if len(*v3Region) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 options3 = append(options3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 option.WithEndpoint(*v3Region+\"-dialogflow.googleapis.com:443\"))\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 client3, err = v3.NewEntityTypesClient(ctx, options3...)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer client3.Close()\u00a0 \u00a0 \u00a0 \u00a0 parent3 := fmt.Sprintf(\"projects/%s/locations/%s/agents/%s\", *v3Project, *v3Region, *v3Agent)\u00a0 \u00a0 \u00a0 \u00a0 // Read each V2 entity type, convert, and write to V3\u00a0 \u00a0 \u00a0 \u00a0 request2 := &proto2.ListEntityTypesRequest{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parent: parent2,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 it2 := client2.ListEntityTypes(ctx, request2)\u00a0 \u00a0 \u00a0 \u00a0 for {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var et2 *proto2.EntityType\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 et2, err = it2.Next()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err == iterator.Done {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Printf(\"Entity Type: %s\\n\", et2.DisplayName)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if *dryRun {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 convertEntityType(et2)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 request3 := &proto3.CreateEntityTypeRequest{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parent: \u00a0 \u00a0 parent3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 EntityType: convertEntityType(et2),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 et3, err := client3.CreateEntityType(ctx, request3)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 entityTypeShortToLong[et3.DisplayName] = et3.Name\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // ES and CX each have a quota limit of 60 design-time requests per minute\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 time.Sleep(2 * time.Second)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return nil}// migrateIntents migrates intents to your CX agentfunc migrateIntents(ctx context.Context) error {\u00a0 \u00a0 \u00a0 \u00a0 var err error\u00a0 \u00a0 \u00a0 \u00a0 // Create ES client\u00a0 \u00a0 \u00a0 \u00a0 var client2 *v2.IntentsClient\u00a0 \u00a0 \u00a0 \u00a0 options2 := []option.ClientOption{}\u00a0 \u00a0 \u00a0 \u00a0 if len(*v2Region) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 options2 = append(options2,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 option.WithEndpoint(*v2Region+\"-dialogflow.googleapis.com:443\"))\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 client2, err = v2.NewIntentsClient(ctx, options2...)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer client2.Close()\u00a0 \u00a0 \u00a0 \u00a0 var parent2 string\u00a0 \u00a0 \u00a0 \u00a0 if len(*v2Region) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 parent2 = fmt.Sprintf(\"projects/%s/agent\", *v2Project)\u00a0 \u00a0 \u00a0 \u00a0 } else {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 parent2 = fmt.Sprintf(\"projects/%s/locations/%s/agent\", *v2Project, *v2Region)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Create CX client\u00a0 \u00a0 \u00a0 \u00a0 var client3 *v3.IntentsClient\u00a0 \u00a0 \u00a0 \u00a0 options3 := []option.ClientOption{}\u00a0 \u00a0 \u00a0 \u00a0 if len(*v3Region) > 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 options3 = append(options3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 option.WithEndpoint(*v3Region+\"-dialogflow.googleapis.com:443\"))\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 client3, err = v3.NewIntentsClient(ctx, options3...)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer client3.Close()\u00a0 \u00a0 \u00a0 \u00a0 parent3 := fmt.Sprintf(\"projects/%s/locations/%s/agents/%s\", *v3Project, *v3Region, *v3Agent)\u00a0 \u00a0 \u00a0 \u00a0 // Read each V2 entity type, convert, and write to V3\u00a0 \u00a0 \u00a0 \u00a0 request2 := &proto2.ListIntentsRequest{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parent: \u00a0 \u00a0 parent2,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IntentView: proto2.IntentView_INTENT_VIEW_FULL,\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 it2 := client2.ListIntents(ctx, request2)\u00a0 \u00a0 \u00a0 \u00a0 for {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var intent2 *proto2.Intent\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 intent2, err = it2.Next()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err == iterator.Done {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Printf(\"Intent: %s\\n\", intent2.DisplayName)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 intent3 := convertIntent(intent2)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if intent3 == nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if *dryRun {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 continue\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 request3 := &proto3.CreateIntentRequest{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Parent: parent3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Intent: intent3,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _, err := client3.CreateIntent(ctx, request3)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return err\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // ES and CX each have a quota limit of 60 design-time requests per minute\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 time.Sleep(2 * time.Second)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return nil}// checkFlags checks commandline flagsfunc checkFlags() error {\u00a0 \u00a0 \u00a0 \u00a0 flag.Parse()\u00a0 \u00a0 \u00a0 \u00a0 if len(*v2Project) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"Need to supply es-project-id flag\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if len(*v3Project) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"Need to supply cx-project-id flag\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if len(*v2Region) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Printf(\"No region supplied for ES, using default\\n\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if len(*v3Region) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"Need to supply cx-region-id flag\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if len(*v3Agent) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"Need to supply cx-agent-id flag\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if len(*outFile) == 0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"Need to supply out-file flag\")\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return nil}// closeFile is used as a convenience for deferfunc closeFile(f *os.File) {\u00a0 \u00a0 \u00a0 \u00a0 err := f.Close()\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Fprintf(os.Stderr, \"ERROR closing CSV file: %v\\n\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.Exit(1)\u00a0 \u00a0 \u00a0 \u00a0 }}func main() {\u00a0 \u00a0 \u00a0 \u00a0 if err := checkFlags(); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Fprintf(os.Stderr, \"ERROR checking flags: %v\\n\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.Exit(1)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 ctx := context.Background()\u00a0 \u00a0 \u00a0 \u00a0 if err := migrateEntities(ctx); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Fprintf(os.Stderr, \"ERROR migrating entities: %v\\n\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.Exit(1)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 if err := migrateIntents(ctx); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Fprintf(os.Stderr, \"ERROR migrating intents: %v\\n\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.Exit(1)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 csvFile, err := os.Create(*outFile)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Fprintf(os.Stderr, \"ERROR opening output file: %v\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.Exit(1)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer closeFile(csvFile)\u00a0 \u00a0 \u00a0 \u00a0 csvWriter := csv.NewWriter(csvFile)\u00a0 \u00a0 \u00a0 \u00a0 if err := csvWriter.WriteAll(issues); err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fmt.Fprintf(os.Stderr, \"ERROR writing CSV output file: %v\", err)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 os.Exit(1)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 csvWriter.Flush()}\n```\n### Tool migration of entity types\n[ES entity types](/dialogflow/es/docs/entities-custom) and [CX entity types](/dialogflow/cx/docs/concept/entity-custom) are very similar, so they are the easiest datatype to migrate. The tool simply copies entity types as-is.\n### Tool migration of intents\n[ES intents](/dialogflow/es/docs/intents-overview) and [CX intents](/dialogflow/cx/docs/concept/intent) are very different.\nES intents are used as the building blocks of the agent; and they contain training phrases, responses, context for conversation control, webhook configurations, events, actions, and slot filling parameters.\nDialogflow CX has moved most of this data to other resources. CX intents only have training phrases and parameters, which makes intents reusable across the agent. The tool only copies these two types of intent data to your CX intents.\n### Migration tool limitations\nThe migration tool does not support the following:\n- **Mega agents** : The tool cannot read from multiple sub-agents, but you can call the tool multiple times against each sub-agent.\n- **Multilingual agents** : You should modify the tool to create multilingual training phrases and entity entries.\n- **System entity verification for non-English languages** : The tool creates TODO items when it finds system entities that are not [supported by CX](/dialogflow/cx/docs/reference/system-entities) , with an assumption that English is the default language, and that it uses a US region. System entity support varies by language and region. For other languages and regions, you should modify the tool to perform this check.## Essential migration steps\nThe following subsections outline migration steps to be taken. You do not need to follow these manual steps in order, and you may even need to do these steps simultaneously or in a different order. Read through the steps and begin planning your changes before you actually make changes.\nAfter you run the migration tool, you can rebuild your CX agent. You will still have a fair amount of migration work to do, but the bulk of the hand entered data will be present in your CX agent and the TODO file.\n### Create your Dialogflow CX agent\nIf you haven't already, [create your Dialogflow CX agent](/dialogflow/cx/docs/concept/agent#create) . Be sure to use the same default language as your ES agent.\n### Run the migration tool\nTake the following steps to execute the tool:\n- If you haven't already, [install Go on your machine](https://go.dev/doc/install) .\n- Create a directory for the tool code called`migrate`.\n- Copy the [tool code above](#tool-code) to a file in this directory called`main.go`.\n- Modify the code if needed for your case.\n- Create a [Go module](https://go.dev/ref/mod#go-mod-init) in this directory. For example:```\ngo mod init migrate\n```\n- Install the Dialogflow ES V2 and Dialogflow CX V3 Go client libraries:```\ngo get cloud.google.com/go/dialogflow/apiv2go get cloud.google.com/go/dialogflow/cx/apiv3\n```\n- Ensure you have set up [client library authentication](/dialogflow/cx/docs/quick/setup#auth) .\n- Run the tool, and save the output to file:```\ngo run main.go -es-project-id=<ES_PROJECT_ID> -cx-project-id=<CX_PROJECT_ID> \\-cx-region-id=<CX_REGION_ID> -cx-agent-id=<CX_AGENT_ID> -out-file=out.csv\n```\n### Migration tool troubleshooting\nIf you experience errors when running the tool, check the following:\n| Error                     | Resolution                                                                                       |\n|:---------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| RPC error that a training phrase part mentions a parameter not defined for the intent. | This may happen if you previously used the ES API to create intent parameters in a way that was inconsistent with the training phrases. To fix this, rename the ES parameter from the console, check that your training phrases are using the parameter properly, then click save. This may also happen if your training phrases reference nonexistent parameters. |\nAfter fixing errors, you will need to clear the CX agent of intents and entities before running the migration tool again.\n### Moving ES intent data to CX\nThe tool migrates intent training phrases and parameters to CX intents, but there are many other ES intent fields to migrate manually.\nAn ES intent may need a corresponding CX page, a corresponding CX intent, or both.\nIf an ES intent match is used to transition the conversation from a particular conversation node to another, you should have two pages in your agent related to this intent:\n- **The original page that contains the intent route,\nwhich will transition to the next page** : The intent route in the original page may have CX fulfillment messages similar to the ES intent responses. You may have many intent routes in this page. While the original page is active, these intent routes can transition the conversation to many possible paths. Many ES intents will share the same corresponding CX original page.\n- **The next page,\nwhich is the transition target for the intent route in the original page** : The CX entry fulfillment for the next page may have CX fulfillment messages similar to the ES intent responses.\nIf an ES intent contains required parameters, you should create a corresponding CX page with the same parameters in a form.\nIt is common for a CX intent and a CX page to share the same parameter list, which would mean that a single ES intent has a corresponding CX page and a corresponding CX intent. When a CX intent with parameters in an intent route is matched, the conversation often transitions to a page with the same parameters. The parameters extracted from the intent match are [propagated to session parameters](/dialogflow/cx/docs/concept/parameter#prop) , which are available to partially or fully fill page form parameters.\nFallback intents and predefined follow-up intents do not exist in CX. See [built-in intents](#diff-built-in-intent) .\nThe following table describes how to map specific intent data from ES to CX resources:\n| ES Intent data     | Corresponding CX data       | Action required                                |\n|:---------------------------------|:----------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------|\n| Training phrases     | Intent training phrases      | Migrated by tool. Tool checks for system entity support, and creates TODO items for unsupported system entities.        |\n| Agent responses     | Fulfillment response messages     | See agent responses.                               |\n| Context for conversation control | nan           | See Structure and conversation path control.                         |\n| Webhook setting     | Fulfillment webhook configuration    | See webhooks.                                 |\n| Events       | Flow-level or Page-level event handlers  | See events.                                 |\n| Actions       | Fulfillment webhook tags      | See webhooks.                                 |\n| Parameters      | Intent parameters and/or Page form parameters | Migrated to intent parameters by tool. If the parameters are required, tool creates TODO items to possibly migrate to a page. See parameters. |\n| Parameter prompts    | Page form parameter prompts     | See form filling.                                |\n### Create flows\nCreate a flow for each high-level conversation topic. The topics in each flow should be distinct, so that the conversation does not frequently jump back and forth between flows.\nIf you were using a mega agent, each sub-agent should become one or more flows.\n### Start with basic conversation paths\nIt is best to test your agent with the simulator while iterating on changes. So, you should initially focus on the basic conversation paths early in the conversation, and test as you make changes. Once you get these working, move on to more detailed conversation paths.\n### Flow-level versus page-level state handlers\nWhen creating state handlers, consider whether they should be applied at flow-level or page-level. A flow-level handler is in scope whenever the flow (and hence any page within the flow) is active. A page-level handler is only in scope when the particular page is active. Flow-level handlers are similar to ES intents with no input context. Page-level handlers are similar to ES intents with input context.\n### Webhook code\nThe webhook request and response properties are different for CX. See the [webhooks section](#diff-webhook) .\n### Knowledge connectors\nCX does not support [knowledge connectors](/dialogflow/es/docs/knowledge-connectors) yet. You will need to implement these as normal intents or wait until Dialogflow CX supports knowledge connectors.\n### Agent settings\nReview your [ES agent settings](/dialogflow/es/docs/agents-settings) , and adjust your [CX agent settings](/dialogflow/cx/docs/concept/agent#settings) as needed.\n**Note:** If your agent settings do not have automatic training configured, you will need to manually train the agent before testing changes.\n### Utilize the TODO file\nThe migration tool outputs a CSV file. The items in this list are focused on particular pieces of data that may need attention. Import this file to a spreadsheet. Resolve each item in the spreadsheet, using a column for marking completion.\n### API usage migration\nIf your system uses the ES API for runtime or design-time calls, you will need to update this code to use the [CX API](/dialogflow/cx/docs/reference/api-overview) . If you only use the detect intent calls at runtime, this update should be fairly straightforward.\n### Integrations\nIf your agent uses integrations, see the [integrations section](#diff-integration) , and make changes as necessary.\n## Recommended migration steps\nThe following subsections outline recommended migration steps.\n### Validation\nUse [agent validation](/dialogflow/cx/docs/concept/validation) to check that your agent follows best practices.\n### Testing\nWhile performing manual migration steps above, you should test your agent with the [simulator](/dialogflow/cx/docs/concept/console#simulator) . Once your agent appears to be working, you should compare conversations between your ES and CX agents, and verify that behavior is similar or improved.\nWhile testing these conversations with the simulator, you should create [test cases](/dialogflow/cx/docs/concept/test-case) to prevent future regressions.\n### Environments\nReview your [ES environments](/dialogflow/es/docs/agents-versions) and update your [CX environments](/dialogflow/cx/docs/concept/version) as needed.", "guide": "Dialogflow"}