{"title": "Vertex AI Search and Conversation - Schemas: auto-detecting versus providing your own", "url": "https://cloud.google.com/generative-ai-app-builder/docs/provide-schema?hl=zh-cn", "abstract": "# Vertex AI Search and Conversation - Schemas: auto-detecting versus providing your own\n**Note:** This feature is a Preview offering, subject to the \"Pre-GA Offerings Terms\" of the [GCP Service Specific Terms](https://cloud.google.com/terms/service-terms) . Pre-GA products and features may have limited support, and changes to pre-GA products and features may not be compatible with other pre-GA versions. For more information, see the [launch stage descriptions](https://cloud.google.com/products#product-launch-stages) . Further, by using this feature, you agree to the [Generative AI Preview terms and conditions](https://cloud.google.com/trustedtester/aitos) (\"Preview Terms\"). For this feature, you can process personal data as outlined in the [Cloud Data Processing Addendum](https://cloud.google.com/terms/data-processing-terms) , subject to applicable restrictions and obligations in the Agreement (as defined in the Preview Terms).\nWhen you import structured data using the Google Cloud console, Vertex AI Search and Conversation auto-detects the schema. You can either use this auto-detected schema in your engine or use the API to provide a schema to indicate the structure of the data.\nIf you provide a schema and later update it with a new schema, the new schema must be backward compatible with the original. Otherwise the schema update fails.\n**Important:** If you don't provide a schema, the auto-detect feature can update your schema by incorporating any newly detected fields when you import new data. If any documents in your imported data contain new fields that are not backward compatible with your original schema, those documents will fail to import.\n", "content": "## Approaches to providing the schema for your data store\nThere are various approaches to determining the schema for structured data.\n### Auto-detect alone\nLet Vertex AI Search and Conversation auto-detect the data in the data store and provide the schema for you.\n- **Pros:** This is the most straightforward and recommended when you create your first test engine.\n- **Cons:** The quality of the search results and recommendations will typically not be as good as the other approaches.\n### Auto-detect and edit\nLet Vertex AI Search and Conversation auto-detect and suggest an initial schema and then you refine the schema through the console interface or through the command line. In particular, we highly recommend that, after your fields have been auto-detected, you map key properties to all the important fields.\n- **Pros:** This approach provides higher quality results than using auto-detect alone.\n- **Cons:** This approach takes the longest of the three because it is a multi-step process and requires indexing and re-indexing the data. However, this can be partially mitigated by uploading a small amount of data to start. See [About auto-detect and edit](#about-auto-and-edit) .\n### Providing the schema as a JSON object\nUsing the command line, or programmatically, you provide the schema to Vertex AI Search and Conversation as a JSON object.\n- **Pros:** This approach is faster than auto-detect followed by editing and  can provide equally good results.\n- **Cons:** This approach is not available from the console. You need to have prepared a correct JSON object.\n### Default schema for media data stores\nIf you create a data store for media, the default schema is applied to that data store. Auto-detect appends to the schema any new fields that it finds during data ingestion.\nFor information about creating a data store for media, see [Create media appsand data stores](/generative-ai-app-builder/docs/create-app-data-store-media-recommendations) .\n## About auto-detect and edit\nBecause it takes a long time to index large data stores and because data stores have to be re-indexed after the schema has been edited, the fastest way to apply the auto-detect and edit approach is as follows:\n- Ingest a small but representative subset of your data.For instructions on ingesting data, see [Create a search data store](/generative-ai-app-builder/docs/create-data-store-es) or [Create a recommendations data store](/generative-ai-app-builder/docs/create-data-store-recommendations) .Auto-detect will create a schema based on this ingested data. If you are ingesting only a small amount of data, it won't take long to create the schema and index the data.\n- Review the schema suggested by auto-detect:- Map the key properties to fields. For more information about mapping properties, see [Configure field settings](/generative-ai-app-builder/docs/configure-field-settings) .\n- Add new fields, if necessary.For example, if a few of your documents include a thumbnail, but none of the documents in your initial ingestion had the thumbnail, then add a thumbnail field to the schema. Or, if you know that a field isn't yet in your data but that it will be coming soon, add it now.For instructions on how to add fields to a schema, see [Update yourschema](/generative-ai-app-builder/docs/update-schemas#genappbuilder_update_schema-console) .\n- After confirming that everything looks good, save the schema.\n- Ingest the rest of your data into the data store. For a large data store, you can expect to wait some hours before the data store in indexed.## About providing your own schema as a JSON object\nExcept in the case of media data stores, you can define your own schema using the [JSON Schema](https://json-schema.org/) format, which is an open source, declarative language to define, annotate, and validate JSON documents. For example, this is a valid JSON schema annotation:\n```\n{\u00a0 \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\u00a0 \"type\": \"object\",\u00a0 \"properties\": {\u00a0 \u00a0 \"title\": {\u00a0 \u00a0 \u00a0 \"type\": \"string\",\u00a0 \u00a0 \u00a0 \"keyPropertyMapping\": \"title\",\u00a0 \u00a0 \u00a0 \"retrievable\": true,\u00a0 \u00a0 \u00a0 \"completable\": true\u00a0 \u00a0 },\u00a0 \u00a0 \"description\": {\u00a0 \u00a0 \u00a0 \"type\": \"string\",\u00a0 \u00a0 \u00a0 \"keyPropertyMapping\": \"description\"\u00a0 \u00a0 },\u00a0 \u00a0 \"categories\": {\u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \"items\": {\u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"string\",\u00a0 \u00a0 \u00a0 \u00a0 \"keyPropertyMapping\": \"category\",\u00a0 \u00a0 \u00a0 \u00a0 \"dynamicFacetable\": true\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 },\u00a0 \u00a0 \"uri\": {\u00a0 \u00a0 \u00a0 \"type\": \"string\",\u00a0 \u00a0 \u00a0 \"keyPropertyMapping\": \"uri\"\u00a0 \u00a0 },\u00a0 \u00a0 \"locations\": {\u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \"items\": {\u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"object\",\u00a0 \u00a0 \u00a0 \u00a0 \"properties\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"address\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"string\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"indexable\": true,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"searchable\": true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"lat\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"number\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"indexable\": true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"lng\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"number\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"indexable\": true\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 }}\n```\nHere are some of the fields in this schema example:\n- **keyPropertyMapping** . A field that maps predefined keywords to critical fields in your documents, helping to clarify their semantic meaning. Values include `title` , `description` , `uri` , and `category` . Note that your field name doesn't need to match the `keyPropertyValues` value. For example, for a field that you named `my_title` , you can include a `keyPropertyValues` field with a value of `title` . **For Vertex AI Search:** fields marked with `keyPropertyMapping` are by default indexable and searchable, but not retrievable, completable, or dynamicFacetable. This means that you don't need to include the `indexable` or `searchable` fields with a `keyPropertyValues` field to get the expected default behavior. **Note:** Key properties are can improve the quality of search and  recommendations results and search autocomplete accuracy. If you use  auto-schema detection, key properties are not automatically added. We  highly recommended using the `schemas.patch` method to mark data fields  as key properties, especially `title` , `uri` , and `description` .\n- **type** . The type of the field. This is a string value that is one of the primitive types ( `boolean` , `object` , `array` , `number` , or `string` ), or `integer` .\nThe following fields apply only for search apps:\n- **retrievable** . Indicates whether this field can be returned in a search response. This can only be set for fields of the `number` , `string` , or `integer` type. A maximum of 50 fields can be set as retrievable. User-defined fields and `keyPropertyValues` fields are not retrievable by default. To make a field retrievable, include `\"retrievable\": true` with the field.\n- **indexable** . Indicates whether this field can be filtered, faceted, boosted, or sorted in the [servingConfigs.search](/generative-ai-app-builder/docs/reference/rest/v1beta/projects.locations.collections.dataStores.servingConfigs/search) method. This can only be set for fields of the `number` , `string` , or `integer` type. A maximum of 50 fields can be set as indexable. User-defined fields are not indexable by default, except for fields containing the `keyPropertyMapping` field. To make a field indexable, include `\"indexable\": true` with the field.\n- **dynamicFacetable** . Indicates that the field can be used as a dynamic facet. This can be set for fields of `number` , `string` , and `integer` types. To make a field dynamically facetable, include `\"dynamicFacetable\": true` with the field.\n- **searchable** . Indicates whether this field can be reverse indexed to match unstructured text queries. This can only be set for fields of the `string` type. A maximum of 50 fields can be set as searchable. User-defined fields are not searchable by default, except for fields containing the `keyPropertyMapping` field. To make a field searchable, include `\"searchable\": true` with the field.\n- **completable** . Indicates whether this field can be returned as an autocomplete suggestion. This can only be set for fields of `string` type. To make a field completable, include `\"completable\": true` with the field.\n**Note:** For auto-detected schemas, newly detected fields are automatically indexable, searchable, and retrievable, as long as they follow the type requirements and stay within the maximum limits.\n## What's next\n- [Create a search app](/generative-ai-app-builder/docs/create-engine-es) \n- [Create a recommendations app](/generative-ai-app-builder/docs/create-engine-personalize) \n- [Get the schema definition for structured data](/generative-ai-app-builder/docs/get-schema-definition) \n- [Update a schema for structured data](/generative-ai-app-builder/docs/update-schemas)", "guide": "Vertex AI Search and Conversation"}