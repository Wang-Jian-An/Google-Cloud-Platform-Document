{"title": "Document AI - Package google.type", "url": "https://cloud.google.com/document-ai/docs/reference/rpc/google.type?hl=zh-cn", "abstract": "# Document AI - Package google.type\n", "content": "## Index\n- ` [Color](/document-ai/docs/reference/rpc/google.type#google.type.Color) `(message)\n- ` [Date](/document-ai/docs/reference/rpc/google.type#google.type.Date) `(message)\n- ` [DateTime](/document-ai/docs/reference/rpc/google.type#google.type.DateTime) `(message)\n- ` [Money](/document-ai/docs/reference/rpc/google.type#google.type.Money) `(message)\n- ` [PostalAddress](/document-ai/docs/reference/rpc/google.type#google.type.PostalAddress) `(message)\n- ` [TimeZone](/document-ai/docs/reference/rpc/google.type#google.type.TimeZone) `(message)\n## Color\nRepresents a color in the RGBA color space. This representation is designed for simplicity of conversion to and from color representations in various languages over compactness. For example, the fields of this representation can be trivially provided to the constructor of `java.awt.Color` in Java; it can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha` method in iOS; and, with just a little work, it can be easily formatted into a CSS `rgba()` string in JavaScript.\nThis reference page doesn't have information about the absolute color space that should be used to interpret the RGB value\u2014for example, sRGB, Adobe RGB, DCI-P3, and BT.2020. By default, applications should assume the sRGB color space.\nWhen color equality needs to be decided, implementations, unless documented otherwise, treat two colors as equal if all their red, green, blue, and alpha values each differ by at most `1e-5` .\nExample (Java):\n```\n import com.google.type.Color;\n // ...\n public static java.awt.Color fromProto(Color protocolor) {\n float alpha = protocolor.hasAlpha()\n  ? protocolor.getAlpha().getValue()\n  : 1.0;\n return new java.awt.Color(\n  protocolor.getRed(),\n  protocolor.getGreen(),\n  protocolor.getBlue(),\n  alpha);\n }\n public static Color toProto(java.awt.Color color) {\n float red = (float) color.getRed();\n float green = (float) color.getGreen();\n float blue = (float) color.getBlue();\n float denominator = 255.0;\n Color.Builder resultBuilder =\n  Color\n   .newBuilder()\n   .setRed(red / denominator)\n   .setGreen(green / denominator)\n   .setBlue(blue / denominator);\n int alpha = color.getAlpha();\n if (alpha != 255) {\n  result.setAlpha(\n   FloatValue\n    .newBuilder()\n    .setValue(((float) alpha) / denominator)\n    .build());\n }\n return resultBuilder.build();\n }\n // ...\n```\nExample (iOS / Obj-C):\n```\n // ...\n static UIColor* fromProto(Color* protocolor) {\n float red = [protocolor red];\n float green = [protocolor green];\n float blue = [protocolor blue];\n FloatValue* alpha_wrapper = [protocolor alpha];\n float alpha = 1.0;\n if (alpha_wrapper != nil) {\n  alpha = [alpha_wrapper value];\n }\n return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];\n }\n static Color* toProto(UIColor* color) {\n  CGFloat red, green, blue, alpha;\n  if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {\n  return nil;\n  }\n  Color* result = [[Color alloc] init];\n  [result setRed:red];\n  [result setGreen:green];\n  [result setBlue:blue];\n  if (alpha <= 0.9999) {\n  [result setAlpha:floatWrapperWithValue(alpha)];\n  }\n  [result autorelease];\n  return result;\n}\n// ...\n```\nExample (JavaScript):\n```\n// ...\nvar protoToCssColor = function(rgb_color) {\n var redFrac = rgb_color.red || 0.0;\n var greenFrac = rgb_color.green || 0.0;\n var blueFrac = rgb_color.blue || 0.0;\n var red = Math.floor(redFrac * 255);\n var green = Math.floor(greenFrac * 255);\n var blue = Math.floor(blueFrac * 255);\n if (!('alpha' in rgb_color)) {\n  return rgbToCssColor(red, green, blue);\n }\n var alphaFrac = rgb_color.alpha.value || 0.0;\n var rgbParams = [red, green, blue].join(',');\n return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');\n};\nvar rgbToCssColor = function(red, green, blue) {\n var rgbNumber = new Number((red << 16) | (green << 8) | blue);\n var hexString = rgbNumber.toString(16);\n var missingZeros = 6 - hexString.length;\n var resultBuilder = ['#'];\n for (var i = 0; i < missingZeros; i++) {\n  resultBuilder.push('0');\n }\n resultBuilder.push(hexString);\n return resultBuilder.join('');\n};\n// ...\n```| Fields | Fields.1                                                                                                                                                       |\n|:---------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| red  | float The amount of red in the color as a value in the interval [0, 1].                                                                                                                                       |\n| green | float The amount of green in the color as a value in the interval [0, 1].                                                                                                                                       |\n| blue  | float The amount of blue in the color as a value in the interval [0, 1].                                                                                                                                       |\n| alpha | FloatValue The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation:pixel color = alpha * (this color) + (1.0 - alpha) * (background color)This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0). |\n## Date\nRepresents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following:- A full date, with non-zero year, month, and day values.\n- A month and day, with a zero year (for example, an anniversary).\n- A year on its own, with a zero month and a zero day.\n- A year and month, with a zero day (for example, a credit card expiration date).Related types:- `google.type.TimeOfDay`\n- ` [google.type.DateTime](/document-ai/docs/reference/rpc/google.type#google.type.DateTime) `\n- ` [google.protobuf.Timestamp](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp) `\n| Fields | Fields.1                                       |\n|:---------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| year  | int32 Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.                    |\n| month | int32 Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.                  |\n| day  | int32 Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. |\n## DateTime\nRepresents civil time (or occasionally physical time).\nThis type can represent a civil time in one of a few possible ways:- When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC.\n- When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone.\n- When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time.The date is relative to the Proleptic Gregorian Calendar.\nIf year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively.\nThis type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user's timezone, that can be done in another field.\nThis type is more flexible than some applications may want. Make sure to document and validate your application's limitations.| Fields                                                                                                         | Fields.1                                                                                                        |\n|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| year                                                                                                         | int32 Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.                                                                                  |\n| month                                                                                                         | int32 Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.                                                                                  |\n| day                                                                                                          | int32 Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.                                                                          |\n| hours                                                                                                         | int32 Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.                                                            |\n| minutes                                                                                                         | int32 Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.                                                                                       |\n| seconds                                                                                                         | int32 Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.                                                                     |\n| nanos                                                                                                         | int32 Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.                                                                                  |\n| Union field time_offset. Optional. Specifies either the UTC offset or the time zone of the DateTime. Choose carefully between them, considering that time zone data may change in the future (for example, a country modifies their DST start/end dates, and future DateTimes in the affected range had already been stored). If omitted, the DateTime is considered to be in local time. time_offset can be only one of the following: | Union field time_offset. Optional. Specifies either the UTC offset or the time zone of the DateTime. Choose carefully between them, considering that time zone data may change in the future (for example, a country modifies their DST start/end dates, and future DateTimes in the affected range had already been stored). If omitted, the DateTime is considered to be in local time. time_offset can be only one of the following: |\n| utc_offset                                                                                                        | Duration UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.                                                                   |\n| time_zone                                                                                                        | TimeZone Time zone.                                                                                                      |\n## Money\nRepresents an amount of money with its currency type.| Fields  | Fields.1                                                                                       |\n|:--------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| currency_code | string The three-letter currency code defined in ISO 4217.                                                                           |\n| units   | int64 The whole units of the amount. For example if currencyCode is \"USD\", then 1 unit is one US dollar.                                                               |\n| nanos   | int32 Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If units is positive, nanos must be positive or zero. If units is zero, nanos can be positive, zero, or negative. If units is negative, nanos must be negative or zero. For example $-1.75 is represented as units=-1 and nanos=-750,000,000. |\n## PostalAddress\nRepresents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains).\nIn typical usage an address would be created via user input or from importing existing data, depending on the type of process.\nAdvice on address input / editing: - Use an internationalization-ready address widget such as [https://github.com/google/libaddressinput](https://github.com/google/libaddressinput) ) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used.\nFor more guidance on how to use this schema, please see: [https://support.google.com/business/answer/6397478](https://support.google.com/business/answer/6397478) | Fields    | Fields.1                                                                                                                                                                                                                                                                                                              |\n|:--------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| revision   | int32 The schema revision of the PostalAddress. This must be set to 0, which is the latest revision.All new revisions must be backward compatible with old revisions.                                                                                                                                                                                                                                                                       |\n| region_code   | string Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: \"CH\" for Switzerland.                                                                                                                                                                                                                                   |\n| language_code  | string Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).Examples: \"zh-Hant\", \"ja\", \"ja-Latn\", \"en\".                                                                                                                                                                 |\n| postal_code   | string Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).                                                                                                                                                                                                                                                   |\n| sorting_code  | string Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like \"CEDEX\", optionally followed by a number (e.g. \"CEDEX 7\"), or just a number alone, representing the \"sector code\" (Jamaica), \"delivery area indicator\" (Malawi) or \"post office indicator\" (e.g. C\u00f4te d'Ivoire).                                                                                                                                                                                                                        |\n| administrative_area | string Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. \"Barcelona\" and not \"Catalonia\"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.                                                                                                                                                                                                      |\n| locality   | string Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.                                                                                                                                                                                                                                              |\n| sublocality   | string Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.                                                                                                                                                                                                                                                                                      |\n| address_lines[]  | string Unstructured address lines describing the lower levels of an address.Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. \"Austin, TX\"), it is important that the line order is clear. The order of address lines should be \"envelope order\" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. \"ja\" for large-to-small ordering and \"ja-Latn\" or \"en\" for small-to-large). This way, the most specific line of an address can be selected based on the language.The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas). |\n| recipients[]  | string Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain \"care of\" information.                                                                                                                                                                                                                                                                     |\n| organization  | string Optional. The name of the organization at the address.                                                                                                                                                                                                                                                                                                 |\n## TimeZone\nRepresents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones) .| Fields | Fields.1                |\n|:---------|:-----------------------------------------------------------------------|\n| id  | string IANA Time Zone Database time zone, e.g. \"America/New_York\".  |\n| version | string Optional. IANA Time Zone Database version number, e.g. \"2019a\". |", "guide": "Document AI"}