{"title": "Cloud SQL - Optimize high CPU usage in instances", "url": "https://cloud.google.com/sql/docs/postgres/optimize-cpu-usage", "abstract": "# Cloud SQL - Optimize high CPU usage in instances\nHigh CPU utilization adversely affects the performance of your instance. Any activity that's performed on the instance uses CPU. Hence, if there's a high CPU utilization notice, you should first identify the root cause of the issue, whether that's poorly written queries, long running transactions, or any other database activity.\nThis document describes the ways to identify CPU bottlenecks in an instance and mitigate the CPU utilization issues in the instance.\n", "content": "## Identify the CPU bottlenecks\n### Use query insights to identify queries that have high CPU consumption\n[Query insights](/sql/docs/postgres/using-query-insights) helps you detect, diagnose, and prevent query performance problems for Cloud SQL databases.\n### Use the pg_proctab extension\nUse the [pg_proctab](/sql/docs/postgres/extensions#pg_proctab) extension with the combination of the `pg_top` utility to get operating system outputs that give per process CPU utilization information.\n### Use queries\nEach active connection to the database takes some amount of CPU, so if the instance has a high number of connections, cumulative utilization could be high. Use the following query to get the information about the number of connections by state.\n```\nSELECT \u00a0 state, \u00a0 usename, \u00a0 count(1) FROM \u00a0 pg_stat_activity WHERE \u00a0 pid <> pg_backend_pid() group by \u00a0 state, \u00a0 usename order by \u00a0 1;\n```\nThe output looks similar to the following:\n```\n\u00a0 \u00a0 \u00a0 \u00a0 state \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0usename \u00a0 \u00a0| count ---------------------+---------------+-------\u00a0active \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| ltest \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 318\u00a0active \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| sbtest \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a095\u00a0active \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 2\u00a0idle \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| cloudsqladmin | \u00a0 \u00a0 2\u00a0idle in transaction | ltest \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a032\u00a0idle in transaction | sbtest \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 5\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| cloudsqladmin | \u00a0 \u00a0 3\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 4(8 rows)\n```\nIf the active connections count is high, check for long running queries or wait events that are blocking the queries from executing.\nIf the idle connection count is high, execute the following query to terminate the connections, after taking the necessary approvals.\n```\nSELECT \u00a0 pg_terminate_backend(pid) FROM \u00a0 pg_stat_activity WHERE \u00a0 usename = 'sbtest' \u00a0 and pid <> pg_backend_pid() \u00a0 and state in ('idle');\n```\nYou can also terminate the connections individually with `pg_terminate_backend` using the following query:\n```\nSELECT pg_terminate_backend (<pid>);\n```\nHere, you can obtain the PID from `pg_stat_activity` .\nHere's an example of a query that returns long running queries. In this case, you can identify the queries that have been active for more than 5 minutes.\n```\nSELECT \u00a0 pid, \u00a0 query_start, \u00a0 xact_start, \u00a0 now() - pg_stat_activity.query_start AS duration, \u00a0 query, \u00a0 state FROM \u00a0 pg_stat_activity WHERE \u00a0 (\u00a0 \u00a0 now() - pg_stat_activity.query_start\u00a0 ) > interval '5 minutes' order by 4 desc;\n```\nUse the EXPLAIN PLAN to investigate a poorly written query and rewrite the query, if necessary. Optionally, consider cancelling the long running query with the following command with necessary approvals.\n```\nSELECT pg_cancel_backend(<pid>);\n```\nThe AUTOVACUUM activity that clears the dead tuples is a CPU-intensive operation. If your instance uses PostgreSQL version 11 or later, use the following query to check if there's any active AUTOVACUUM or VACUUM activity in progress.\n```\nSELECT \u00a0 relid :: regclass, \u00a0 pid, \u00a0 phase, \u00a0 heap_blks_total, \u00a0 heap_blks_scanned, \u00a0 heap_blks_vacuumed, \u00a0 index_vacuum_count, \u00a0 max_dead_tuples, \u00a0 num_dead_tuples FROM \u00a0 pg_stat_progress_vacuum;\n```\nCheck if there's an ongoing VACUUM activity in an instance using the following query:\n```\nSELECT \u00a0 pid, \u00a0 datname,\u00a0 usename, \u00a0 query FROM \u00a0 pg_stat_activity WHERE \u00a0 query like '%vacuum%';\n```\nAdditonally, you can [optimize and troubleshoot VACUUM operations in PostgreSQL](https://cloud.google.com/solutions/optimizing-monitoring-troubleshooting-vacuum-operations-postgresql) .\nSet up the `pg_stat_statements` extension to get enhanced dictionary information about instance activity.\nFrequent checkpoints degrade performance. Consider adjusting the `checkpoint_timeout` flag if the PostgreSQL alert log reports the `checkpoint occurring too frequently` warning.\nEnsure that the query planner has the latest statistics about tables to choose the best plan for queries. The ANALYZE operation collects statistics about the contents of tables in the database, and stores the results in the pg_statistic system catalog. Subsequently, the query planner uses these statistics to help determine the most efficient execution plans for queries. The AUTOVACUUM process automatically analyzes the tables periodically, so run the following command to check if all the tables have been analyzed and have the latest metadata available to the planner.\n```\nSELECT \u00a0 relname, \u00a0 last_autovacuum, \u00a0 last_autoanalyze FROM \u00a0 pg_stat_user_tables;\n```\nThere are other factors and flag settings or system factors that influence the performance of your query. Run the following query to check the wait events and wait event type to get the insights about the performance of other system settings.\n```\nSELECT \u00a0 datname, \u00a0 usename, \u00a0 (\u00a0 \u00a0 case when usename is not null then state else query end\u00a0 ) AS what, \u00a0 wait_event_type, \u00a0 wait_event, \u00a0 backend_type, \u00a0 count(*) FROM \u00a0 pg_stat_activity GROUP BY \u00a0 1, \u00a0 2, \u00a0 3, \u00a0 4, \u00a0 5, \u00a0 6 ORDER BY \u00a0 1, \u00a0 2, \u00a0 3, \u00a0 4 nulls first, \u00a0 5, \u00a0 6;\n```\nThe output looks similar to this:\n```\n\u00a0 \u00a0.. \u00a0| .. | what \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | wait_event_type | \u00a0 \u00a0 \u00a0wait_event \u00a0 \u00a0 \u00a0| .. \u00a0 \u00a0| count-..--+-..-+----------------+-----------------+----------------------+-..----+------\u00a0..\u00a0.. \u00a0| .. | active \u00a0 \u00a0 \u00a0 \u00a0 | IO \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| CommitWaitFlush \u00a0 \u00a0 \u00a0| .. \u00a0 \u00a0| \u00a0 750\u00a0.. \u00a0| .. | idle \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | IO \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| CommitWaitFlush \u00a0 \u00a0 \u00a0| .. \u00a0 \u00a0| \u00a0 360\u00a0.. \u00a0| .. | active \u00a0 \u00a0 \u00a0 \u00a0 | LWLock \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| BufferMapping \u00a0 \u00a0 \u00a0 \u00a0| .. \u00a0 \u00a0| \u00a0 191\u00a0 \n```\nFrequent sequential scans over tables of more than a few tens of rows usually indicate a missing index. When the scans touch thousands or even hundreds of thousands of rows, it can cause excessive CPU usage.\nFrequent sequential scans on tables with hundreds of thousands of rows can cause excessive CPU usage. Avoid sequential scans on such tables by creating necessary indices.\nRun the following query to check the number of times sequential scans are initiated on any table.\n```\nSELECT \u00a0 relname, \u00a0 idx_scan, \u00a0\u00a0 seq_scan, \u00a0 n_live_tup FROM \u00a0 pg_stat_user_tables WHERE \u00a0 seq_scan > 0 ORDER BY \u00a0 n_live_tup desc;\n```\nLastly, if the CPU is still high and you feel those queries are legitimate traffic then consider increasing the CPU resources in your instance to avoid database crash or downtime.", "guide": "Cloud SQL"}