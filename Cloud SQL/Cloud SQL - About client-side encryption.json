{"title": "Cloud SQL - About client-side encryption", "url": "https://cloud.google.com/sql/docs/postgres/client-side-encryption", "abstract": "# Cloud SQL - About client-side encryption\nThis page describes how to implement client-side encryption on Cloud SQL.\n", "content": "## Overview\nClient-side encryption is the act of encrypting data before writing it to Cloud SQL. You can encrypt Cloud SQL data in a manner that only your application can decrypt.\nTo enable client-side encryption you have the following options:\n- Using an encryption key stored in the Cloud Key Management Service (Cloud KMS).\n- Using an encryption key stored locally in your application.\nIn this topic, we describe how to use the first option, which provides the most seamless key management option. We create an encryption key in Cloud KMS and implement [envelope encryption](/kms/docs/envelope-encryption) using [Tink](https://github.com/google/tink) , Google's open source cryptographic library.\n### Why do you need client-side encryption?\nYou need client-side encryption if you want to protect Cloud SQL data at the column level . Imagine you have a table of names and credit card numbers. You want to grant a user access to this table, but you don't want them to view the credit card numbers. You can encrypt the numbers using client-side encryption. As long as the user is not granted access to the encryption key in Cloud KMS, they can't read the credit card information.\n### Create keys using Cloud KMS\nCloud KMS lets you create and manage keys on Google Cloud Platform.\nCloud KMS supports many different key types. For client-side encryption, you need to create a [symmetric key](/kms/docs/creating-keys) .\nTo give your application access to the key in Cloud KMS, you need to grant the service account that your application uses with the `cloudkms.cryptoKeyEncrypterDecrypter` role. In gcloud, you use the following command to do this:\n```\ngcloud kms keys add-iam-policy-binding key \\--keyring=key-ring \\--location=location \\--member=serviceAccount:service-account-name@example.domain.com \\--role=roles/cloudkms.cryptoKeyEncrypterDecrypter\n```\nWhile you can use the KMS key to directly [encrypt data](/kms/docs/encrypt-decrypt) , here we use a more flexible solution called . This allows us to encrypt messages longer than 64KB, which is the maximum message size that the Cloud Key Management Service API can support.\n### Cloud KMS envelope encryption\nIn envelope encryption, the KMS key acts as a key encrypting key (KEK). That is, it is used to encrypt data encryption keys (DEK) which in turn are used to encrypt actual data.\nAfter creating a KEK in Cloud KMS, to encrypt each message you need to:\n- Generate a data encryption key (DEK) locally.\n- Use this DEK locally to encrypt the message.\n- Call Cloud KMS to encrypt (wrap) the DEK with the KEK.\n- Store the encrypted data and the wrapped DEK.\nInstead of implementing envelope encryption from scratch, in this topic we use Tink.\n### Tink\nTink is a multi-language, cross-platform library that provides high-level cryptographic APIs. To encrypt data with Tink's envelope encryption, you provide Tink with a key URI pointing to your KEK in Cloud KMS, and credentials that allow Tink to use the KEK. Tink generates the DEK, encrypts the data, wraps the DEK and returns a single ciphertext with the encrypted data and wrapped DEK.\nTink supports envelope encryption in C++, Java, Go, and Python using the AEAD API:\n```\npublic interface Aead{\u00a0 byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\u00a0 throws\u2026\u00a0 byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\u00a0 throws\u2026}\n```\nBesides the normal message/ciphertext argument, the encrypt and decrypt methods support optional associated data. This argument can be used to tie the ciphertext to a piece of data. For example, suppose you have a database with a field `user-id` and a field `encrypted-medical-history` . In this case, the field `user-id` should probably be used as associated data when encrypting the medical history. This ensures that an attacker cannot move medical history from one user to another. It is also used to verify that you have the correct row of data when you run a query.\n## Samples\nIn this section, we'll walk through sample code for a voter information database that uses client-side encryption. The sample code shows how to:\n- Create a database table and connection pool\n- Set up Tink for envelope encryption\n- Encrypt and decrypt data using Tink's envelope encryption with a KEK in Cloud KMS\n### Before you begin\n- Create a Cloud SQL Instance by following these [instructions](https://cloud.google.com/sql/docs/postgres/create-instance) . Note the connection string, database user, and database password that you create.\n- Create a database for your application by following these [instructions](https://cloud.google.com/sql/docs/postgres/create-manage-databases) . Note the database name.\n- Create a KMS key for your application by following these [instructions](https://cloud.google.com/kms/docs/creating-keys) . Copy the resource name of your created key.\n- Create a service account with the 'Cloud SQL Client' permissions by following these [instructions](https://cloud.google.com/sql/docs/postgres/connect-external-app#4_if_required_by_your_authentication_method_create_a_service_account) .\n- Add the 'Cloud KMS CryptoKey Encrypter/Decrypter' permission for the key to your service account by following these [instructions](https://cloud.google.com/kms/docs/iam) .\n### Create a connection pool and create a new table in the database.\n[  cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/CloudSqlConnectionPool.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/CloudSqlConnectionPool.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/CloudSqlConnectionPool.java) \n```\nimport com.zaxxer.hikari.HikariConfig;import com.zaxxer.hikari.HikariDataSource;import java.security.GeneralSecurityException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import javax.sql.DataSource;public class CloudSqlConnectionPool {\u00a0 public static DataSource createConnectionPool(String dbUser, String dbPass, String dbName,\u00a0 \u00a0 \u00a0 String instanceConnectionName) throws GeneralSecurityException {\u00a0 \u00a0 HikariConfig config = new HikariConfig();\u00a0 \u00a0 config.setJdbcUrl(String.format(\"jdbc:postgresql:///%s\", dbName));\u00a0 \u00a0 config.setUsername(dbUser); // e.g. \"root\", \"postgres\"\u00a0 \u00a0 config.setPassword(dbPass); // e.g. \"my-password\"\u00a0 \u00a0 config.addDataSourceProperty(\"socketFactory\", \"com.google.cloud.sql.postgres.SocketFactory\");\u00a0 \u00a0 config.addDataSourceProperty(\"cloudSqlInstance\", instanceConnectionName);\u00a0 \u00a0 DataSource pool = new HikariDataSource(config);\u00a0 \u00a0 return pool;\u00a0 }\u00a0 public static void createTable(DataSource pool, String tableName) throws SQLException {\u00a0 \u00a0 // Safely attempt to create the table schema.\u00a0 \u00a0 try (Connection conn = pool.getConnection()) {\u00a0 \u00a0 \u00a0 String stmt = String.format(\"CREATE TABLE IF NOT EXISTS %s ( \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"vote_id SERIAL NOT NULL, time_cast timestamp NOT NULL, team CHAR(6) NOT NULL,\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"voter_email BYTEA, PRIMARY KEY (vote_id) );\", tableName);\u00a0 \u00a0 \u00a0 try (PreparedStatement createTableStatement = conn.prepareStatement(stmt);) {\u00a0 \u00a0 \u00a0 \u00a0 createTableStatement.execute();\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 }}\n``` [  cloud-sql/postgres/client-side-encryption/snippets/cloud_sql_connection_pool.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/cloud_sql_connection_pool.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/cloud_sql_connection_pool.py) \n```\nimport sqlalchemydef init_tcp_connection_engine(\u00a0 \u00a0 db_user: str, db_pass: str, db_name: str, db_host: str) -> sqlalchemy.engine.base.Engine:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Creates a connection to the database using tcp socket.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 # Remember - storing secrets in plaintext is potentially unsafe. Consider using\u00a0 \u00a0 # something like https://cloud.google.com/secret-manager/docs/overview to help keep\u00a0 \u00a0 # secrets secret.\u00a0 \u00a0 # Extract host and port from db_host\u00a0 \u00a0 host_args = db_host.split(\":\")\u00a0 \u00a0 db_hostname, db_port = host_args[0], int(host_args[1])\u00a0 \u00a0 pool = sqlalchemy.create_engine(\u00a0 \u00a0 \u00a0 \u00a0 # Equivalent URL:\u00a0 \u00a0 \u00a0 \u00a0 # postgresql+pg8000://<db_user>:<db_pass>@<db_host>:<db_port>/<db_name>\u00a0 \u00a0 \u00a0 \u00a0 sqlalchemy.engine.url.URL.create(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 drivername=\"postgresql+pg8000\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 username=db_user, \u00a0# e.g. \"my-database-user\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 password=db_pass, \u00a0# e.g. \"my-database-password\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 host=db_hostname, \u00a0# e.g. \"127.0.0.1\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port=db_port, \u00a0# e.g. 5432\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 database=db_name, \u00a0# e.g. \"my-database-name\"\u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 )\u00a0 \u00a0 print(\"Created TCP connection pool\")\u00a0 \u00a0 return pooldef init_unix_connection_engine(\u00a0 \u00a0 db_user: str,\u00a0 \u00a0 db_pass: str,\u00a0 \u00a0 db_name: str,\u00a0 \u00a0 instance_connection_name: str,\u00a0 \u00a0 db_socket_dir: str,) -> sqlalchemy.engine.base.Engine:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Creates a connection to the database using unix socket.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 # Remember - storing secrets in plaintext is potentially unsafe. Consider using\u00a0 \u00a0 # something like https://cloud.google.com/secret-manager/docs/overview to help keep\u00a0 \u00a0 # secrets secret.\u00a0 \u00a0 pool = sqlalchemy.create_engine(\u00a0 \u00a0 \u00a0 \u00a0 # Equivalent URL:\u00a0 \u00a0 \u00a0 \u00a0 # mpostgresql+pg8000://<db_user>:<db_pass>@/<db_name>?unix_socket=<socket_path>/<cloud_sql_instance_name>\u00a0 \u00a0 \u00a0 \u00a0 sqlalchemy.engine.url.URL.create(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 drivername=\"postgresql+pg8000\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 username=db_user, \u00a0# e.g. \"my-database-user\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 password=db_pass, \u00a0# e.g. \"my-database-password\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 database=db_name, \u00a0# e.g. \"my-database-name\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 query={\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"unix_sock\": \"{}/{}/.s.PGSQL.5432\".format(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 db_socket_dir, instance_connection_name \u00a0# e.g. \"/cloudsql\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ) \u00a0# i.e \"<PROJECT-NAME>:<INSTANCE-REGION>:<INSTANCE-NAME>\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 )\u00a0 \u00a0 print(\"Created Unix socket connection pool\")\u00a0 \u00a0 return pooldef init_db(\u00a0 \u00a0 db_user: str,\u00a0 \u00a0 db_pass: str,\u00a0 \u00a0 db_name: str,\u00a0 \u00a0 table_name: str,\u00a0 \u00a0 instance_connection_name: str = None,\u00a0 \u00a0 db_socket_dir: str = None,\u00a0 \u00a0 db_host: str = None,) -> sqlalchemy.engine.base.Engine:\u00a0 \u00a0 \"\"\"Starts a connection to the database and creates voting table if it doesn't exist.\"\"\"\u00a0 \u00a0 if db_host:\u00a0 \u00a0 \u00a0 \u00a0 db = init_tcp_connection_engine(db_user, db_pass, db_name, db_host)\u00a0 \u00a0 else:\u00a0 \u00a0 \u00a0 \u00a0 db = init_unix_connection_engine(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 db_user, db_pass, db_name, instance_connection_name, db_socket_dir\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 # Create tables (if they don't already exist)\u00a0 \u00a0 with db.connect() as conn:\u00a0 \u00a0 \u00a0 \u00a0 conn.execute(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 f\"CREATE TABLE IF NOT EXISTS {table_name} \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"( vote_id SERIAL NOT NULL, time_cast timestamp NOT NULL, \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"team VARCHAR(6) NOT NULL, voter_email BYTEA, \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"PRIMARY KEY (vote_id) );\"\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 print(f\"Created table {table_name} in db {db_name}\")\u00a0 \u00a0 return db\n```### Initialize an envelope AEAD primitive with Tink.\n[  cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/CloudKmsEnvelopeAead.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/CloudKmsEnvelopeAead.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/CloudKmsEnvelopeAead.java) \n```\nimport com.google.crypto.tink.Aead;import com.google.crypto.tink.KmsClient;import com.google.crypto.tink.aead.AeadConfig;import com.google.crypto.tink.aead.AeadKeyTemplates;import com.google.crypto.tink.aead.KmsEnvelopeAead;import com.google.crypto.tink.integration.gcpkms.GcpKmsClient;import java.security.GeneralSecurityException;public class CloudKmsEnvelopeAead {\u00a0 public static Aead get(String kmsUri) throws GeneralSecurityException {\u00a0 \u00a0 AeadConfig.register();\u00a0 \u00a0 // Create a new KMS Client\u00a0 \u00a0 KmsClient client = new GcpKmsClient().withDefaultCredentials();\u00a0 \u00a0 // Create an AEAD primitive using the Cloud KMS key\u00a0 \u00a0 Aead gcpAead = client.getAead(kmsUri);\u00a0 \u00a0 // Create an envelope AEAD primitive.\u00a0 \u00a0 // This key should only be used for client-side encryption to ensure authenticity and integrity\u00a0 \u00a0 // of data.\u00a0 \u00a0 return new KmsEnvelopeAead(AeadKeyTemplates.AES128_GCM, gcpAead);\u00a0 }}\n``` [  cloud-sql/postgres/client-side-encryption/snippets/cloud_kms_env_aead.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/cloud_kms_env_aead.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/cloud_kms_env_aead.py) \n```\nimport loggingimport tinkfrom tink import aeadfrom tink.integration import gcpkmslogger = logging.getLogger(__name__)def init_tink_env_aead(key_uri: str, credentials: str) -> tink.aead.KmsEnvelopeAead:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Initiates the Envelope AEAD object using the KMS credentials.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 aead.register()\u00a0 \u00a0 try:\u00a0 \u00a0 \u00a0 \u00a0 gcp_client = gcpkms.GcpKmsClient(key_uri, credentials)\u00a0 \u00a0 \u00a0 \u00a0 gcp_aead = gcp_client.get_aead(key_uri)\u00a0 \u00a0 except tink.TinkError as e:\u00a0 \u00a0 \u00a0 \u00a0 logger.error(\"Error initializing GCP client: %s\", e)\u00a0 \u00a0 \u00a0 \u00a0 raise e\u00a0 \u00a0 # Create envelope AEAD primitive using AES256 GCM for encrypting the data\u00a0 \u00a0 # This key should only be used for client-side encryption to ensure authenticity and integrity\u00a0 \u00a0 # of data.\u00a0 \u00a0 key_template = aead.aead_key_templates.AES256_GCM\u00a0 \u00a0 env_aead = aead.KmsEnvelopeAead(key_template, gcp_aead)\u00a0 \u00a0 print(f\"Created envelope AEAD Primitive using KMS URI: {key_uri}\")\u00a0 \u00a0 return env_aead\n```### Encrypt data and insert it into the database.\n[  cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/EncryptAndInsertData.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/EncryptAndInsertData.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/EncryptAndInsertData.java) \n```\nimport com.google.crypto.tink.Aead;import java.security.GeneralSecurityException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import java.sql.Timestamp;import java.util.Date;import javax.sql.DataSource;public class EncryptAndInsertData {\u00a0 public static void main(String[] args) throws GeneralSecurityException, SQLException {\u00a0 \u00a0 // Saving credentials in environment variables is convenient, but not secure - consider a more\u00a0 \u00a0 // secure solution such as Cloud Secret Manager to help keep secrets safe.\u00a0 \u00a0 String dbUser = System.getenv(\"DB_USER\"); // e.g. \"root\", \"postgres\"\u00a0 \u00a0 String dbPass = System.getenv(\"DB_PASS\"); // e.g. \"mysupersecretpassword\"\u00a0 \u00a0 String dbName = System.getenv(\"DB_NAME\"); // e.g. \"votes_db\"\u00a0 \u00a0 String instanceConnectionName =\u00a0 \u00a0 \u00a0 \u00a0 System.getenv(\"INSTANCE_CONNECTION_NAME\"); // e.g. \"project-name:region:instance-name\"\u00a0 \u00a0 String kmsUri = System.getenv(\"CLOUD_KMS_URI\"); // e.g. \"gcp-kms://projects/...path/to/key\u00a0 \u00a0 // Tink uses the \"gcp-kms://\" prefix for paths to keys stored in Google Cloud KMS. For more\u00a0 \u00a0 // info on creating a KMS key and getting its path, see\u00a0 \u00a0 // https://cloud.google.com/kms/docs/quickstart\u00a0 \u00a0 String team = \"TABS\";\u00a0 \u00a0 String tableName = \"votes\";\u00a0 \u00a0 String email = \"hello@example.com\";\u00a0 \u00a0 // Initialize database connection pool and create table if it does not exist\u00a0 \u00a0 // See CloudSqlConnectionPool.java for setup details\u00a0 \u00a0 DataSource pool =\u00a0 \u00a0 \u00a0 \u00a0 CloudSqlConnectionPool.createConnectionPool(dbUser, dbPass, dbName, instanceConnectionName);\u00a0 \u00a0 CloudSqlConnectionPool.createTable(pool, tableName);\u00a0 \u00a0 // Initialize envelope AEAD\u00a0 \u00a0 // See CloudKmsEnvelopeAead.java for setup details\u00a0 \u00a0 Aead envAead = CloudKmsEnvelopeAead.get(kmsUri);\u00a0 \u00a0 encryptAndInsertData(pool, envAead, tableName, team, email);\u00a0 }\u00a0 public static void encryptAndInsertData(\u00a0 \u00a0 \u00a0 DataSource pool, Aead envAead, String tableName, String team, String email)\u00a0 \u00a0 \u00a0 throws GeneralSecurityException, SQLException {\u00a0 \u00a0 try (Connection conn = pool.getConnection()) {\u00a0 \u00a0 \u00a0 String stmt =\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 String.format(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"INSERT INTO %s (team, time_cast, voter_email) VALUES (?, ?, ?);\", tableName);\u00a0 \u00a0 \u00a0 try (PreparedStatement voteStmt = conn.prepareStatement(stmt); ) {\u00a0 \u00a0 \u00a0 \u00a0 voteStmt.setString(1, team);\u00a0 \u00a0 \u00a0 \u00a0 voteStmt.setTimestamp(2, new Timestamp(new Date().getTime()));\u00a0 \u00a0 \u00a0 \u00a0 // Use the envelope AEAD primitive to encrypt the email, using the team name as\u00a0 \u00a0 \u00a0 \u00a0 // associated data. This binds the encryption of the email to the team name, preventing\u00a0 \u00a0 \u00a0 \u00a0 // associating an encrypted email in one row with a team name in another row.\u00a0 \u00a0 \u00a0 \u00a0 byte[] encryptedEmail = envAead.encrypt(email.getBytes(), team.getBytes());\u00a0 \u00a0 \u00a0 \u00a0 voteStmt.setBytes(3, encryptedEmail);\u00a0 \u00a0 \u00a0 \u00a0 // Finally, execute the statement. If it fails, an error will be thrown.\u00a0 \u00a0 \u00a0 \u00a0 voteStmt.execute();\u00a0 \u00a0 \u00a0 \u00a0 System.out.println(String.format(\"Successfully inserted row into table %s\", tableName));\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 }}\n``` [  cloud-sql/postgres/client-side-encryption/snippets/encrypt_and_insert_data.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/encrypt_and_insert_data.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/encrypt_and_insert_data.py) \n```\nimport datetimeimport loggingimport osimport sqlalchemyimport tinkfrom .cloud_kms_env_aead import init_tink_env_aeadfrom .cloud_sql_connection_pool import init_dblogger = logging.getLogger(__name__)def main() -> None:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Connects to the database, encrypts and inserts some data.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 db_user = os.environ[\"DB_USER\"] \u00a0# e.g. \"root\", \"postgres\"\u00a0 \u00a0 db_pass = os.environ[\"DB_PASS\"] \u00a0# e.g. \"mysupersecretpassword\"\u00a0 \u00a0 db_name = os.environ[\"DB_NAME\"] \u00a0# e.g. \"votes_db\"\u00a0 \u00a0 # Set if connecting using TCP:\u00a0 \u00a0 db_host = os.environ[\"DB_HOST\"] \u00a0# e.g. \"127.0.0.1\"\u00a0 \u00a0 # Set if connecting using Unix sockets:\u00a0 \u00a0 db_socket_dir = os.environ.get(\"DB_SOCKET_DIR\", \"/cloudsql\")\u00a0 \u00a0 instance_connection_name = os.environ[\"INSTANCE_CONNECTION_NAME\"]\u00a0 \u00a0 # e.g. \"project-name:region:instance-name\"\u00a0 \u00a0 credentials = os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\", \"\")\u00a0 \u00a0 key_uri = \"gcp-kms://\" + os.environ[\"GCP_KMS_URI\"]\u00a0 \u00a0 # e.g. \"gcp-kms://projects/...path/to/key\u00a0 \u00a0 # Tink uses the \"gcp-kms://\" prefix for paths to keys stored in Google\u00a0 \u00a0 # Cloud KMS. For more info on creating a KMS key and getting its path, see\u00a0 \u00a0 # https://cloud.google.com/kms/docs/quickstart\u00a0 \u00a0 table_name = \"votes\"\u00a0 \u00a0 team = \"TABS\"\u00a0 \u00a0 email = \"hello@example.com\"\u00a0 \u00a0 env_aead = init_tink_env_aead(key_uri, credentials)\u00a0 \u00a0 db = init_db(\u00a0 \u00a0 \u00a0 \u00a0 db_user,\u00a0 \u00a0 \u00a0 \u00a0 db_pass,\u00a0 \u00a0 \u00a0 \u00a0 db_name,\u00a0 \u00a0 \u00a0 \u00a0 table_name,\u00a0 \u00a0 \u00a0 \u00a0 instance_connection_name,\u00a0 \u00a0 \u00a0 \u00a0 db_socket_dir,\u00a0 \u00a0 \u00a0 \u00a0 db_host,\u00a0 \u00a0 )\u00a0 \u00a0 encrypt_and_insert_data(db, env_aead, table_name, team, email)def encrypt_and_insert_data(\u00a0 \u00a0 db: sqlalchemy.engine.base.Engine,\u00a0 \u00a0 env_aead: tink.aead.KmsEnvelopeAead,\u00a0 \u00a0 table_name: str,\u00a0 \u00a0 team: str,\u00a0 \u00a0 email: str,) -> None:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Inserts a vote into the database with email address previously encrypted using\u00a0 \u00a0 a KmsEnvelopeAead object.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 time_cast = datetime.datetime.now(tz=datetime.timezone.utc)\u00a0 \u00a0 # Use the envelope AEAD primitive to encrypt the email, using the team name as\u00a0 \u00a0 # associated data. Encryption with associated data ensures authenticity\u00a0 \u00a0 # (who the sender is) and integrity (the data has not been tampered with) of that\u00a0 \u00a0 # data, but not its secrecy. (see RFC 5116 for more info)\u00a0 \u00a0 encrypted_email = env_aead.encrypt(email.encode(), team.encode())\u00a0 \u00a0 # Verify that the team is one of the allowed options\u00a0 \u00a0 if team != \"TABS\" and team != \"SPACES\":\u00a0 \u00a0 \u00a0 \u00a0 logger.error(f\"Invalid team specified: {team}\")\u00a0 \u00a0 \u00a0 \u00a0 return\u00a0 \u00a0 # Preparing a statement before hand can help protect against injections.\u00a0 \u00a0 stmt = sqlalchemy.text(\u00a0 \u00a0 \u00a0 \u00a0 f\"INSERT INTO {table_name} (time_cast, team, voter_email)\"\u00a0 \u00a0 \u00a0 \u00a0 \" VALUES (:time_cast, :team, :voter_email)\"\u00a0 \u00a0 )\u00a0 \u00a0 # Using a with statement ensures that the connection is always released\u00a0 \u00a0 # back into the pool at the end of statement (even if an error occurs)\u00a0 \u00a0 with db.connect() as conn:\u00a0 \u00a0 \u00a0 \u00a0 conn.execute(stmt, time_cast=time_cast, team=team, voter_email=encrypted_email)\u00a0 \u00a0 print(f\"Vote successfully cast for '{team}' at time {time_cast}!\")\n```### Query the database and decrypt the stored data.\n[  cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/QueryAndDecryptData.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/QueryAndDecryptData.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/src/main/java/cloudsql/tink/QueryAndDecryptData.java) \n```\nimport com.google.crypto.tink.Aead;import java.security.GeneralSecurityException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Timestamp;import javax.sql.DataSource;public class QueryAndDecryptData {\u00a0 public static void main(String[] args) throws GeneralSecurityException, SQLException {\u00a0 \u00a0 // Saving credentials in environment variables is convenient, but not secure - consider a more\u00a0 \u00a0 // secure solution such as Cloud Secret Manager to help keep secrets safe.\u00a0 \u00a0 String dbUser = System.getenv(\"DB_USER\"); // e.g. \"root\", \"postgres\"\u00a0 \u00a0 String dbPass = System.getenv(\"DB_PASS\"); // e.g. \"mysupersecretpassword\"\u00a0 \u00a0 String dbName = System.getenv(\"DB_NAME\"); // e.g. \"votes_db\"\u00a0 \u00a0 String instanceConnectionName =\u00a0 \u00a0 \u00a0 \u00a0 System.getenv(\"INSTANCE_CONNECTION_NAME\"); // e.g. \"project-name:region:instance-name\"\u00a0 \u00a0 String kmsUri = System.getenv(\"CLOUD_KMS_URI\"); // e.g. \"gcp-kms://projects/...path/to/key\u00a0 \u00a0 // Tink uses the \"gcp-kms://\" prefix for paths to keys stored in Google Cloud KMS. For more\u00a0 \u00a0 // info on creating a KMS key and getting its path, see\u00a0 \u00a0 // https://cloud.google.com/kms/docs/quickstart\u00a0 \u00a0 String tableName = \"votes123\";\u00a0 \u00a0 // Initialize database connection pool and create table if it does not exist\u00a0 \u00a0 // See CloudSqlConnectionPool.java for setup details\u00a0 \u00a0 DataSource pool =\u00a0 \u00a0 \u00a0 \u00a0 CloudSqlConnectionPool.createConnectionPool(dbUser, dbPass, dbName, instanceConnectionName);\u00a0 \u00a0 CloudSqlConnectionPool.createTable(pool, tableName);\u00a0 \u00a0 // Initialize envelope AEAD\u00a0 \u00a0 // See CloudKmsEnvelopeAead.java for setup details\u00a0 \u00a0 Aead envAead = CloudKmsEnvelopeAead.get(kmsUri);\u00a0 \u00a0 // Insert row into table to test\u00a0 \u00a0 // See EncryptAndInsert.java for setup details\u00a0 \u00a0 EncryptAndInsertData.encryptAndInsertData(\u00a0 \u00a0 \u00a0 \u00a0 pool, envAead, tableName, \"SPACES\", \"hello@example.com\");\u00a0 \u00a0 queryAndDecryptData(pool, envAead, tableName);\u00a0 }\u00a0 public static void queryAndDecryptData(DataSource pool, Aead envAead, String tableName)\u00a0 \u00a0 \u00a0 throws GeneralSecurityException, SQLException {\u00a0 \u00a0 try (Connection conn = pool.getConnection()) {\u00a0 \u00a0 \u00a0 String stmt =\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 String.format(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"SELECT team, time_cast, voter_email FROM %s ORDER BY time_cast DESC LIMIT 5\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 tableName);\u00a0 \u00a0 \u00a0 try (PreparedStatement voteStmt = conn.prepareStatement(stmt); ) {\u00a0 \u00a0 \u00a0 \u00a0 ResultSet voteResults = voteStmt.executeQuery();\u00a0 \u00a0 \u00a0 \u00a0 System.out.println(\"Team\\tTime Cast\\tEmail\");\u00a0 \u00a0 \u00a0 \u00a0 while (voteResults.next()) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 String team = voteResults.getString(1);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Timestamp timeCast = voteResults.getTimestamp(2);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Postgres pads CHAR fields with spaces. These will need to be removed before\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // decrypting.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 String aad = voteResults.getString(1).trim();\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Use the envelope AEAD primitive to encrypt the email, using the team name as\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // associated data. This binds the encryption of the email to the team name, preventing\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // associating an encrypted email in one row with a team name in another row.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 String email = new String(envAead.decrypt(voteResults.getBytes(3), aad.getBytes()));\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 System.out.println(String.format(\"%s\\t%s\\t%s\", team, timeCast, email));\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 }}\n``` [  cloud-sql/postgres/client-side-encryption/snippets/query_and_decrypt_data.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/query_and_decrypt_data.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/client-side-encryption/snippets/query_and_decrypt_data.py) \n```\nimport osimport sqlalchemyimport tinkfrom .cloud_kms_env_aead import init_tink_env_aeadfrom .cloud_sql_connection_pool import init_dbfrom .encrypt_and_insert_data import encrypt_and_insert_datadef main() -> None:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Connects to the database, inserts encrypted data and retrieves encrypted data.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 db_user = os.environ[\"DB_USER\"] \u00a0# e.g. \"root\", \"postgres\"\u00a0 \u00a0 db_pass = os.environ[\"DB_PASS\"] \u00a0# e.g. \"mysupersecretpassword\"\u00a0 \u00a0 db_name = os.environ[\"DB_NAME\"] \u00a0# e.g. \"votes_db\"\u00a0 \u00a0 # Set if connecting using TCP:\u00a0 \u00a0 db_host = os.environ[\"DB_HOST\"] \u00a0# e.g. \"127.0.0.1\"\u00a0 \u00a0 # Set if connecting using Unix sockets:\u00a0 \u00a0 db_socket_dir = os.environ.get(\"DB_SOCKET_DIR\", \"/cloudsql\")\u00a0 \u00a0 instance_connection_name = os.environ[\"INSTANCE_CONNECTION_NAME\"]\u00a0 \u00a0 # e.g. \"project-name:region:instance-name\"\u00a0 \u00a0 credentials = os.environ.get(\"GOOGLE_APPLICATION_CREDENTIALS\", \"\")\u00a0 \u00a0 key_uri = \"gcp-kms://\" + os.environ[\"GCP_KMS_URI\"]\u00a0 \u00a0 # e.g. \"gcp-kms://projects/...path/to/key\u00a0 \u00a0 # Tink uses the \"gcp-kms://\" prefix for paths to keys stored in Google\u00a0 \u00a0 # Cloud KMS. For more info on creating a KMS key and getting its path, see\u00a0 \u00a0 # https://cloud.google.com/kms/docs/quickstart\u00a0 \u00a0 table_name = \"votes\"\u00a0 \u00a0 team = \"TABS\"\u00a0 \u00a0 email = \"hello@example.com\"\u00a0 \u00a0 env_aead = init_tink_env_aead(key_uri, credentials)\u00a0 \u00a0 db = init_db(\u00a0 \u00a0 \u00a0 \u00a0 db_user,\u00a0 \u00a0 \u00a0 \u00a0 db_pass,\u00a0 \u00a0 \u00a0 \u00a0 db_name,\u00a0 \u00a0 \u00a0 \u00a0 table_name,\u00a0 \u00a0 \u00a0 \u00a0 instance_connection_name,\u00a0 \u00a0 \u00a0 \u00a0 db_socket_dir,\u00a0 \u00a0 \u00a0 \u00a0 db_host,\u00a0 \u00a0 )\u00a0 \u00a0 encrypt_and_insert_data(db, env_aead, table_name, team, email)\u00a0 \u00a0 query_and_decrypt_data(db, env_aead, table_name)def query_and_decrypt_data(\u00a0 \u00a0 db: sqlalchemy.engine.base.Engine,\u00a0 \u00a0 env_aead: tink.aead.KmsEnvelopeAead,\u00a0 \u00a0 table_name: str,) -> list[tuple[str]]:\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 Retrieves data from the database and decrypts it using the KmsEnvelopeAead object.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 with db.connect() as conn:\u00a0 \u00a0 \u00a0 \u00a0 # Execute the query and fetch all results\u00a0 \u00a0 \u00a0 \u00a0 recent_votes = conn.execute(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 f\"SELECT team, time_cast, voter_email FROM {table_name} \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"ORDER BY time_cast DESC LIMIT 5\"\u00a0 \u00a0 \u00a0 \u00a0 ).fetchall()\u00a0 \u00a0 \u00a0 \u00a0 print(\"Team\\tEmail\\tTime Cast\")\u00a0 \u00a0 \u00a0 \u00a0 output = []\u00a0 \u00a0 \u00a0 \u00a0 for row in recent_votes:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 team = row[0]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Postgres pads CHAR fields with spaces. These will need to be removed before\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # decrypting.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 aad = team.rstrip()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Use the envelope AEAD primitive to decrypt the email, using the team name as\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # associated data. Encryption with associated data ensures authenticity\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # (who the sender is) and integrity (the data has not been tampered with) of that\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # data, but not its secrecy. (see RFC 5116 for more info)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 email = env_aead.decrypt(row[2], aad.encode()).decode()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 time_cast = row[1]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Print recent votes\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 print(f\"{team}\\t{email}\\t{time_cast}\")\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 output.append((team, email, time_cast))\u00a0 \u00a0 return output\n```- You can also restrict access at the [instance](/sql/docs/postgres/instance-access-control#instanceaccess) or [database](/sql/docs/postgres/instance-access-control#MySQLaccess) level. [\u21a9](#fnref1)", "guide": "Cloud SQL"}