{"title": "Cloud SQL - Connect from Cloud Functions", "url": "https://cloud.google.com/sql/docs/postgres/connect-functions", "abstract": "# Cloud SQL - Connect from Cloud Functions\nThis page contains information and examples for connecting to a Cloud SQL instance from a service running in Cloud Functions.\n**For step-by-step instructions on running a Cloud Functions sample web application connected to Cloud SQL,** see the [quickstart for connecting from Cloud Functions](/sql/docs/postgres/connect-instance-cloud-functions) .\nCloud SQL is a fully-managed database service that helps you set up, maintain, manage, and administer your relational databases in the cloud.\n[Cloud Functions](/functions/docs/concepts/overview) is a lightweight compute solution for developers to create single-purpose, standalone functions that respond to Cloud events without the need to manage a server or runtime environment.\n", "content": "## Set up a Cloud SQL instance\n- Enable the Cloud SQL Admin API in the Google Cloud project that you are connecting from, if you haven't already done so: [Enable the API](https://console.cloud.google.com/flows/enableapi?apiid=sqladmin&redirect=https://console.cloud.google.com) \n- [Create a Cloud SQL for PostgreSQL instance](/sql/docs/postgres/create-instance) .By default, Cloud SQL assigns a public IP address to a new  instance.  You also have the option to assign a private IP address. For more  information about the connectivity options for both, see the [ Connecting Overview](/sql/docs/postgres/connect-overview) page.## Configure Cloud Functions\nTo configure Cloud Functions to enable connections to a Cloud SQL instance:\n- Confirm that the instance created above has a public IP address. You can  confirm this on the **Overview** page for the instance in the [Google Cloud console](https://console.cloud.google.com/sql) . If you  need to add a public IP address, see [Configure public IP](/sql/docs/postgres/configure-ip) .\n- Get the instance's. This value is  available:- On the **Overview** page for the instance, in the [Google Cloud console](https://console.cloud.google.com/sql) , or\n- By running the following command:`gcloud sql instances describe [INSTANCE_NAME]`\n- [ Configure the service account](/functions/docs/securing/function-identity) for your function. If the authorizing  service account belongs to a different project from the Cloud SQL  instance, enable the Cloud SQL Admin API, and add the IAM permissions listed  below, on both projects. Confirm that the  service account has the appropriate [Cloud SQL roles and permissions to connect to Cloud SQL](/sql/docs/mysql/project-access-control#roles) .- To connect to Cloud SQL, the service account needs one of the  following [  IAM roles](/iam/docs/understanding-roles#cloud-sql-roles) :- `Cloud SQL Client`(preferred)\n- `Cloud SQL Editor`\n- `Cloud SQL Admin`\nOr, you can manually assign the following IAM permissions:- `cloudsql.instances.connect`\n- `cloudsql.instances.get`\n- If you're using [  Cloud Functions (2nd gen) and not Cloud Functions (1st gen)](/functions/docs/concepts/version-comparison) , the  following are required (also see [  Configure Cloud Run](/sql/docs/postgres/connect-run#configure) ):- Initially deploy your function.When you first begin creating a Cloud Function in the   Google Cloud console, the underlying Cloud Run   service hasn't been created yet. You can't configure a   Cloud SQL connection until that service is created (by deploying   the Cloud Function).\n- In the Google Cloud console, in the upper right of the **Function details** page, under **Powered by Cloud Run** , click the  link to access the underlying Cloud Run service.\n- On the Cloud Run **Service details** page, select the **Edit and deploy new revision** tab.\n- Follow the [standard steps](/sql/docs/postgres/connect-run#create-deploy) (as in the case of any configuration  change) for setting a new configuration for a Cloud SQL connection.This creates a new Cloud Run revision, and subsequent revisions  automatically receive this Cloud SQL connection, unless you  explicitly change it.If the authorizing service account belongs to a different project than the one containing the Cloud SQL instance, do the following:\n- In both projects, enable the Cloud SQL Admin API.\n- For the service account in the project that contains the Cloud SQL instance, add the [IAM permissions](/sql/docs/mysql/roles-and-permissions#serverless-roles-permissions) .A Serverless VPC Access connector uses private IP addresses to handle communication to your VPC network. To connect directly with private IP addresses, you must do the following:\n- Make sure that the Cloud SQL instance created previously has a private IP address. If you need to add one, see [Configure private IP](/sql/docs/postgres/configure-private-ip) for instructions.\n- [Create](/vpc/docs/configure-serverless-vpc-access#creating_a_connector) a Serverless VPC Access connector in the same VPC  network as your Cloud SQL instance. Note the following conditions:\n- Unless you're using [ Shared VPC](/vpc/docs/configure-serverless-vpc-access#shared-vpc) , your connector must be in the same project and  region as the resource that uses it, but it can send traffic to resources in  different regions.\n- Serverless VPC Access supports communication to  VPC networks connected using [Cloud VPN](/vpn/docs) and [VPC Network Peering](/vpc/docs/using-vpc-peering) .\n- Serverless VPC Access doesn't support [legacy networks](/vpc/docs/legacy) .\n- Configure Cloud Functions to use the connector.\n- Connect using your instance's private IP address and port`5432`.## Connect to Cloud SQL\nAfter you configure Cloud Functions, you can connect to your Cloud SQL instance.\nFor public IP paths, Cloud Functions provides encryption and connects using the [Cloud SQL Auth Proxy](/sql/docs/postgres/sql-proxy) in two ways:\n- Through [Unix sockets](#connect-unix-socket) \n- By using a [Cloud SQL connector](#connect-connectors) \nFor private IP paths, your application connects directly to your instance through a VPC network. This method uses TCP to connect directly to the Cloud SQL instance without using the Cloud SQL Auth Proxy.\n### Connect with TCPConnect using the private IP address of your Cloud SQL instance as the host and port `5432` .To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/cloud-sql/postgres/sqlalchemy/README.md) .\n [  cloud-sql/postgres/sqlalchemy/connect_tcp.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) \n```\nimport osimport sslimport sqlalchemydef connect_tcp_socket() -> sqlalchemy.engine.base.Engine:\u00a0 \u00a0 \"\"\"Initializes a TCP connection pool for a Cloud SQL instance of Postgres.\"\"\"\u00a0 \u00a0 # Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 # secure - consider a more secure solution such as\u00a0 \u00a0 # Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 # keep secrets safe.\u00a0 \u00a0 db_host = os.environ[\u00a0 \u00a0 \u00a0 \u00a0 \"INSTANCE_HOST\"\u00a0 \u00a0 ] \u00a0# e.g. '127.0.0.1' ('172.17.0.1' if deployed to GAE Flex)\u00a0 \u00a0 db_user = os.environ[\"DB_USER\"] \u00a0# e.g. 'my-db-user'\u00a0 \u00a0 db_pass = os.environ[\"DB_PASS\"] \u00a0# e.g. 'my-db-password'\u00a0 \u00a0 db_name = os.environ[\"DB_NAME\"] \u00a0# e.g. 'my-database'\u00a0 \u00a0 db_port = os.environ[\"DB_PORT\"] \u00a0# e.g. 5432\u00a0 \u00a0 pool = sqlalchemy.create_engine(\u00a0 \u00a0 \u00a0 \u00a0 # Equivalent URL:\u00a0 \u00a0 \u00a0 \u00a0 # postgresql+pg8000://<db_user>:<db_pass>@<db_host>:<db_port>/<db_name>\u00a0 \u00a0 \u00a0 \u00a0 sqlalchemy.engine.url.URL.create(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 drivername=\"postgresql+pg8000\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 username=db_user,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 password=db_pass,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 host=db_host,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port=db_port,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 database=db_name,\u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 \u00a0 \u00a0 # ...\u00a0 \u00a0 )\u00a0 \u00a0 return pool\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/master/cloud-sql/postgres/servlet/README.md) .\nNote:\n- CLOUD_SQL_CONNECTION_NAME should be represented as    <MY-PROJECT>:<INSTANCE-REGION>:<INSTANCE-NAME>\n- Using the argument ipTypes=PRIVATE will force the SocketFactory    to connect with an instance's associated private IP\n- See the JDBC socket factory version requirements for the pom.xml    file [ here ](https://github.com/GoogleCloudPlatform/cloud-sql-jdbc-socket-factory/blob/main/docs/jdbc-mysql.md) .\n [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/TcpConnectionPoolFactory.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/TcpConnectionPoolFactory.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/TcpConnectionPoolFactory.java) \n```\nimport com.zaxxer.hikari.HikariConfig;import com.zaxxer.hikari.HikariDataSource;import javax.sql.DataSource;public class TcpConnectionPoolFactory extends ConnectionPoolFactory {\u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 // secure - consider a more secure solution such as\u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 // keep secrets safe.\u00a0 private static final String DB_USER = System.getenv(\"DB_USER\");\u00a0 private static final String DB_PASS = System.getenv(\"DB_PASS\");\u00a0 private static final String DB_NAME = System.getenv(\"DB_NAME\");\u00a0 private static final String INSTANCE_HOST = System.getenv(\"INSTANCE_HOST\");\u00a0 private static final String DB_PORT = System.getenv(\"DB_PORT\");\u00a0 public static DataSource createConnectionPool() {\u00a0 \u00a0 // The configuration object specifies behaviors for the connection pool.\u00a0 \u00a0 HikariConfig config = new HikariConfig();\u00a0 \u00a0 // The following URL is equivalent to setting the config options below:\u00a0 \u00a0 // jdbc:postgresql://<INSTANCE_HOST>:<DB_PORT>/<DB_NAME>?user=<DB_USER>&password=<DB_PASS>\u00a0 \u00a0 // See the link below for more info on building a JDBC URL for the Cloud SQL JDBC Socket Factory\u00a0 \u00a0 // https://github.com/GoogleCloudPlatform/cloud-sql-jdbc-socket-factory#creating-the-jdbc-url\u00a0 \u00a0 // Configure which instance and what database user to connect with.\u00a0 \u00a0 config.setJdbcUrl(String.format(\"jdbc:postgresql://%s:%s/%s\", INSTANCE_HOST, DB_PORT, DB_NAME));\u00a0 \u00a0 config.setUsername(DB_USER); // e.g. \"root\", \"postgres\"\u00a0 \u00a0 config.setPassword(DB_PASS); // e.g. \"my-password\"\u00a0 \u00a0 // ... Specify additional connection properties here.\u00a0 \u00a0 // ...\u00a0 \u00a0 // Initialize the connection pool using the configuration object.\u00a0 \u00a0 return new HikariDataSource(config);\u00a0 }}\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/master/cloud-sql/postgres/knex/README.md) .\n [  cloud-sql/postgres/knex/connect-tcp.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/connect-tcp.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/connect-tcp.js) \n```\nconst Knex = require('knex');const fs = require('fs');// createTcpPool initializes a TCP connection pool for a Cloud SQL// instance of Postgres.const createTcpPool = async config => {\u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 // secure - consider a more secure solution such as\u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 // keep secrets safe.\u00a0 const dbConfig = {\u00a0 \u00a0 client: 'pg',\u00a0 \u00a0 connection: {\u00a0 \u00a0 \u00a0 host: process.env.INSTANCE_HOST, // e.g. '127.0.0.1'\u00a0 \u00a0 \u00a0 port: process.env.DB_PORT, // e.g. '5432'\u00a0 \u00a0 \u00a0 user: process.env.DB_USER, // e.g. 'my-user'\u00a0 \u00a0 \u00a0 password: process.env.DB_PASS, // e.g. 'my-user-password'\u00a0 \u00a0 \u00a0 database: process.env.DB_NAME, // e.g. 'my-database'\u00a0 \u00a0 },\u00a0 \u00a0 // ... Specify additional properties here.\u00a0 \u00a0 ...config,\u00a0 };\u00a0 // Establish a connection to the database.\u00a0 return Knex(dbConfig);};\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/tree/master/cloudsql/postgres/database-sql/README.md) .\n [  cloudsql/postgres/database-sql/connect_tcp.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/connect_tcp.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/connect_tcp.go) \n```\npackage cloudsqlimport (\u00a0 \u00a0 \u00a0 \u00a0 \"database/sql\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"log\"\u00a0 \u00a0 \u00a0 \u00a0 \"os\"\u00a0 \u00a0 \u00a0 \u00a0 // Note: If connecting using the App Engine Flex Go runtime, use\u00a0 \u00a0 \u00a0 \u00a0 // \"github.com/jackc/pgx/stdlib\" instead, since v5 requires\u00a0 \u00a0 \u00a0 \u00a0 // Go modules which are not supported by App Engine Flex.\u00a0 \u00a0 \u00a0 \u00a0 _ \"github.com/jackc/pgx/v5/stdlib\")// connectTCPSocket initializes a TCP connection pool for a Cloud SQL// instance of Postgres.func connectTCPSocket() (*sql.DB, error) {\u00a0 \u00a0 \u00a0 \u00a0 mustGetenv := func(k string) string {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 v := os.Getenv(k)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if v == \"\" {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Fatalf(\"Fatal Error in connect_tcp.go: %s environment variable not set.\", k)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return v\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 \u00a0 \u00a0 // secure - consider a more secure solution such as\u00a0 \u00a0 \u00a0 \u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 \u00a0 \u00a0 // keep secrets safe.\u00a0 \u00a0 \u00a0 \u00a0 var (\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbUser \u00a0 \u00a0= mustGetenv(\"DB_USER\") \u00a0 \u00a0 \u00a0 // e.g. 'my-db-user'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbPwd \u00a0 \u00a0 = mustGetenv(\"DB_PASS\") \u00a0 \u00a0 \u00a0 // e.g. 'my-db-password'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbTCPHost = mustGetenv(\"INSTANCE_HOST\") // e.g. '127.0.0.1' ('172.17.0.1' if deployed to GAE Flex)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbPort \u00a0 \u00a0= mustGetenv(\"DB_PORT\") \u00a0 \u00a0 \u00a0 // e.g. '5432'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbName \u00a0 \u00a0= mustGetenv(\"DB_NAME\") \u00a0 \u00a0 \u00a0 // e.g. 'my-database'\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 \u00a0 \u00a0 dbURI := fmt.Sprintf(\"host=%s user=%s password=%s port=%s database=%s\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbTCPHost, dbUser, dbPwd, dbPort, dbName)\u00a0 \u00a0 \u00a0 \u00a0 // dbPool is the pool of database connections.\u00a0 \u00a0 \u00a0 \u00a0 dbPool, err := sql.Open(\"pgx\", dbURI)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return nil, fmt.Errorf(\"sql.Open: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // ...\u00a0 \u00a0 \u00a0 \u00a0 return dbPool, nil}\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/php-docs-samples/tree/main/cloud_sql/postgres/pdo/README.md) .\n [  cloud_sql/postgres/pdo/src/DatabaseTcp.php ](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/DatabaseTcp.php) [View on GitHub](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/DatabaseTcp.php) \n```\nnamespace Google\\Cloud\\Samples\\CloudSQL\\Postgres;use PDO;use PDOException;use RuntimeException;use TypeError;class DatabaseTcp{\u00a0 \u00a0 public static function initTcpDatabaseConnection(): PDO\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 try {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // secure - consider a more secure solution such as\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // keep secrets safe.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $username = getenv('DB_USER'); // e.g. 'your_db_user'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $password = getenv('DB_PASS'); // e.g. 'your_db_password'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $dbName = getenv('DB_NAME'); // e.g. 'your_db_name'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $instanceHost = getenv('INSTANCE_HOST'); // e.g. '127.0.0.1' ('172.17.0.1' for GAE Flex)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Connect using TCP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $dsn = sprintf('pgsql:dbname=%s;host=%s', $dbName, $instanceHost);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Connect to the database\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $conn = new PDO(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $dsn,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $username,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $password,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 );\u00a0 \u00a0 \u00a0 \u00a0 } catch (TypeError $e) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 throw new RuntimeException(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sprintf(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'Invalid or missing configuration! Make sure you have set ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 '$username, $password, $dbName, and $instanceHost (for TCP mode). ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'The PHP error was %s',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getMessage()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getCode(),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 );\u00a0 \u00a0 \u00a0 \u00a0 } catch (PDOException $e) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 throw new RuntimeException(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sprintf(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'Could not connect to the Cloud SQL Database. Check that ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'your username and password are correct, that the Cloud SQL ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'proxy is running, and that the database exists and is ready ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'for use. For more assistance, refer to %s. The PDO error was %s',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'https://cloud.google.com/sql/docs/postgres/connect-external-app',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getMessage()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getCode(),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 );\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return $conn;\u00a0 \u00a0 }}\n```\n## Best practices and other information\nYou can use the [Cloud SQL Auth Proxy](/sql/docs/postgres/sql-proxy) when testing your application locally. See the [quickstart for using the Cloud SQL Auth Proxy](/sql/docs/mysql/connect-instance-auth-proxy) for detailed instructions.\n### Connection Pools\n[Managing database connections](/sql/docs/postgres/manage-connections)\n### Connection Limits\n[Cloud SQL Quotas and Limits](/sql/docs/quotas#fixed-limits)\nNote: Cloud Functions limits concurrent executions to one per instance. You never have a situation where a single function instance is processing two requests at the same time. In most situations, only a single database connection is needed.\nWhere possible, you should take care to only initialize a connection pool for functions that need access to your database. Some connection pools will create connections preemptively, which can consume excess resources and count towards your connection limits. For this reason, it's recommended to use [ Lazy Initialization](/functions/docs/bestpractices/tips#do_lazy_initialization_of_global_variables) to delay the creation of a connection pool until needed, and only include the connection pool in functions where it's used.\nFor more detailed examples on how to limit the number of connections, see [Managing database connections](/sql/docs/postgres/manage-connections#count) .\n### API Quota Limits\nCloud Functions provides a mechanism that connects using the Cloud SQL Auth Proxy, which uses the Cloud SQL Admin API. [API quota limits](https://console.cloud.google.com/iam-admin/quotas?service=sqladmin.googleapis.com) apply to the Cloud SQL Auth Proxy. The Cloud SQL Admin API quota used is approximately two times the number of Cloud SQL instances configured times the total number of functions deployed. You can [set thenumber of max concurrent invocations](/functions/quotas#additional_quotas_for_background_functions) to modify the expected API quota consumed. Cloud Functions also imposes [rate limits](/functions/quotas#rate_limits) on the number of API calls allowed per 100 seconds.\n## What's next\n- Learn more about [Cloud Functions](/functions/docs) .\n- Learn more about [deploying Cloud Functions](/functions/docs/deploy) .\n- Learn more about [specifying triggers for Cloud Functions](/functions/docs/calling) .\n- Learn more about [configuring Cloud Functions](/functions/docs/configuring) .", "guide": "Cloud SQL"}