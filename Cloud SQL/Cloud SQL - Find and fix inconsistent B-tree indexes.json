{"title": "Cloud SQL - Find and fix inconsistent B-tree indexes", "url": "https://cloud.google.com/sql/docs/postgres/find-fix-inconsistent-indexes", "abstract": "# Cloud SQL - Find and fix inconsistent B-tree indexes\nInconsistencies in database indexes can occur for a variety of reasons including software defects, hardware issues, or underlying changes in behavior such as sort order changes.\nThe PostgreSQL community has built tools to identify and remediate such issues. This includes tools like [amcheck](https://www.postgresql.org/docs/current/amcheck.html) , which is recommended by the PostgreSQL community to identify consistency issues, including issues that earlier versions of [PostgreSQL 14](https://www.migops.com/blog/important-postgresql-14-update-to-avoid-silent-corruption-of-indexes/#:%7E:text=The%20cause%20of%20the%20silent,in%20a%20silently%20corrupted%20state.) exhibited.\nWe have written this playbook as a reference for Cloud SQL for PostgreSQL users who experience such issues. We hope this page provides information that may also aid other PostgreSQL users in identifying and remediating inconsistent b-tree indexes. Our goal is to continually improve this document as a resource for the broader open source community. If you have any feedback, please use the Send Feedback button at the top and bottom of this page.\nResolving an index's inconsistencies involves the following steps:\n- [Before you begin](#before) .Before you begin reindexing, you should back up your database, set the correct permissions, verify your `psql` client version, and download the `amcheck` extension.\n- [Check for inconsistent B-tree indexes](#check-index) .To identify the indexes you need to fix inconsistencies for, you need to identify all B-tree indexes with inconsistencies and identify all unique and primary key violations.\n- [Fix the index's inconsistencies](#fix-indexes) .Reindexing an index fixes all its inconsistencies. You may need to adjust your instance's memory settings to improve performance.\n- [Monitor reindexing operations](#monitor) .We recommend that you monitor the progress of the reindexing operation to ensure that the operation is progressing and is not blocked.\n- [Verify that the indexes are consistent](#verify) .After you have successfully reindexed your index, we recommend that you verify that your index does not contain any inconsistencies.", "content": "## Before you begin\n### Backup your database\nTo ensure that no data is lost during reindexing, we recommend that you back up your database. For more information, see [Create an on-demand backup](/sql/docs/mysql/backup-recovery/backing-up#on-demand) .\n**Caution:** A backup taken on a database that already has index inconsistencies will still have inconsistencies when restored.\n### Set the cloudsqlsuperuser permission\nTo complete the steps on this page, you must have `cloudsqlsuperuser` permissions. For more information, see [session_replication_role](/sql/docs/postgres/flags) .\n### Ensure that the psql client version is 9.6 or higher\nTo complete the steps on this page, you must ensure that your `psql` client version is 9.6 or higher. Run the command `psql --version` to verify your current `psql` client version.\n### Install the amcheck extension\nTo check for index inconsistencies, you must enable the `amcheck` extension.\n**Note:** You must ensure that POSTGRES_9_6_24.R20220710.01_12 is  installed before installing`amcheck_next`. For more  information on installing a new target maintenance version, see [Self Service Maintenance](/sql/docs/postgres/self-service-maintenance) .\nTo install `amcheck` for PostgreSQL 9.6, run the following statement:\n```\n\u00a0 CREATE EXTENSION amcheck_next;\u00a0 \n```\nIf you get an error saying `Could not open extension control file...`, verify that you're running the correct target maintenance version (POSTGRES_9_6_24.R20220710.01_12).To install `amcheck` for PostgreSQL 10 and later, run the following statement:\n```\n\u00a0 CREATE EXTENSION amcheck;\u00a0 \n```\n## Check for inconsistent B-tree indexes\nThe following sections describe how to check for inconsistent B-tree indexes by checking for an index's inconsistencies as well as unique and primary key violations.\n### Check for inconsistencies\nRun the following statement to check for inconsistencies in all B-tree indexes in each of your databases:\n```\n\u00a0 DO $$\u00a0 DECLARE\u00a0 \u00a0 r RECORD;\u00a0 \u00a0 version varchar(100);\u00a0 BEGIN\u00a0 \u00a0 RAISE NOTICE 'Started amcheck on database: %', current_database();\u00a0 \u00a0 SHOW server_version into version;\u00a0 \u00a0 SELECT split_part(version, '.', 1) into version;\u00a0 \u00a0 FOR r IN\u00a0 \u00a0 \u00a0 SELECT c.oid, c.oid::regclass relname, i.indisunique\u00a0 \u00a0 \u00a0 \u00a0 FROM pg_index i\u00a0 \u00a0 \u00a0 \u00a0 JOIN pg_opclass op ON i.indclass[0] = op.oid\u00a0 \u00a0 \u00a0 \u00a0 JOIN pg_am am ON op.opcmethod = am.oid\u00a0 \u00a0 \u00a0 \u00a0 JOIN pg_class c ON i.indexrelid = c.oid\u00a0 \u00a0 \u00a0 \u00a0 JOIN pg_namespace n ON c.relnamespace = n.oid\u00a0 \u00a0 \u00a0 WHERE am.amname = 'btree'\u00a0 \u00a0 \u00a0 \u00a0 AND c.relpersistence != 't'\u00a0 \u00a0 \u00a0 \u00a0 AND c.relkind = 'i'\u00a0 \u00a0 \u00a0 \u00a0 AND i.indisready AND i.indisvalid LOOP\u00a0 \u00a0 \u00a0 BEGIN\u00a0 \u00a0 \u00a0 \u00a0 RAISE NOTICE 'Checking index %:', r.relname;\u00a0 \u00a0 \u00a0 \u00a0 IF version = '10' THEN\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 PERFORM bt_index_check(index => r.oid);\u00a0 \u00a0 \u00a0 \u00a0 ELSE\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 PERFORM bt_index_check(index => r.oid, heapallindexed => r.indisunique);\u00a0 \u00a0 \u00a0 \u00a0 END IF;\u00a0 \u00a0 \u00a0 EXCEPTION\u00a0 \u00a0 \u00a0 \u00a0 WHEN undefined_function THEN\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 RAISE EXCEPTION 'Failed to find the amcheck extension';\u00a0 \u00a0 \u00a0 \u00a0 WHEN OTHERS THEN\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 RAISE LOG 'Failed to check index %: %', r.relname, sqlerrm;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 RAISE WARNING 'Failed to check index %: %', r.relname, sqlerrm;\u00a0 \u00a0 \u00a0 END;\u00a0 \u00a0 END LOOP;\u00a0 \u00a0 RAISE NOTICE 'Finished amcheck on database: %', current_database();\u00a0 END $$;\u00a0 \n```\nYou should receive output similar to the following:\n```\n\u00a0 NOTICE: \u00a0Checking index t_pkey:\u00a0 NOTICE: \u00a0Checking index t_i_key:\u00a0 WARNING: \u00a0Failed to check index t_i_key: item order invariant violated for index \"t_i_key\"\u00a0 NOTICE: \u00a0Checking index t_j_key:\u00a0 WARNING: \u00a0Failed to check index t_j_key: item order invariant violated for index \"t_j_key\"\u00a0 NOTICE: \u00a0Checking index ij:\u00a0 WARNING: \u00a0Failed to check index ij: item order invariant violated for index \"ij\"\u00a0 \n```\n**Warning:** If your output doesn't contain WARNING notices, unique or key violations could still exist. To check for violations, perform the procedures in Identify and fix unique and primary key violations.\nFor more information about viewing PostgreSQL logs, see [View instance logs](/sql/docs/postgres/logging) .\n### Identify and fix unique and primary key violations\nThis section describes how to check your index for unique and primary key violations, and if some exist, how you fix them.\nUnique key violations must be [fixed](#unique-key) before you reindex an index. To check for all unique key violations, run the following command in each database:\n```\n\u00a0 WITH q AS (\u00a0 \u00a0 \u00a0 /* this gets info for all UNIQUE indexes */\u00a0 \u00a0 \u00a0 SELECT indexrelid::regclass as idxname, \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 indrelid::regclass as tblname, \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 indcollation, \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pg_get_indexdef(indexrelid), \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 format('(%s)',(select string_agg(quote_ident(attname), ', ') \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 from pg_attribute a \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 join unnest(indkey) ia(nr) on ia.nr = a.attnum\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 where attrelid = indrelid)) as idxfields,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 COALESCE(substring(pg_get_indexdef(indexrelid) FROM '[)] (WHERE .*)$'), '') as whereclause\u00a0 \u00a0 \u00a0 \u00a0 FROM pg_index\u00a0 \u00a0 \u00a0 WHERE indisunique\u00a0 \u00a0 \u00a0 /* next line excludes indexes not affected by collation changes */\u00a0 \u00a0 \u00a0 \u00a0 AND trim(replace(indcollation::text, '0', '')) != '' \u00a0 )\u00a0 SELECT\u00a0 /* the format constructs the query to execute for each index */\u00a0 format(\u00a0 $sql$\u00a0 DO $$ BEGIN RAISE NOTICE 'checking index=%3$I \u00a0 \u00a0on \u00a0 table=%1$I \u00a0 \u00a0 \u00a0key_columns=%2$I '; END;$$;\u00a0 SELECT this,\u00a0 \u00a0 \u00a0 \u00a0 prev,\u00a0 \u00a0 \u00a0 \u00a0 /* we detect both reversed ordering or just not unique */\u00a0 \u00a0 \u00a0 \u00a0 (CASE WHEN this = prev THEN 'DUPLICATE' ELSE 'BACKWARDS' END) as violation_type\u00a0 \u00a0 FROM (SELECT %2$s AS this,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 lag(%2$s) OVER (ORDER BY %2$s) AS prev\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 FROM %1$s %4$s\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ) s\u00a0 WHERE this <= prev and this IS NOT NULL and prev IS NOT NULL; /* change to just '<' if looking for reverse order in index */\u00a0 $sql$, tblname, idxfields, idxname, whereclause\u00a0 )\u00a0 \u00a0 FROM q\u00a0 -- LIMIT 20 /* may use limit for testing */\u00a0 -- the next line tells psql to executes this query and then execute each returned line separately \u00a0 \\gexec\u00a0 \n```\nThe output of the script is similar to the following:\n```\n\u00a0 NOTICE: \u00a0checking index=users_email_key on table=users key_columns=\"(email)\" \u00a0 NOTICE: \u00a0checking index=games_title_key on table=games \u00a0key_columns=\"(title)\" \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 this \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 \u00a0 \u00a0prev \u00a0 \u00a0 \u00a0 \u00a0| violation_type \u00a0 --------------------+--------------------+----------------\u00a0 Game #16 $soccer 2 \u00a0| Game #16 $soccer 2 | DUPLICATE\u00a0 Game #18 $soccer 2 \u00a0| Game #18 $soccer 2 | DUPLICATE\u00a0 Game #2 $soccer 2 \u00a0 | Game #2 $soccer 2 \u00a0| DUPLICATE\u00a0 Game #5 $soccer 2 \u00a0 | Game #5 $soccer 2 \u00a0| DUPLICATE\u00a0 \n```\nIn this output, the table header `NOTICE` shows the index, column, and table for the values displayed below it. If your output contains rows displaying `DUPLICATE` or `BACKWARDS` , then this shows corruption in the index and may need to be fixed. Rows with `BACKWARDS` indicate possible duplicate values that might be hidden. If you see either of these entries in the table, see [Fix duplicate key violations](#unique-key) .\nIf you have identified a duplicate unique index or if a reindex operation fails due to a duplicate key violation error, complete the following steps to find and remove the duplicate key(s).\n**Note:** You need to repeat the following steps for each index that has key violations.\n- Extract the `key_columns` from the `NOTICE` table header, as shown in the preceding sample output. In the following example, the key column is `email` .\n```\n\u00a0 NOTICE: \u00a0checking index=users_email_key on table=users key_columns=\"(email)\" \n```\nUse these values in in the query in step 3.\n- Find the schema for your table. Use `psql` to connect to your database and run the following command:\n```\n\\dt TABLE_NAME\n```\nThe value in the\n`schema`\ncolumn is the value you use for\nin the query in step 3.\nFor example, for the following query:\n```\n\u00a0\\dt games\u00a0\n```\nThe output is similar to the following:\n```\n\u00a0List of relations\u00a0Schema \u00a0| Name \u00a0| Type \u00a0| Owner\u00a0--------+-------+-------+----------\u00a0public \u00a0| games | table | postgres\u00a0(1 row)\u00a0\n```\n- Run the following statements to force a full table scan and get duplicate keys.\n```\nSET enable_indexscan = off;SET enable_bitmapscan = off;SET enable_indexonlyscan = off;SELECT KEY_COLUMNS, count(*)\u00a0 FROM SCHEMA_NAME.TABLE_NAMEGROUP BY KEY_COLUMNSHAVING count(*) > 1;\n```\n **Note:** If your database is large, this statement may take a long time to complete.In the above statement, are one or more columns covered by the unique index or primary key in the table you are checking. These were identified when you checked for unique key violations. The statement returns the duplicate keys and a count of the duplicates for each.For example, for the following query:```\n\u00a0 SELECT name,count(*) \u00a0 \u00a0 FROM public.TEST_NAMES\u00a0 GROUP BY name \u00a0 HAVING count(*) > 1;\u00a0 \n```The output is similar to the following:```\n\u00a0 name \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| count \u00a0 --------------------+-------\u00a0 Johnny \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0| \u00a0 \u00a0 2\u00a0 Peter \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | \u00a0 \u00a0 2\u00a0 (2 rows)\u00a0 \n```In this case, continue to the next step to remove the duplicate keys.If any of the columns in are null, you can ignore them because unique constraints do not apply for NULL columns.If no duplicate keys are found, you can move to [Fix inconsistent indexes](#fix-indexes) .\n- Optional but recommended: Create a backup for the records containing duplicate keys. Run the following statement to create backup records:\n```\n\u00a0 CREATE TABLE SCHEMA_NAME.TABLE_NAME_bak\u00a0 AS SELECT * FROM SCHEMA_NAME.TABLE_NAME\u00a0 WHERE (KEY_COLUMNS)\u00a0 IN ((KEY_VALUES));\u00a0 \n```\nIn this statement, is a list of values copied from the result of the previous step. For example:\n```\n\u00a0 CREATE TABLE public.TEST_NAMES_bak\u00a0 AS SELECT * FROM public.TEST_NAMES\u00a0 WHERE (name) IN (('Johnny'),('Peter'))\u00a0 \n```\nFor a large number of rows, it is easier to replace the (( )) parameter in the `IN` statement with the `SELECT` statement from step 2 without the `count` parameter. For example:\n```\n\u00a0 CREATE TABLE SCHEMA_NAME.TABLE_NAME_bak\u00a0 AS SELECT * FROM SCHEMA_NAME.TABLE_NAME\u00a0 WHERE (KEY_COLUMNS)\u00a0 IN ( SELECT (KEY_COLUMNS)\u00a0 FROM SCHEMA_NAME.TABLE_NAME\u00a0 GROUP BY (KEY_COLUMNS)\u00a0 HAVING count(*) > 1);\u00a0 \n```\n- Add a replication role to the user to disable triggers:\n```\n\u00a0 ALTER USER CURRENT_USER with REPLICATION;\u00a0 SET session_replication_role = replica;\u00a0 \n```\n- Run the following statement to delete the duplicate keys:\n```\n\u00a0 BEGIN;\u00a0 DELETE FROM \u00a0SCHEMA_NAME.TABLE_NAME a\u00a0 \u00a0 \u00a0 USING \u00a0(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SELECT \u00a0 min(ctid) AS ctid,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 KEY_COLUMNS\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 FROM \u00a0 \u00a0 SCHEMA_NAME.TABLE_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 GROUP BY KEY_COLUMNS\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 HAVING count(*) > 1 ) b\u00a0 \u00a0 \u00a0 WHERE a.KEY_COLUMNS = b.KEY_COLUMNS \u00a0 \u00a0 \u00a0 AND \u00a0 a.ctid <> b.ctid;\u00a0 \n```\nFor example, for multi-column :\n```\n\u00a0 DELETE FROM public.test_random a\u00a0 \u00a0 \u00a0 USING (\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0SELECT min(ctid) AS ctid,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0day, rnum\u00a0 \u00a0 \u00a0 FROM public.test_random\u00a0 \u00a0 \u00a0 GROUP BY day, rnum\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0HAVING count(*) > 1 ) b\u00a0 \u00a0 \u00a0 WHERE a.day=b.day and a.rnum = b.rnum\u00a0 \u00a0 \u00a0 AND a.ctid <> b.ctid;\u00a0 \n```\nWhere\nand\nare\n.\nRunning this statement keeps one row and deletes others for each set of duplicate rows. If you want to control which version of the row gets deleted, run the following filter in the delete statement:\n```\n\u00a0 DELETE FROM \u00a0SCHEMA_NAME.TABLE_NAME\u00a0 WHERE ( KEY_COLUMNS, ctid) = (KEY_VALUES, CTID_VALUE);\u00a0 \n```\n **Warning:** Committing this transaction mutates your database and removes duplicate keys. Make sure that you don't delete any data that's still needed. Restoring from a backup might restore the inconsistent indexes.\n- Complete the following steps to check that the `DELETE` command returned the expected number of rows without any errors:- Run the following statement to identify the rows in which tables were changed:\n```\n\u00a0 SELECT schemaname, relname, n_tup_del, n_tup_upd\u00a0 \u00a0 FROM pg_stat_xact_all_tables\u00a0 WHERE n_tup_del+n_tup_upd > 0;\u00a0 \n```\n- If all the rows are correct, commit the `DELETE` transaction:\n```\n\u00a0 END;\u00a0 \n```\n- If there are errors, roll back the changes to fix the errors:\n```\n\u00a0 ROLLBACK;\u00a0 \n```\n- After the duplicate keys are deleted, you can reindex your index.## Fix inconsistent indexes\nThe following sections describe how you can fix the index inconsistencies found in your instance.\n**Note:** If your index has unique and primary key violations, you must fix these before reindexing.\nDepending on how your database is configured, you may need to do the following for each index identified in the previous steps:\n- [Prepare to reindex your index](#prepare) .\n- [Reindex your index](#rebuild) .\n- If the reindex operation fails due to foreign key violations, you must [find and fix these violations](#check-fk) .\n- Run the reindex operation again.\n### Prepare to reindex your index\nIndexing larger databases requires more time than smaller databases. To improve the speed of index and reindex operations of larger databases, you can allocate more memory and CPU power to these operations. This is an important step in planning your reindex operation. After you know the index size, you can [set the memory size used by the reindex operation](#memory) and [set the number of parallel workers](#workers) .\nRun the following statement to find the index size, in kilobytes, of the index that you want to fix:\n```\n\u00a0 SELECT i.relname \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0AS index_name,\u00a0 \u00a0 \u00a0 \u00a0 pg_size_pretty(pg_relation_size(x.indexrelid)) AS index_size\u00a0 FROM \u00a0 pg_index x\u00a0 \u00a0 \u00a0 \u00a0 JOIN pg_class i\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ON i.oid = x.indexrelid\u00a0 WHERE \u00a0i.relname = 'INDEX_NAME';\u00a0 \n```\nThe output of this statement is similar to the following:\n```\n\u00a0 index_name \u00a0| index_size \u00a0 ------------+------------\u00a0 my_index \u00a0 \u00a0| 16 kB\u00a0 (1 row)\u00a0 \n```\nBased on the size of your index as determined in the previous section, it is important to set the appropriate value for [maintenance_work_mem](/sql/docs/postgres/flags#postgres-m) . This parameter specifies the amount of memory to use for the reindexing operation. For example, if your index size is greater than 15 GB, we recommend that you adjust your maintenance memory. For more information, see [Set a database flag](/sql/docs/postgres/flags#set_a_database_flag) .\n**Note:** The value of `maintenance_work_mem` is set for each session. You don't need to restart your instance after changing the value. However, if you connect to the database again in a new session, the value from the previous setting is not saved.\nIndexing larger databases requires more time than smaller databases. To improve the speed of index and reindex operations, we recommend setting `maintenance_work_mem` to at least 2% of the instance memory for instances with 4GB or more memory during this reindexing operation.\nYou can increase the number of parallel workers for reindexing by setting the [max_parallel_maintenance_workers](/sql/docs/postgres/flags#postgres-m) parameter in databases using PostgreSQL 11 or higher. The default value of this parameter is 2 but can be set to a higher value to increase the number of workers for reindexing. For instances with 8 or more vCPU cores, we recommend setting the `max_parallel_maintenance_workers` flag value to 4.\nFor more information, see [Set a database flag](/sql/docs/postgres/flags#set_a_database_flag) .\n### Reindex your index\nYou can reindex an index without blocking your production workload using the `pg_repack` utility. This utility automates and simplifies the concurrent reindex process, enabling you to reindex without downtime, especially for PostgreSQL versions 11 and earlier, which do not have the `REINDEX CONCURRENTLY` operation. For this procedure, use `pg_repack` version 1.4.7.\nComplete the following steps to reindex your index using `pg_repack` :\n- Download, compile, and install the `pg_repack` utility from the [pg_repack page](https://reorg.github.io) .\nFor convenience, we recommend that Debian Linux users download and  install this [pre-built executable binary for the Linux x86_64 platform](https://storage.googleapis.com/cloud-sql-pg-repack/ver_1.4.7/pg_repack) .\nThe sha256 checksum hash of the binary is the following:\n`ecfee54364a625d9365d86cb27940b458bfdb0d6ff63bb88063039256fbde96f`\nTo verify that your Linux version is Debian GNU/Linux 11, run the command `hostnamectl` . **Note:** For this procedure, you should run the command in the terminal on either Linux or on Unix with a working GNU toolchain.\nDownload, compile, and install the `pg_repack` utility from the [pg_repack page](https://reorg.github.io/pg_repack/) .\n- Create the `pg_repack` extension:\n```\n\u00a0 CREATE EXTENSION pg_repack;\u00a0 \n```\n- Run the following command to reindex your index concurrently:\n```\n\u00a0 pg_repack -h HOSTIP -p 5432 -U USERNAME -d \"DATABASE_NAME\" -i \"INDEX_NAME\" --no-superuser-check --no-kill-backend --wait-timeout=3600\u00a0 \n```\n **Note:** `pg_repack` does not allow you to reindex an index on a materialized view.This command has output similar to the following:\n```\n\u00a0 INFO: repacking index \"public.t_i_key\"\u00a0 \n```\nIf any errors occurred when running `pg_repack` , you can correct the error and try again. After you have fixed all of your unique key indexes and primary key indexes, you should [check for foreign key violations](#check-fk) and fix any that are found.\n### Find and fix foreign key violations\nFor information about how to find and fix foreign key violations, see [Find and fix foreign key violations](/sql/docs/postgres/fix-foreign-keys) .\n## Monitor reindexing operations\nOccasionally, the reindex operation may be blocked by other sessions. We recommended that you check this every 4 hours. If the reindex operation is blocked, you can cancel the blocking session so the reindex operation can complete.\nComplete the following steps to identify blocking and waiting sessions and then cancel them in the INDEX operation:\n- To identify blocking sessions, run the following query:\n```\n\u00a0 SELECT pid,\u00a0 \u00a0 \u00a0 \u00a0 usename,\u00a0 \u00a0 \u00a0 \u00a0 pg_blocking_pids(pid) AS blocked_by,\u00a0 \u00a0 \u00a0 \u00a0 query \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AS blocked_query\u00a0 FROM \u00a0 pg_stat_activity\u00a0 WHERE \u00a0cardinality(pg_blocking_pids(pid)) > 0; \u00a0 \n```\n- To cancel a session, run the following query using the PID of the blocking session from the previous query:\n```\n\u00a0 SELECT pg_cancel_backend(PID);\u00a0 \n```\n## Verify that your indexes are consistent\nYou must continue to check for index inconsistencies for each inconsistent index. After you have fixed all your instance's inconsistent indexes and key violations, you can check that no issues exist by following the steps in the previous sections:\n- [Check for an index's inconsistencies](#check-index) \n- [Check for unique key violations](#check-uk)", "guide": "Cloud SQL"}