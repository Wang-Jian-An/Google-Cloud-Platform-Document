{"title": "Cloud SQL - Connect from Google Kubernetes Engine", "url": "https://cloud.google.com/sql/docs/postgres/connect-kubernetes-engine", "abstract": "# Cloud SQL - Connect from Google Kubernetes Engine\nThis page describes how to set up a connection from an application running in Google Kubernetes Engine (GKE) to a Cloud SQL instance.\n**For step-by-step instructions on running a Google Kubernetes Engine sample webapplication connected to Cloud SQL,** see the [quickstart for connectingfrom Google Kubernetes Engine](/sql/docs/postgres/connect-instance-kubernetes) .\nCloud SQL is a fully-managed database service that helps you set up, maintain, manage, and administer your relational databases in the cloud.\nGoogle Kubernetes Engine is a simple way to automatically deploy, scale, and manage Kubernetes.\n", "content": "## About connecting Google Kubernetes Engine to Cloud SQL\nTo access a Cloud SQL instance from an application running in Google Kubernetes Engine, you can use either the Cloud SQL Auth Proxy (with public or private IP), or connect directly using a private IP address.\nThe Cloud SQL Auth Proxy is the recommended way to connect to Cloud SQL, even when using private IP. This is because the Cloud SQL Auth Proxy provides strong encryption and authentication using IAM, which can help keep your database secure.\nDatabase connections consume resources on the server and the connecting application. Always use good connection management practices to minimize your application's footprint and reduce the likelihood of exceeding Cloud SQL [connection limits](/sql/docs/postgres/quotas#configurable-limits) . For more information, see [Managing database connections](/sql/docs/postgres/manage-connections) .\n### Before you begin\nTo connect to Cloud SQL you must have:\n- A GKE cluster, with the `kubectl` command-line tool installed and configured to communicate with the cluster.For help getting started with GKE, see [Deploy an app to a GKE cluster](/kubernetes-engine/docs/deploy-app-cluster) .For connecting using private IP, the GKE cluster must be [VPC-native](https://cloud.google.com/kubernetes-engine/docs/how-to/alias-ips) and peered with the same Virtual Private Cloud (VPC) network as the Cloud SQL instance.\n- An instance created.For help creating a Cloud SQL instance, see [Creating Instances](/sql/docs/postgres/create-instance) .\n- A PostgreSQL user account configured on the instance.Your application will use this account to connect to the database. For help with creating a user account, see [Creating a user](/sql/docs/postgres/create-manage-users#creating) .\n**Note:** Some of the kubectl commands will use a default namespace unless you use a`--namespace`flag. For more information, see the [Kubernetes documentation on Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/) .\n### About Kubernetes Secrets\nIn Kubernetes, [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/) are a secure way to pass configuration details to your application. You can create a Secret with details such as your database name, user, and password which can be injected into your application as env vars.\nThere are many different ways Secrets can be used, depending on the connection type:\n- A database credentials Secret includes the name of the database user you are connecting as, and the user's database password.\n- If connecting with the Cloud SQL Auth Proxy, a Secret can be used to hold your service account's credential file.\n- If connecting with private IP, a Secret can be used to specify the private IP address of your Cloud SQL instance.\nFor complete examples of how to use Secrets, see the GitHub repositories referenced later on this page.- You create the Secret objects by using the [kubectl create secret command](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/#create-a-secret) .To create a database credentials Secret:```\nkubectl create secret generic <YOUR-DB-SECRET> \\\u00a0 --from-literal=username=<YOUR-DATABASE-USER> \\\u00a0 --from-literal=password=<YOUR-DATABASE-PASSWORD> \\\u00a0 --from-literal=database=<YOUR-DATABASE-NAME>\n```\n- Once created, you can view the objects in the **Configuration** section of the Google Kubernetes Engine page in the [Google Cloud console](https://console.cloud.google.com/kubernetes) .## Connect to Cloud SQL using the Cloud SQL Auth Proxy\nWhen you connect using the Cloud SQL Auth Proxy, the Cloud SQL Auth Proxy is added to your pod using the `sidecar` container pattern. The Cloud SQL Auth Proxy container is in the same pod as your application, which enables the application to connect to the Cloud SQL Auth Proxy using `localhost` , increasing security and performance.\nFor more information about the Cloud SQL Auth Proxy, see [About the Cloud SQL Auth Proxy](/sql/docs/postgres/sql-proxy) . For more information about working with pods, see [Pod Overview](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview) in the Kubernetes documentation.\nFor connecting using the Cloud SQL Auth Proxy you need the following:\n- The instance connection name of your Cloud SQL instance.The instance connection name is available in the **Cloud SQLInstance details** page of the Google Cloud console or from the `gcloud sql instances describe` `` command.\n- The location of the key file associated with a service account with the proper privileges for your Cloud SQL instance.See [Creating a service account](/sql/docs/postgres/connect-auth-proxy#create-service-account) for more information.\n- The Cloud SQL Admin API is enabled. [Enable the API](https://console.cloud.google.com/flows/enableapi?apiid=sqladmin&redirect=https://console.cloud.google.com) \n### Provide the service account to the Cloud SQL Auth Proxy\nThe first step to running the Cloud SQL Auth Proxy in Google Kubernetes Engine is creating a Google Service Account (GSA) to represent your application. It is recommended that you create a service account unique to each application, instead of using the same service account everywhere. This model is more secure since it allows you to limit permissions on a per-application basis.\nThe service account for your application needs to meet the following criteria:\n- Belong to a project with the Cloud SQL Admin API enabled\n- Has been granted the Cloud SQL Client IAM role (or equivalent) for the project containing the instance you want to connect to\n- If connecting using private IP, you must use a VPC-native GKE cluster, in the same VPC as your Cloud SQL instance\nYou need to configure GKE to provide the service account to the Cloud SQL Auth Proxy. There are two recommended ways to do this: [workload identity](#workload-identity) or a [service accountkey file](#service-account-key-file) .\nIf you are using [Google Kubernetes Engine](/kubernetes-engine) , the preferred method is to use GKE's [Workload Identity](/kubernetes-engine/docs/how-to/workload-identity) feature. This method allows you to bind a [Kubernetes Service Account (KSA)](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) to a [Google Service Account(GSA)](#gsa) . The GSA will then be accessible to applications using the matching KSA.\nA Google Service Account (GSA) is an IAM identity that represents your application in Google Cloud. In a similar fashion, a Kubernetes Service Account (KSA) is a an identity that represents your application in a Google Kubernetes Engine cluster.\nWorkload Identity binds a KSA to a GSA, causing any deployments with that KSA to authenticate as the GSA in their interactions with Google Cloud.\n- [Enable Workload Identity for your cluster](/kubernetes-engine/docs/how-to/workload-identity#enable_on_cluster) \n- Typically, each application has its own identity, represented by a KSA and GSA pair. Create a KSA for your application by running `kubectl apply -f service-account.yaml` : [  examples/k8s-sidecar/service_account.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/c733a6c62a4e5d7899156e2d77f6e2f839aff63e/examples/k8s-sidecar/service_account.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/c733a6c62a4e5d7899156e2d77f6e2f839aff63e/examples/k8s-sidecar/service_account.yaml) ```\napiVersion: v1kind: ServiceAccountmetadata:\u00a0 name: <YOUR-KSA-NAME> # TODO(developer): replace these values\n```\n- Enable the IAM binding between your and :```\ngcloud iam service-accounts add-iam-policy-binding \\--role=\"roles/iam.workloadIdentityUser\" \\--member=\"serviceAccount:YOUR-GOOGLE-CLOUD-PROJECT.svc.id.goog[YOUR-K8S-NAMESPACE/YOUR-KSA-NAME]\" \\YOUR-GSA-NAME@YOUR-GOOGLE-CLOUD-PROJECT.iam.gserviceaccount.com\n```\n- Add an annotation to to complete the binding:```\nkubectl annotate serviceaccount \\YOUR-KSA-NAME \\iam.gke.io/gcp-service-account=YOUR-GSA-NAME@YOUR-GOOGLE-CLOUD-PROJECT.iam.gserviceaccount.com\n```\n- Finally, make sure to specify the service account for the k8s object. [  examples/k8s-sidecar/proxy_with_workload_identity.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_workload_identity.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_workload_identity.yaml) ```\napiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: <YOUR-DEPLOYMENT-NAME>spec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 serviceAccountName: <YOUR-KSA-NAME>\n```Alternatively, if you can't use Workload Identity, the recommended pattern is to mount a service account key file into the Cloud SQL Auth Proxy pod and use the `--credentials-file` flag.\n- Create a credential file for your service account key:```\ngcloud iam service-accounts keys create ~/key.json \\--iam-account=YOUR-SA-NAME@project-id.iam.gserviceaccount.com\n```\n- Turn your service account key into a k8s [Secret](https://kubernetes.io/docs/concepts/configuration/secret/) :```\nkubectl create secret generic YOUR-SA-SECRET \\--from-file=service_account.json=~/key.json\n```\n- Mount the secret as a volume under the `spec:` for your k8s object: [  examples/k8s-sidecar/proxy_with_sa_key.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_sa_key.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_sa_key.yaml) ```\nvolumes:- name: <YOUR-SA-SECRET-VOLUME>\u00a0 secret:\u00a0 \u00a0 secretName: <YOUR-SA-SECRET>\n```\n- Follow the instructions in the next section to access the volume from the Cloud SQL Auth Proxy's pod.\n### Run the Cloud SQL Auth Proxy in a sidecar pattern\nWe recommend running the Cloud SQL Auth Proxy in a `sidecar` pattern (as an additional container sharing a pod with your application). We recommend this over running as a separate service for several reasons:\n- Prevents your SQL traffic from being exposed locally; the Cloud SQL Auth Proxy provides encryption on outgoing connections, but you need to limit exposure for incoming connections.\n- Prevents a single point of failure; each application's access to your database is independent from the others, making it more resilient.\n- Limits access to the Cloud SQL Auth Proxy, allowing you to use IAM permissions per application rather than exposing the database to the entire cluster.\n- Allows you to scope resource requests more accurately; because the Cloud SQL Auth Proxy consumes resources linearly to usage, this pattern allows you to more accurately scope and request resources to match your applications as it scales.\n- Add the Cloud SQL Auth Proxy to the pod configuration under `containers` : [  examples/k8s-sidecar/proxy_with_workload_identity.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_workload_identity.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_workload_identity.yaml) ```\n- name: cloud-sql-proxy\u00a0 # It is recommended to use the latest version of the Cloud SQL Auth Proxy\u00a0 # Make sure to update on a regular schedule!\u00a0 image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.8.0\u00a0 args:\u00a0 \u00a0 # If connecting from a VPC-native GKE cluster, you can use the\u00a0 \u00a0 # following flag to have the proxy connect over private IP\u00a0 \u00a0 # - \"--private-ip\"\u00a0 \u00a0 # Enable structured logging with LogEntry format:\u00a0 \u00a0 - \"--structured-logs\"\u00a0 \u00a0 # Replace DB_PORT with the port the proxy should listen on\u00a0 \u00a0 - \"--port=<DB_PORT>\"\u00a0 \u00a0 - \"<INSTANCE_CONNECTION_NAME>\"\u00a0 securityContext:\u00a0 \u00a0 # The default Cloud SQL Auth Proxy image runs as the\u00a0 \u00a0 # \"nonroot\" user and group (uid: 65532) by default.\u00a0 \u00a0 runAsNonRoot: true\u00a0 # You should use resource requests/limits as a best practice to prevent\u00a0 # pods from consuming too many resources and affecting the execution of\u00a0 # other pods. You should adjust the following values based on what your\u00a0 # application needs. For details, see\u00a0 # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\u00a0 resources:\u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 # The proxy's memory use scales linearly with the number of active\u00a0 \u00a0 \u00a0 # connections. Fewer open connections will use less memory. Adjust\u00a0 \u00a0 \u00a0 # this value based on your application's requirements.\u00a0 \u00a0 \u00a0 memory: \"2Gi\"\u00a0 \u00a0 \u00a0 # The proxy's CPU use scales linearly with the amount of IO between\u00a0 \u00a0 \u00a0 # the database and the application. Adjust this value based on your\u00a0 \u00a0 \u00a0 # application's requirements.\u00a0 \u00a0 \u00a0 cpu: \u00a0 \u00a0\"1\"\n```If you're using a service account key, specify your secret volume and add the `--credentials-file` flag to the command: [  examples/k8s-sidecar/proxy_with_sa_key.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_sa_key.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_sa_key.yaml) ```\n\u00a0 # This flag specifies where the service account key can be found\u00a0 - \"--credentials-file=/secrets/service_account.json\"securityContext:\u00a0 # The default Cloud SQL Auth Proxy image runs as the\u00a0 # \"nonroot\" user and group (uid: 65532) by default.\u00a0 runAsNonRoot: truevolumeMounts:- name: <YOUR-SA-SECRET-VOLUME>\u00a0 mountPath: /secrets/\u00a0 readOnly: true\n```\n- If you're using [IAM database authentication](/sql/docs/postgres/iam-logins#using_with_the) , start the Cloud SQL Auth Proxy with the`--auto-iam-authn`flag.\n- Finally, configure your application to connect using`127.0.0.1`on whicheveryou specified in the command section.\nComplete sample configuration files:\n[  examples/k8s-sidecar/proxy_with_workload_identity.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_workload_identity.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_workload_identity.yaml) \n```\n# Copyright 2021 Google LLC\n## Licensed under the Apache License, Version 2.0 (the \"License\");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at\n## \u00a0 \u00a0 \u00a0http://www.apache.org/licenses/LICENSE-2.0\n## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an \"AS IS\" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.apiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: <YOUR-DEPLOYMENT-NAME>spec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 serviceAccountName: <YOUR-KSA-NAME>\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 \u00a0 \u00a0 # ... other container configuration\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_USER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: username\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_PASS\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: database\u00a0 \u00a0 \u00a0 - name: cloud-sql-proxy\u00a0 \u00a0 \u00a0 \u00a0 # It is recommended to use the latest version of the Cloud SQL Auth Proxy\u00a0 \u00a0 \u00a0 \u00a0 # Make sure to update on a regular schedule!\u00a0 \u00a0 \u00a0 \u00a0 image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.8.0\u00a0 \u00a0 \u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # If connecting from a VPC-native GKE cluster, you can use the\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # following flag to have the proxy connect over private IP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # - \"--private-ip\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Enable structured logging with LogEntry format:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"--structured-logs\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Replace DB_PORT with the port the proxy should listen on\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"--port=<DB_PORT>\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"<INSTANCE_CONNECTION_NAME>\"\u00a0 \u00a0 \u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # The default Cloud SQL Auth Proxy image runs as the\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # \"nonroot\" user and group (uid: 65532) by default.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 runAsNonRoot: true\u00a0 \u00a0 \u00a0 \u00a0 # You should use resource requests/limits as a best practice to prevent\u00a0 \u00a0 \u00a0 \u00a0 # pods from consuming too many resources and affecting the execution of\u00a0 \u00a0 \u00a0 \u00a0 # other pods. You should adjust the following values based on what your\u00a0 \u00a0 \u00a0 \u00a0 # application needs. For details, see\u00a0 \u00a0 \u00a0 \u00a0 # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # The proxy's memory use scales linearly with the number of active\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # connections. Fewer open connections will use less memory. Adjust\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # this value based on your application's requirements.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: \"2Gi\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # The proxy's CPU use scales linearly with the amount of IO between\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # the database and the application. Adjust this value based on your\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # application's requirements.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: \u00a0 \u00a0\"1\"\n``` [  examples/k8s-sidecar/proxy_with_sa_key.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_sa_key.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/main/examples/k8s-sidecar/proxy_with_sa_key.yaml) \n```\n# Copyright 2021 Google LLC\n## Licensed under the Apache License, Version 2.0 (the \"License\");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at\n## \u00a0 \u00a0 \u00a0http://www.apache.org/licenses/LICENSE-2.0\n## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an \"AS IS\" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.apiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: <YOUR-DEPLOYMENT-NAME>spec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 \u00a0 \u00a0 # ... other container configuration\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_USER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: username\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_PASS\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: database\u00a0 \u00a0 \u00a0 - name: cloud-sql-proxy\u00a0 \u00a0 \u00a0 \u00a0 # It is recommended to use the latest version of the Cloud SQL Auth Proxy\u00a0 \u00a0 \u00a0 \u00a0 # Make sure to update on a regular schedule!\u00a0 \u00a0 \u00a0 \u00a0 image: gcr.io/cloud-sql-connectors/cloud-sql-proxy:2.8.0\u00a0 \u00a0 \u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # If connecting from a VPC-native GKE cluster, you can use the\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # following flag to have the proxy connect over private IP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # - \"--private-ip\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Enable structured logging with LogEntry format:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"--structured-logs\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # Replace DB_PORT with the port the proxy should listen on\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"--port=<DB_PORT>\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"<INSTANCE_CONNECTION_NAME>\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # This flag specifies where the service account key can be found\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 - \"--credentials-file=/secrets/service_account.json\"\u00a0 \u00a0 \u00a0 \u00a0 securityContext:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # The default Cloud SQL Auth Proxy image runs as the\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # \"nonroot\" user and group (uid: 65532) by default.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 runAsNonRoot: true\u00a0 \u00a0 \u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 \u00a0 \u00a0 - name: <YOUR-SA-SECRET-VOLUME>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mountPath: /secrets/\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 readOnly: true\u00a0 \u00a0 \u00a0 \u00a0 # Resource configuration depends on an application's requirements. You\u00a0 \u00a0 \u00a0 \u00a0 # should adjust the following values based on what your application\u00a0 \u00a0 \u00a0 \u00a0 # needs. For details, see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\u00a0 \u00a0 \u00a0 \u00a0 resources:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 requests:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # The proxy's memory use scales linearly with the number of active\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # connections. Fewer open connections will use less memory. Adjust\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # this value based on your application's requirements.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 memory: \"2Gi\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # The proxy's CPU use scales linearly with the amount of IO between\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # the database and the application. Adjust this value based on your\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # application's requirements.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cpu: \u00a0 \u00a0\"1\"\u00a0 \u00a0 \u00a0 volumes:\u00a0 \u00a0 \u00a0 - name: <YOUR-SA-SECRET-VOLUME>\u00a0 \u00a0 \u00a0 \u00a0 secret:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretName: <YOUR-SA-SECRET>\n```\n## Connect to Cloud SQL without the Cloud SQL Auth Proxy\nWhile not as secure, it is possible to connect from a [VPC-native GKE cluster](/kubernetes-engine/docs/how-to/alias-ips) to a Cloud SQL instance on the same VPC using private IP without the Cloud SQL Auth Proxy.\n- Create a secret with your instance's private IP address:```\nkubectl create secret generic <YOUR-PRIVATE-IP-SECRET> \\\u00a0 \u00a0 --from-literal=db_host=<YOUR-PRIVATE-IP-ADDRESS>\n```\n- Next make sure you add the secret to your application's container: [  examples/k8s-sidecar/no_proxy_private_ip.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/c733a6c62a4e5d7899156e2d77f6e2f839aff63e/examples/k8s-sidecar/no_proxy_private_ip.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/c733a6c62a4e5d7899156e2d77f6e2f839aff63e/examples/k8s-sidecar/no_proxy_private_ip.yaml) ```\n- name: DB_HOST\u00a0 valueFrom:\u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 name: <YOUR-PRIVATE-IP-SECRET>\u00a0 \u00a0 \u00a0 key: db_host\n```\n- Finally, configure your application to connect using the IP address from the `DB_HOST` env var. You will need to use the correct port for PostgreSQL: 5432\nComplete sample configuration file:\n[  examples/k8s-sidecar/no_proxy_private_ip.yaml ](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/c733a6c62a4e5d7899156e2d77f6e2f839aff63e/examples/k8s-sidecar/no_proxy_private_ip.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-sql-proxy/blob/c733a6c62a4e5d7899156e2d77f6e2f839aff63e/examples/k8s-sidecar/no_proxy_private_ip.yaml) \n```\n# Copyright 2021 Google LLC\n## Licensed under the Apache License, Version 2.0 (the \"License\");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at\n## \u00a0 \u00a0 \u00a0http://www.apache.org/licenses/LICENSE-2.0\n## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an \"AS IS\" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.apiVersion: apps/v1kind: Deploymentmetadata:\u00a0 name: <YOUR-DEPLOYMENT-NAME>spec:\u00a0 selector:\u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 template:\u00a0 \u00a0 metadata:\u00a0 \u00a0 \u00a0 labels:\u00a0 \u00a0 \u00a0 \u00a0 app: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 spec:\u00a0 \u00a0 \u00a0 containers:\u00a0 \u00a0 \u00a0 - name: <YOUR-APPLICATION-NAME>\u00a0 \u00a0 \u00a0 \u00a0 # ... other container configuration\u00a0 \u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_USER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: username\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_PASS\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_NAME\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-DB-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: database\u00a0 \u00a0 \u00a0 \u00a0 - name: DB_HOST\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: <YOUR-PRIVATE-IP-SECRET>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: db_host\n```\n## Troubleshooting\nNeed help? For help troubleshooting the proxy, see [Troubleshooting Cloud SQL Auth Proxy connections](/sql/docs/postgres/connect-auth-proxy#troubleshooting) , or see our [Cloud SQL Support](/sql/docs/postgres/getting-support) page.\n## What's next\n- Learn more about [private IP](/sql/docs/postgres/private-ip) .\n- Learn more about the [Cloud SQL Auth Proxy](/sql/docs/postgres/sql-proxy) and the [proxy docker image](/sql/docs/postgres/connect-auth-proxy#connecting-docker) .\n- Get help [troubleshooting Cloud SQL Auth Proxy connections](/sql/docs/postgres/connect-auth-proxy#troubleshooting) .\n- Learn more about [Google Kubernetes Engine](/kubernetes-engine/docs) .\n- Learn about [options for support](/sql/docs/postgres/support) .", "guide": "Cloud SQL"}