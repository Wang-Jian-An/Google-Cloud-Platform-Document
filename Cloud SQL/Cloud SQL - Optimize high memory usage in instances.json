{"title": "Cloud SQL - Optimize high memory usage in instances", "url": "https://cloud.google.com/sql/docs/postgres/optimize-high-memory-usage", "abstract": "# Cloud SQL - Optimize high memory usage in instances\n**    Preview     ** This feature is subject to the \"Pre-GA Offerings Terms\" in the General Service Terms section   of the [Service Specific Terms](/terms/service-terms#1) .     Pre-GA features are available \"as is\" and might have limited support.    For more information, see the [launch stage descriptions](/products#product-launch-stages) .\nThis document covers how to identify high memory usage for Cloud SQL instances and provides recommendations on how to solve memory-related issues.\nTo learn how to configure memory usage for a Cloud SQL instance, see [Best practices for managing memory usage](/sql/docs/postgres/manage-memory-usage-best-practices) .\n", "content": "## Identify high memory usage\n### Use Metrics Explorer to identify the memory usage\nYou can review memory usage of the instance with the [database/memory/components.usage](/sql/docs/postgres/admin-api/metrics) metric in [Metrics Explorer](/monitoring/charts/metrics-explorer) .\n**Note:** If you have less than 10% memory in `database/memory/components.cache` and `database/memory/components.free` combined, the risk of an OOM event is high. To monitor the memory usage and to prevent OOM events, we recommend that you set up an [alerting policy](/monitoring/alerts) with a metric threshold condition of 90% in `database/memory/components.usage` .\n### Use Query insights to analyse explain plan for queries that are consuming high resources\n[Query insights](/sql/docs/postgres/using-query-insights) helps you detect, diagnose, and prevent query performance problems for Cloud SQL databases. Query insights gives you a list of long running queries along with their [explain plan (PostgreSQL documentation)](https://www.postgresql.org/docs/current/sql-explain.html) . Review the explain plan and identify the part of the query that has a high memory usage scan method. Regardless of the query run time, query insights gives you the explain plan for all queries. Identify the complex queries that are taking more time so that you know which queries are blocking the memory for longer durations.\nCommon PostgreSQL scan methods that use high memory include the following:\n- Bitmap heap scan\n- Quick sort\n- Hash join or Hash## High Memory Usage - Recommendations\nThe following recommendations address the common memory-related problems. If the instance continues to use a high amount of memory, chances are high that it eventually gets an `out of memory` issue. If the memory demands of either PostgreSQL or another process cause the system to run out of memory, you see an `Out of Memory` kernel message in PostgreSQL logs and the PostgreSQL instance is eventually stopped. For example:\n`Out of Memory: Killed process 12345 (postgres)`\nThe most common instance where you see an OOM issue is with a higher value of `work_mem` with a high number of active connections. Therefore, if you are getting frequent OOMs or to avoid OOMs in your Cloud SQL for PostgreSQL instance, you should consider following these recommendations:\n- Set `work_mem`Queries that use quick sort are faster than the ones using external merge sort. However, the former may lead to memory exhaustion. To resolve this issue, set the `work_mem` value reasonable enough such that it balances both, the sort operations happening in the memory and disk. You can also consider setting `work_mem` on a session level rather than setting it for an entire instance.\n- Monitor the active sessionsEach connection uses a certain amount of memory. Use the following query to check the active connections count:```\n\u00a0 SELECT\u00a0 \u00a0 state,\u00a0 \u00a0 usename,\u00a0 \u00a0 count(1)\u00a0 FROM\u00a0 \u00a0 pg_stat_activity\u00a0 WHERE\u00a0 \u00a0 pid <> pg_backend_pid()\u00a0 GROUP BY\u00a0 \u00a0 state,\u00a0 \u00a0 usename\u00a0 ORDER BY\u00a0 \u00a0 1;\n```If you have a large number of active sessions, analyze the root cause for a high number of active sessions; for example, transaction locks.\n- Set `shared_buffers`If `shared_buffers` is set to a higher value, consider decreasing the `shared_buffers` value so that the memory can be used for other operations, such as `work_mem` , or for establishing new connections. **Cache hit ratio** PostgreSQL generally tries to keep the data you access most often in the cache. When the data is requested by a client, if it's already cached in shared buffers, it's directly given to the client. This is called a . If the data is not present in shared buffers, the data is first fetched to shared buffers from a disk and then given to the client. This is called a . Cache hit ratio measures how many content requests the cache has handled compared to the requests received. Run the following query to check the cache hit ratio for the table requests in the PostgreSQL instance:```\nSELECT\u00a0 sum(heap_blks_read) as heap_read,\u00a0 sum(heap_blks_hit) \u00a0as heap_hit,\u00a0 sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratioFROM\u00a0 pg_statio_user_tables;\n```Run the following query to check the cache hit ratio for the index requests in the PostgreSQL instance:```\n\u00a0 SELECT\u00a0 \u00a0 sum(idx_blks_read) as idx_read,\u00a0 \u00a0 sum(idx_blks_hit) \u00a0as idx_hit,\u00a0 \u00a0 (sum(idx_blks_hit) - sum(idx_blks_read)) / sum(idx_blks_hit) as ratio\u00a0 FROM\u00a0 \u00a0 pg_statio_user_indexes;\n```Generally, 95 to 99% of cache hit ratio is considered to be a good value.\n- Enable huge pages Cloud SQL for PostgreSQL by default has `huge_pages` enabled for better memory management. We recommend that you enable it. To learn more about `huge_pages` , see [PostreSQL documentation](https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-HUGE-PAGES) .\n- Set `max_locks_per_transaction`The `max_locks_per_transaction` value indicates the number of database objects that can be locked simultaneously. In most cases, the default value of 64 is sufficient. However, if you are dealing with a large data set, you may end up with OOMs. Consider increasing the value of `max_locks_per_transaction` high enough to avoid OOMs. **Note:** The object-level locking happens in memory on an ongoing transaction, Increasing the `max_prepared_transactions` value unreasonably high can cause the database instance to request more shared memory.The `max_locks_per_transaction` value should be `max_locks_per_transaction` * ( `max_connections` + `max_prepared_transactions` ) objects. This means that if you have 300 thousand objects, and if the value of `max_connections` is 200, then `max_locks_per_transaction` should be 1500.\n- Set `max_pred_locks_per_transaction`The transaction might fail if you have clients that touch many different tables in a single serializable transaction. In that scenario, consider increasing `max_pred_locks_per_transaction` to a reasonably high value. Like `max_locks_per_transaction` , `max_pred_locks_per_transaction` also uses shared memory so do not set an unreasonable high value.\n- If the memory usage is still high and you feel those queries are legitimate traffic, then consider increasing the number of memory resources in your instance to avoid database crash or downtime.", "guide": "Cloud SQL"}