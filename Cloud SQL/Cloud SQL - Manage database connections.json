{"title": "Cloud SQL - Manage database connections", "url": "https://cloud.google.com/sql/docs/postgres/manage-connections", "abstract": "# Cloud SQL - Manage database connections\nThis page provides best practices and language-specific code samples to help you create applications that use Cloud SQL database connections effectively.\nThese samples are excerpts from a complete web application available to you on GitHub. [Learn more](#app-links) .\n**For step-by-step instructions on running a sample webapplication connected to Cloud SQL,** follow the link for your environment:\n- [Quickstart for connecting from your local computer](/sql/docs/postgres/connect-instance-local-computer) \n- [Quickstart for connecting from Compute Engine](/sql/docs/postgres/connect-instance-compute-engine) \n- [Quickstart for connecting from Cloud Run](/sql/docs/postgres/connect-instance-cloud-run) \n- [Quickstart for connecting from Cloud Functions](/sql/docs/postgres/connect-instance-cloud-functions) \n- [Quickstart for connecting from Google Kubernetes Engine](/sql/docs/postgres/connect-instance-kubernetes) ", "content": "## Connection pools\nA connection pool is a cache of database connections that are shared and reused to improve connection latency and performance. When your application needs a database connection, it borrows one from its pool temporarily; when the application is finished with the connection, it returns the connection to the pool, where it can be reused the next time the application needs a database connection.## Open and close connections\nWhen you use a connection pool, you must open and close connections properly, so that your connections are always returned to the pool when you are done with them. Unreturned or \"leaked\" connections are not reused, which wastes resources and can cause performance bottlenecks for your application.\n[  cloud-sql/postgres/sqlalchemy/app.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/app.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/app.py) \n```\n# Preparing a statement before hand can help protect against injections.stmt = sqlalchemy.text(\u00a0 \u00a0 \"INSERT INTO votes (time_cast, candidate) VALUES (:time_cast, :candidate)\")try:\u00a0 \u00a0 # Using a with statement ensures that the connection is always released\u00a0 \u00a0 # back into the pool at the end of statement (even if an error occurs)\u00a0 \u00a0 with db.connect() as conn:\u00a0 \u00a0 \u00a0 \u00a0 conn.execute(stmt, parameters={\"time_cast\": time_cast, \"candidate\": team})\u00a0 \u00a0 \u00a0 \u00a0 conn.commit()except Exception as e:\u00a0 \u00a0 # If something goes wrong, handle the error in this section. This might\u00a0 \u00a0 # involve retrying or adjusting parameters depending on the situation.\u00a0 \u00a0 # ...\n``` [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/IndexServlet.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/IndexServlet.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/IndexServlet.java) \n```\n// Using a try-with-resources statement ensures that the connection is always released back// into the pool at the end of the statement (even if an error occurs)try (Connection conn = pool.getConnection()) {\u00a0 // PreparedStatements can be more efficient and project against injections.\u00a0 String stmt = \"INSERT INTO votes (time_cast, candidate) VALUES (?, ?);\";\u00a0 try (PreparedStatement voteStmt = conn.prepareStatement(stmt);) {\u00a0 \u00a0 voteStmt.setTimestamp(1, now);\u00a0 \u00a0 voteStmt.setString(2, team);\u00a0 \u00a0 // Finally, execute the statement. If it fails, an error will be thrown.\u00a0 \u00a0 voteStmt.execute();\u00a0 }} catch (SQLException ex) {\u00a0 // If something goes wrong, handle the error in this section. This might involve retrying or\u00a0 // adjusting parameters depending on the situation.\u00a0 // ...}\n``` [  cloud-sql/postgres/knex/index.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) \n```\n/**\u00a0* Insert a vote record into the database.\u00a0*\u00a0* @param {object} pool The Knex connection object.\u00a0* @param {object} vote The vote record to insert.\u00a0* @returns {Promise}\u00a0*/const insertVote = async (pool, vote) => {\u00a0 try {\u00a0 \u00a0 return await pool('votes').insert(vote);\u00a0 } catch (err) {\u00a0 \u00a0 throw Error(err);\u00a0 }};\n``` [  cloud-sql/postgres/ConnectTcp.cs ](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/ConnectTcp.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/ConnectTcp.cs) \n```\nusing Npgsql;using System;namespace CloudSql{\u00a0 \u00a0 public class PostgreSqlTcp\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 public static NpgsqlConnectionStringBuilder NewPostgreSqlTCPConnectionString()\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Equivalent connection string:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // \"Uid=<DB_USER>;Pwd=<DB_PASS>;Host=<INSTANCE_HOST>;Database=<DB_NAME>;\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var connectionString = new NpgsqlConnectionStringBuilder()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // secure - consider a more secure solution such as\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // keep secrets safe.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Host = Environment.GetEnvironmentVariable(\"INSTANCE_HOST\"), \u00a0 \u00a0 // e.g. '127.0.0.1'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Set Host to 'cloudsql' when deploying to App Engine Flexible environment\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Username = Environment.GetEnvironmentVariable(\"DB_USER\"), // e.g. 'my-db-user'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Password = Environment.GetEnvironmentVariable(\"DB_PASS\"), // e.g. 'my-db-password'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Database = Environment.GetEnvironmentVariable(\"DB_NAME\"), // e.g. 'my-database'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // The Cloud SQL proxy provides encryption between the proxy and instance.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SslMode = SslMode.Disable,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 };\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 connectionString.Pooling = true;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Specify additional properties here.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return connectionString;\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }}\n``` [  cloudsql/postgres/database-sql/cloudsql.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/cloudsql.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/cloudsql.go) \n```\ninsertVote := \"INSERT INTO votes(candidate, created_at) VALUES($1, NOW())\"_, err := db.Exec(insertVote, team)\n``` [  cloud-sql/postgres/activerecord/app/controllers/votes_controller.rb ](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/app/controllers/votes_controller.rb) [View on GitHub](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/app/controllers/votes_controller.rb) \n```\n@vote = Vote.new candidate: candidate# ActiveRecord creates and executes your SQL and automatically# handles the opening and closing of the database connection.if @vote.save\u00a0 render json: \"Vote successfully cast for \\\"#{@vote.candidate}\\\" at #{@vote.time_cast} PST!\"else\u00a0 render json: @vote.errors, status: :unprocessable_entityend\n``` [  cloud_sql/postgres/pdo/src/Votes.php ](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/Votes.php) [View on GitHub](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/Votes.php) \n```\n// Use prepared statements to guard against SQL injection.$sql = 'INSERT INTO votes (time_cast, candidate) VALUES (NOW(), :voteValue)';try {\u00a0 \u00a0 $statement = $conn->prepare($sql);\u00a0 \u00a0 $statement->bindParam('voteValue', $value);\u00a0 \u00a0 $res = $statement->execute();} catch (PDOException $e) {\u00a0 \u00a0 throw new RuntimeException(\u00a0 \u00a0 \u00a0 \u00a0 'Could not insert vote into database. The PDO exception was ' .\u00a0 \u00a0 \u00a0 \u00a0 $e->getMessage(),\u00a0 \u00a0 \u00a0 \u00a0 $e->getCode(),\u00a0 \u00a0 \u00a0 \u00a0 $e\u00a0 \u00a0 );}\n```\n **Note:** Most PHP applications are not long-running. They start at the beginning of request processing and shut down when request processing ends. Database connections are closed when the application shuts down.\n## Connection count\nEvery database connection uses client and server-side resources. In addition, Cloud SQL imposes overall connection limits that cannot be exceeded. Creating and using fewer connections reduces overhead and helps you stay under the connection limit.\n[  cloud-sql/postgres/sqlalchemy/connect_tcp.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) \n```\n# Pool size is the maximum number of permanent connections to keep.pool_size=5,# Temporarily exceeds the set pool_size if no connections are available.max_overflow=2,# The total number of concurrent connections for your application will be# a total of pool_size and max_overflow.\n``` [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) \n```\n// maximumPoolSize limits the total number of concurrent connections this pool will keep. Ideal// values for this setting are highly variable on app design, infrastructure, and database.config.setMaximumPoolSize(5);// minimumIdle is the minimum number of idle connections Hikari maintains in the pool.// Additional connections will be established to meet this value unless the pool is full.config.setMinimumIdle(5);\n``` [  cloud-sql/postgres/knex/index.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) \n```\n// 'max' limits the total number of concurrent connections this pool will keep. Ideal// values for this setting are highly variable on app design, infrastructure, and database.config.pool.max = 5;// 'min' is the minimum number of idle connections Knex maintains in the pool.// Additional connections will be established to meet this value unless the pool is full.config.pool.min = 5;\n``` [  cloud-sql/postgres/Startup.cs ](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) \n```\n// MaxPoolSize sets maximum number of connections allowed in the pool.connectionString.MaxPoolSize = 5;// MinPoolSize sets the minimum number of connections in the pool.connectionString.MinPoolSize = 0;\n``` [  cloudsql/postgres/database-sql/cloudsql.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/cloudsql.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/cloudsql.go) \n```\n// Set maximum number of connections in idle connection pool.db.SetMaxIdleConns(5)// Set maximum number of open connections to the database.db.SetMaxOpenConns(7)\n``` [  cloud-sql/postgres/activerecord/config/database_tcp.yml ](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) [View on GitHub](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) \n```\n# 'pool' is the maximum number of permanent connections to keep.pool: 5\n```\n [PDO](https://www.php.net/manual/en/book.pdo.php) currently doesn't offer any functionality to configure connection limits.\n## Exponential backoff\nIf your application attempts to connect to the database and does not succeed, the database could be temporarily unavailable. In this case, sending repeated connection requests wastes resources. It is preferable to wait before sending additional connection requests in order to allow the database to become accessible again. Using an exponential backoff or other delay mechanism achieves this goal.\nThis retry only makes sense when first connecting, or when first grabbing a connection from the pool. If errors happen in the middle of a transaction, the must do the retrying, and it must retry from the beginning of a transaction. So even if your pool is configured properly, the application might still see errors if connections are lost.\n[  cloud-sql/postgres/sqlalchemy/connect_tcp.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) \n```\n# SQLAlchemy automatically uses delays between failed connection attempts,# but provides no arguments for configuration.\n``` [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) \n```\n// Hikari automatically delays between failed connection attempts, eventually reaching a// maximum delay of `connectionTimeout / 2` between attempts.\n``` [  cloud-sql/postgres/knex/index.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) \n```\n// 'knex' uses a built-in retry strategy which does not implement backoff.// 'createRetryIntervalMillis' is how long to idle after failed connection creation before trying againconfig.pool.createRetryIntervalMillis = 200; // 0.2 seconds\n``` [  cloud-sql/postgres/Startup.cs ](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) \n```\nPolicy\u00a0 \u00a0 .Handle<NpgsqlException>()\u00a0 \u00a0 .WaitAndRetry(new[]\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 TimeSpan.FromSeconds(1),\u00a0 \u00a0 \u00a0 \u00a0 TimeSpan.FromSeconds(2),\u00a0 \u00a0 \u00a0 \u00a0 TimeSpan.FromSeconds(5)\u00a0 \u00a0 })\u00a0 \u00a0 .Execute(() => connection.Open());\n```\nThe [database/sql](http://go-database-sql.org/) package currently doesn't offer any functionality to configure exponential backoff.\n [  cloud-sql/postgres/activerecord/config/database_tcp.yml ](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) [View on GitHub](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) \n```\n# ActiveRecord automatically uses delays between failed connection attempts,# but provides no arguments for configuration.\n```\n [PDO](https://www.php.net/manual/en/book.pdo.php) currently doesn't offer any functionality to configure exponential backoff.\n## Connection timeout\nThere are many reasons why a connection attempt might not succeed. Network communication is never guaranteed, and the database might be temporarily unable to respond. Make sure your application handles broken or unsuccessful connections gracefully.\n[  cloud-sql/postgres/sqlalchemy/connect_tcp.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) \n```\n# 'pool_timeout' is the maximum number of seconds to wait when retrieving a# new connection from the pool. After the specified amount of time, an# exception will be thrown.pool_timeout=30, \u00a0# 30 seconds\n``` [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) \n```\n// setConnectionTimeout is the maximum number of milliseconds to wait for a connection checkout.// Any attempt to retrieve a connection from this pool that exceeds the set limit will throw an// SQLException.config.setConnectionTimeout(10000); // 10 seconds// idleTimeout is the maximum amount of time a connection can sit in the pool. Connections that// sit idle for this many milliseconds are retried if minimumIdle is exceeded.config.setIdleTimeout(600000); // 10 minutes\n``` [  cloud-sql/postgres/knex/index.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/index.js) \n```\n// 'acquireTimeoutMillis' is the number of milliseconds before a timeout occurs when acquiring a// connection from the pool. This is slightly different from connectionTimeout, because acquiring// a pool connection does not always involve making a new connection, and may include multiple retries.// when making a connectionconfig.pool.acquireTimeoutMillis = 60000; // 60 seconds// 'createTimeoutMillis` is the maximum number of milliseconds to wait trying to establish an// initial connection before retrying.// After acquireTimeoutMillis has passed, a timeout exception will be thrown.config.pool.createTimeoutMillis = 30000; // 30 seconds// 'idleTimeoutMillis' is the number of milliseconds a connection must sit idle in the pool// and not be checked out before it is automatically closed.config.pool.idleTimeoutMillis = 600000; // 10 minutes\n``` [  cloud-sql/postgres/Startup.cs ](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) \n```\n// Timeout sets the time to wait (in seconds) while// trying to establish a connection before terminating the attempt.connectionString.Timeout = 15;\n```\nThe [database/sql](http://go-database-sql.org/) package currently doesn't offer any functionality to configure connection timeout. Timeout is configured at the driver level.\n [  cloud-sql/postgres/activerecord/config/database_tcp.yml ](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) [View on GitHub](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) \n```\n# 'timeout' is the maximum number of seconds to wait when retrieving a# new connection from the pool. After the specified amount of time, an# ActiveRecord::ConnectionTimeoutError will be raised.timeout: 5000\n``` [  cloud_sql/postgres/pdo/src/DatabaseTcp.php ](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/DatabaseTcp.php) [View on GitHub](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/DatabaseTcp.php) \n```\n// Here we set the connection timeout to five seconds and ask PDO to// throw an exception if any errors occur.[\u00a0 \u00a0 PDO::ATTR_TIMEOUT => 5,\u00a0 \u00a0 PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,]\n```\n## Connection duration\nLimiting a connection's lifetime can help prevent abandoned connections from accumulating. You can use the connection pool to limit your connection lifetimes.\n[  cloud-sql/postgres/sqlalchemy/connect_tcp.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) \n```\n# 'pool_recycle' is the maximum number of seconds a connection can persist.# Connections that live longer than the specified amount of time will be# re-establishedpool_recycle=1800, \u00a0# 30 minutes\n``` [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/ConnectionPoolFactory.java) \n```\n// maxLifetime is the maximum possible lifetime of a connection in the pool. Connections that// live longer than this many milliseconds will be closed and reestablished between uses. This// value should be several minutes shorter than the database's timeout value to avoid unexpected// terminations.config.setMaxLifetime(1800000); // 30 minutes\n```\nThe ' [knex](https://github.com/knex/knex) ' Node.js library currently doesn't offer any functionality to control the duration of a connection.\n [  cloud-sql/postgres/Startup.cs ](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/Startup.cs) \n```\n// ConnectionIdleLifetime sets the time (in seconds) to wait before// closing idle connections in the pool if the count of all// connections exceeds MinPoolSize.connectionString.ConnectionIdleLifetime = 300;\n``` [  cloudsql/postgres/database-sql/cloudsql.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/cloudsql.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/cloudsql.go) \n```\n// Set Maximum time (in seconds) that a connection can remain open.db.SetConnMaxLifetime(1800 * time.Second)\n```\n [ActiveRecord](https://github.com/rails/rails/tree/master/activerecord) currently doesn't offer any functionality to control the duration of a connection.\n [PDO](https://www.php.net/manual/en/book.pdo.php) currently doesn't offer any functionality to control the duration of a connection.\n## View the complete application\nTo see the complete application, click the link below.\nView the [complete application](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/cloud-sql/postgres/sqlalchemy/README.md) for the Python programming language.\nView the [complete application](https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/cloud-sql/postgres/servlet) for the Java programming language.\nView the [complete application](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/master/cloud-sql/mysql/mysql/README.md) for the Node.js programming language.\nView the [complete application](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/cloud-sql/postgres/README.md) for the C# programming language.\nView the [complete application](https://github.com/GoogleCloudPlatform/golang-samples/blob/master/cloudsql/postgres/database-sql/README.md) for the Go programming language.\nView the [complete application](https://github.com/GoogleCloudPlatform/ruby-docs-samples/tree/master/cloud-sql/postgres/activerecord) for the Ruby programming language.\nView the [complete application](https://github.com/GoogleCloudPlatform/php-docs-samples/tree/main/cloud_sql/postgres/pdo) for the PHP programming language.\n## What's next\n- Learn more about [Private IP](/sql/docs/postgres/private-ip) .\n- Learn about [quotas and limits](/sql/docs/postgres/quotas) for Cloud SQL and App Engine.\n- Learn about [best practices](/sql/docs/postgres/best-practices) for working with Cloud SQL.\n- Learn more about [connecting from an external application](/sql/docs/postgres/connect-external-app) .", "guide": "Cloud SQL"}