{"title": "Cloud SQL - Connect from Cloud Build", "url": "https://cloud.google.com/sql/docs/postgres/connect-build", "abstract": "# Cloud SQL - Connect from Cloud Build\nThis page contains information and examples for connecting to a Cloud SQL instance from a service running in Cloud Build.\nCloud SQL is a fully-managed database service that helps you set up, maintain, manage, and administer your relational databases in the cloud.\n[Cloud Build](/build/docs/overview) is a service that executes your builds on Google Cloud infrastructure.\n", "content": "## Set up a Cloud SQL instance\n- Enable the Cloud SQL Admin API in the Google Cloud project that you are connecting from, if you haven't already done so: [Enable the API](https://console.cloud.google.com/flows/enableapi?apiid=sqladmin&redirect=https://console.cloud.google.com) \n- [Create a Cloud SQL for PostgreSQL instance](/sql/docs/postgres/create-instance) .By default, Cloud SQL assigns a public IP address to a new  instance.  You also have the option to assign a private IP address. For more  information about the connectivity options for both, see the [ Connecting Overview](/sql/docs/postgres/connect-overview) page.## Configure Cloud Build\nMake sure your [ Cloud Build service account](/build/docs/cloud-build-service-account) has the [IAM roles and permissions required to connect to the Cloud SQL instance](/sql/docs/mysql/project-access-control#roles) . The Cloud Build service account is listed on the Google Cloud console [IAM](https://console.cloud.google.com/iam-admin) page as the **Principal** `[YOUR-PROJECT-NUMBER]@cloudbuild.gserviceaccount.com` .\nTo view this service account in the Google Cloud console, select the **Include Google-provided role grants** checkbox.\nYour Cloud Build service account needs one of the following [IAM roles](/iam/docs/understanding-roles#cloud-sql-roles) :- `Cloud SQL Client`(preferred)\n- `Cloud SQL Admin`Or, you can manually assign the following IAM permissions:\n- `cloudsql.instances.connect`\n- `cloudsql.instances.get`\nIf the Cloud Build service account belongs to a different project than the Cloud SQL instance, then the Cloud SQL Admin API and IAM permissions need to be added for both projects.To connect to your Cloud SQL instance over private IP, Cloud Build must be in the same VPC network as your Cloud SQL instance. To configure this:\n- Set up a private connection between the [VPC network of your Cloud SQL instance and the service producer network](/build/docs/private-pools/set-up-private-pool-environment#setup-private-connection) .\n- Create a [Cloud Build private pool](/build/docs/private-pools/create-manage-private-pools#creating_a_new_private_pool) .\nOnce configured, your application will be able to connect directly using your instance's private IP address and port `5432` when your build is run in the pool.\n## Connect to Cloud SQL\nAfter you configure Cloud Build, you can connect to your Cloud SQL instance.\nFor public IP paths, Cloud Build supports both Unix and TCP sockets.\nYou can use the Cloud SQL Auth Proxy in a Cloud Build step to allow connections to your database. This configuration:\n- Builds your container and pushes it to Container Registry. **Note:** Container Registry is deprecated and scheduled for shutdown. Organizations that haven't used Container Registry prior to January 8, 2024 have new gcr.io repositories hosted on Artifact Registry by default. After May 15, 2024, Google Cloud projects without previous usage of Container Registry will only support hosting and managing images for the `gcr.io` domain in [Artifact Registry](/artifact-registry/docs) .Container Registry is scheduled for shutdown on March 18, 2025. For details on the deprecation, see [Container Registry deprecation](/container-registry/docs/deprecations/container-registry-deprecation) .\n- Builds a second container, copying in the Cloud SQL Auth Proxy binary.\n- Containers built by Cloud Build do not need to be pushed to any registry, and are [discarded on build completion](https://cloud.google.com/build/docs/build-config-file-schema#images) .\n- Using the second container, starts the Cloud SQL Auth Proxy and runs any migration commands.\n [  sql-proxy/cloudbuild.yaml ](https://github.com/GoogleCloudPlatform/cloud-build-samples/blob/HEAD/sql-proxy/cloudbuild.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-build-samples/blob/HEAD/sql-proxy/cloudbuild.yaml) \n```\nsteps:\u00a0 - id: \"docker-build\"\u00a0 \u00a0 name: \"gcr.io/cloud-builders/docker\"\u00a0 \u00a0 args: [\"build\", \"-t\", \"${_IMAGE_NAME}\", \"sql-proxy/.\"]\u00a0 - id: \"docker-push\"\u00a0 \u00a0 name: \"gcr.io/cloud-builders/docker\"\u00a0 \u00a0 args: [\"push\", \"${_IMAGE_NAME}\"]\u00a0 - id: \"docker-layer\"\u00a0 \u00a0 name: \"gcr.io/cloud-builders/docker\"\u00a0 \u00a0 entrypoint: /bin/bash\u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 - '-c'\u00a0 \u00a0 \u00a0 - |\u00a0 \u00a0 \u00a0 \u00a0 echo \"FROM $_IMAGE_NAME\u00a0 \u00a0 \u00a0 \u00a0 COPY --from=gcr.io/cloud-sql-connectors/cloud-sql-proxy /cloud-sql-proxy /cloudsql/cloud-sql-proxy\" > Dockerfile-proxy;\u00a0 \u00a0 \u00a0 \u00a0 docker build -f Dockerfile-proxy -t ${_IMAGE_NAME}-proxy .\u00a0 # For TCP connections\u00a0 - id: \"migrate-tcp\"\u00a0 \u00a0 name: \"${_IMAGE_NAME}-proxy\"\u00a0 \u00a0 dir: sql-proxy\u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 - \"DATABASE_NAME=${_DATABASE_NAME}\"\u00a0 \u00a0 \u00a0 - \"DATABASE_USER=${_DATABASE_USER}\"\u00a0 \u00a0 \u00a0 - \"DATABASE_HOST=127.0.0.1\"\u00a0 \u00a0 \u00a0 - \"DATABASE_PORT=${_DATABASE_PORT}\"\u00a0 \u00a0 \u00a0 - \"DATABASE_TYPE=${_DATABASE_TYPE}\"\u00a0 \u00a0 secretEnv:\u00a0 \u00a0 \u00a0 - DATABASE_PASS\u00a0 \u00a0 entrypoint: /bin/bash\u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 - '-c'\u00a0 \u00a0 \u00a0 - |\u00a0 \u00a0 \u00a0 \u00a0 /cloudsql/cloud-sql-proxy --port ${_DATABASE_PORT} ${_INSTANCE_CONNECTION_NAME} & sleep 2;\u00a0 \u00a0 \u00a0 \u00a0 python migrate.py # for example\u00a0 # For Unix Socket connections\u00a0 - id: \"migrate-socket\"\u00a0 \u00a0 name: \"${_IMAGE_NAME}-proxy\"\u00a0 \u00a0 dir: sql-proxy\u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 - \"DATABASE_NAME=${_DATABASE_NAME}\"\u00a0 \u00a0 \u00a0 - \"DATABASE_USER=${_DATABASE_USER}\"\u00a0 \u00a0 \u00a0 - \"INSTANCE_CONNECTION_NAME=${_INSTANCE_CONNECTION_NAME}\"\u00a0 \u00a0 \u00a0 - \"DATABASE_TYPE=${_DATABASE_TYPE}\"\u00a0 \u00a0 secretEnv:\u00a0 \u00a0 \u00a0 - DATABASE_PASS\u00a0 \u00a0 entrypoint: /bin/bash\u00a0 \u00a0 args:\u00a0 \u00a0 \u00a0 - '-c'\u00a0 \u00a0 \u00a0 - |\u00a0 \u00a0 \u00a0 \u00a0 /cloudsql/cloud-sql-proxy --unix-socket /cloudsql ${_INSTANCE_CONNECTION_NAME} & sleep 2;\u00a0 \u00a0 \u00a0 \u00a0 if [ $_DATABASE_TYPE = 'mssql' ]; then echo \"MSSQL doesn't support Unix Sockets. Skippng.\"; exit 0; fi;\u00a0 \u00a0 \u00a0 \u00a0 python migrate.py # for example.options:\u00a0 dynamic_substitutions: truesubstitutions:\u00a0 _DATABASE_USER: myuser\u00a0 _DATABASE_NAME: mydatabase\u00a0 _INSTANCE_CONNECTION_NAME: ${PROJECT_ID}:us-central1:myinstance\u00a0 _DATABASE_PORT: '5432'\u00a0 _DATABASE_TYPE: postgres\u00a0 _DATABASE_PASSWORD_KEY: database_password\u00a0 _IMAGE_NAME: gcr.io/${PROJECT_ID}/sample-sql-proxyavailableSecrets:\u00a0 secretManager:\u00a0 \u00a0 - versionName: projects/$PROJECT_ID/secrets/${_DATABASE_PASSWORD_KEY}/versions/latest\u00a0 \u00a0 \u00a0 env: DATABASE_PASS\n```\nThe Cloud Build code sample above shows how you might run a hypothetical **migrate** script after deploying the sample app above to update its Cloud SQL database using the Cloud SQL Auth Proxy and Cloud Build. To run this Cloud Build code sample the setup steps required are:- Create a folder name`sql-proxy`\n- Create a`Dockerfile`file in the`sql-proxy`folder with the following single line of code for its file contents:```\nFROM gcr.io/gcp-runtimes/ubuntu_20_0_4\n```\n- Create a`cloudbuild.yaml`file in the`sql-proxy`folder.\n- Update the`cloudbuild.yaml`file:- Copy the sample Cloud Build code above and paste it into the`cloudbuild.yaml`file.\n- Use either a TCP connection or a Unix socket connection by removing the code block for the connection method not being used.\n- Replace the following placeholder values with the values used in your project:- `mydatabase`\n- `myuser`\n- `myinstance`\n- Create a secret named`database_password`in [Secret Manager](https://console.cloud.google.com/security/secret-manager/) .- In order for the Cloud Build service account to access this secret, you will have to grant it the [Secret Manager Secret Accessor](/iam/docs/understanding-roles#secret-manager-roles) role in [IAM](https://console.cloud.google.com/iam-admin/iam) . See [Using secrets from Secret Manager](/build/docs/securing-builds/use-secrets) for more information.\n- Create a **migrate.py** script file in the`sql-proxy`folder.- The script can reference the following environment variables and the secret created in the`cloudbuild.yaml`file using the following examples:- `os.getenv('DATABASE_NAME')`\n- `os.getenv('DATABASE_USER')`\n- `os.getenv('DATABASE_PASS')`\n- `os.getenv('INSTANCE_CONNECTION_NAME')`\n- To reference the same variables from a Bash script (for example:`migrate.sh`) use the following examples:- `$DATABASE_NAME`\n- `$DATABASE_USER`\n- `$DATABASE_PASS`\n- `$INSTANCE_CONNECTION_NAME`\n- Run the following [gcloud builds submit](/sdk/gcloud/reference/builds/submit) command to build a container with the Cloud SQL Auth Proxy, start the Cloud SQL Auth Proxy, and run the`migrate.py`script:```\ngcloud builds submit --config cloudbuild.yaml\n```\nFor private IP paths, your application connects directly to your instance through private pools. This method uses TCP to connect directly to the Cloud SQL instance without using the Cloud SQL Auth Proxy.\n### Connect with TCPConnect using the private IP address of your Cloud SQL instance as the host and port `5432` .To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/cloud-sql/postgres/sqlalchemy/README.md) .\n [  cloud-sql/postgres/sqlalchemy/connect_tcp.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/cloud-sql/postgres/sqlalchemy/connect_tcp.py) \n```\nimport osimport sslimport sqlalchemydef connect_tcp_socket() -> sqlalchemy.engine.base.Engine:\u00a0 \u00a0 \"\"\"Initializes a TCP connection pool for a Cloud SQL instance of Postgres.\"\"\"\u00a0 \u00a0 # Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 # secure - consider a more secure solution such as\u00a0 \u00a0 # Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 # keep secrets safe.\u00a0 \u00a0 db_host = os.environ[\u00a0 \u00a0 \u00a0 \u00a0 \"INSTANCE_HOST\"\u00a0 \u00a0 ] \u00a0# e.g. '127.0.0.1' ('172.17.0.1' if deployed to GAE Flex)\u00a0 \u00a0 db_user = os.environ[\"DB_USER\"] \u00a0# e.g. 'my-db-user'\u00a0 \u00a0 db_pass = os.environ[\"DB_PASS\"] \u00a0# e.g. 'my-db-password'\u00a0 \u00a0 db_name = os.environ[\"DB_NAME\"] \u00a0# e.g. 'my-database'\u00a0 \u00a0 db_port = os.environ[\"DB_PORT\"] \u00a0# e.g. 5432\u00a0 \u00a0 pool = sqlalchemy.create_engine(\u00a0 \u00a0 \u00a0 \u00a0 # Equivalent URL:\u00a0 \u00a0 \u00a0 \u00a0 # postgresql+pg8000://<db_user>:<db_pass>@<db_host>:<db_port>/<db_name>\u00a0 \u00a0 \u00a0 \u00a0 sqlalchemy.engine.url.URL.create(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 drivername=\"postgresql+pg8000\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 username=db_user,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 password=db_pass,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 host=db_host,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 port=db_port,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 database=db_name,\u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 \u00a0 \u00a0 # ...\u00a0 \u00a0 )\u00a0 \u00a0 return pool\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/master/cloud-sql/postgres/servlet/README.md) .\nNote:\n- CLOUD_SQL_CONNECTION_NAME should be represented as    <MY-PROJECT>:<INSTANCE-REGION>:<INSTANCE-NAME>\n- Using the argument ipTypes=PRIVATE will force the SocketFactory    to connect with an instance's associated private IP\n- See the JDBC socket factory version requirements for the pom.xml    file [ here ](https://github.com/GoogleCloudPlatform/cloud-sql-jdbc-socket-factory/blob/main/docs/jdbc-mysql.md) .\n [  cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/TcpConnectionPoolFactory.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/TcpConnectionPoolFactory.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/cloud-sql/postgres/servlet/src/main/java/com/example/cloudsql/TcpConnectionPoolFactory.java) \n```\nimport com.zaxxer.hikari.HikariConfig;import com.zaxxer.hikari.HikariDataSource;import javax.sql.DataSource;public class TcpConnectionPoolFactory extends ConnectionPoolFactory {\u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 // secure - consider a more secure solution such as\u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 // keep secrets safe.\u00a0 private static final String DB_USER = System.getenv(\"DB_USER\");\u00a0 private static final String DB_PASS = System.getenv(\"DB_PASS\");\u00a0 private static final String DB_NAME = System.getenv(\"DB_NAME\");\u00a0 private static final String INSTANCE_HOST = System.getenv(\"INSTANCE_HOST\");\u00a0 private static final String DB_PORT = System.getenv(\"DB_PORT\");\u00a0 public static DataSource createConnectionPool() {\u00a0 \u00a0 // The configuration object specifies behaviors for the connection pool.\u00a0 \u00a0 HikariConfig config = new HikariConfig();\u00a0 \u00a0 // The following URL is equivalent to setting the config options below:\u00a0 \u00a0 // jdbc:postgresql://<INSTANCE_HOST>:<DB_PORT>/<DB_NAME>?user=<DB_USER>&password=<DB_PASS>\u00a0 \u00a0 // See the link below for more info on building a JDBC URL for the Cloud SQL JDBC Socket Factory\u00a0 \u00a0 // https://github.com/GoogleCloudPlatform/cloud-sql-jdbc-socket-factory#creating-the-jdbc-url\u00a0 \u00a0 // Configure which instance and what database user to connect with.\u00a0 \u00a0 config.setJdbcUrl(String.format(\"jdbc:postgresql://%s:%s/%s\", INSTANCE_HOST, DB_PORT, DB_NAME));\u00a0 \u00a0 config.setUsername(DB_USER); // e.g. \"root\", \"postgres\"\u00a0 \u00a0 config.setPassword(DB_PASS); // e.g. \"my-password\"\u00a0 \u00a0 // ... Specify additional connection properties here.\u00a0 \u00a0 // ...\u00a0 \u00a0 // Initialize the connection pool using the configuration object.\u00a0 \u00a0 return new HikariDataSource(config);\u00a0 }}\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/master/cloud-sql/postgres/knex/README.md) .\n [  cloud-sql/postgres/knex/connect-tcp.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/connect-tcp.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/cloud-sql/postgres/knex/connect-tcp.js) \n```\nconst Knex = require('knex');const fs = require('fs');// createTcpPool initializes a TCP connection pool for a Cloud SQL// instance of Postgres.const createTcpPool = async config => {\u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 // secure - consider a more secure solution such as\u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 // keep secrets safe.\u00a0 const dbConfig = {\u00a0 \u00a0 client: 'pg',\u00a0 \u00a0 connection: {\u00a0 \u00a0 \u00a0 host: process.env.INSTANCE_HOST, // e.g. '127.0.0.1'\u00a0 \u00a0 \u00a0 port: process.env.DB_PORT, // e.g. '5432'\u00a0 \u00a0 \u00a0 user: process.env.DB_USER, // e.g. 'my-user'\u00a0 \u00a0 \u00a0 password: process.env.DB_PASS, // e.g. 'my-user-password'\u00a0 \u00a0 \u00a0 database: process.env.DB_NAME, // e.g. 'my-database'\u00a0 \u00a0 },\u00a0 \u00a0 // ... Specify additional properties here.\u00a0 \u00a0 ...config,\u00a0 };\u00a0 // Establish a connection to the database.\u00a0 return Knex(dbConfig);};\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/tree/master/cloudsql/postgres/database-sql/README.md) .\n [  cloudsql/postgres/database-sql/connect_tcp.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/connect_tcp.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/cloudsql/postgres/database-sql/connect_tcp.go) \n```\npackage cloudsqlimport (\u00a0 \u00a0 \u00a0 \u00a0 \"database/sql\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"log\"\u00a0 \u00a0 \u00a0 \u00a0 \"os\"\u00a0 \u00a0 \u00a0 \u00a0 // Note: If connecting using the App Engine Flex Go runtime, use\u00a0 \u00a0 \u00a0 \u00a0 // \"github.com/jackc/pgx/stdlib\" instead, since v5 requires\u00a0 \u00a0 \u00a0 \u00a0 // Go modules which are not supported by App Engine Flex.\u00a0 \u00a0 \u00a0 \u00a0 _ \"github.com/jackc/pgx/v5/stdlib\")// connectTCPSocket initializes a TCP connection pool for a Cloud SQL// instance of Postgres.func connectTCPSocket() (*sql.DB, error) {\u00a0 \u00a0 \u00a0 \u00a0 mustGetenv := func(k string) string {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 v := os.Getenv(k)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if v == \"\" {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 log.Fatalf(\"Fatal Error in connect_tcp.go: %s environment variable not set.\", k)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return v\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 \u00a0 \u00a0 // secure - consider a more secure solution such as\u00a0 \u00a0 \u00a0 \u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 \u00a0 \u00a0 // keep secrets safe.\u00a0 \u00a0 \u00a0 \u00a0 var (\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbUser \u00a0 \u00a0= mustGetenv(\"DB_USER\") \u00a0 \u00a0 \u00a0 // e.g. 'my-db-user'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbPwd \u00a0 \u00a0 = mustGetenv(\"DB_PASS\") \u00a0 \u00a0 \u00a0 // e.g. 'my-db-password'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbTCPHost = mustGetenv(\"INSTANCE_HOST\") // e.g. '127.0.0.1' ('172.17.0.1' if deployed to GAE Flex)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbPort \u00a0 \u00a0= mustGetenv(\"DB_PORT\") \u00a0 \u00a0 \u00a0 // e.g. '5432'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbName \u00a0 \u00a0= mustGetenv(\"DB_NAME\") \u00a0 \u00a0 \u00a0 // e.g. 'my-database'\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 \u00a0 \u00a0 dbURI := fmt.Sprintf(\"host=%s user=%s password=%s port=%s database=%s\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dbTCPHost, dbUser, dbPwd, dbPort, dbName)\u00a0 \u00a0 \u00a0 \u00a0 // dbPool is the pool of database connections.\u00a0 \u00a0 \u00a0 \u00a0 dbPool, err := sql.Open(\"pgx\", dbURI)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return nil, fmt.Errorf(\"sql.Open: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // ...\u00a0 \u00a0 \u00a0 \u00a0 return dbPool, nil}\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/master/cloud-sql/mysql/README.md) .\n [  cloud-sql/postgres/ConnectTcp.cs ](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/ConnectTcp.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/HEAD/cloud-sql/postgres/ConnectTcp.cs) \n```\nusing Npgsql;using System;namespace CloudSql{\u00a0 \u00a0 public class PostgreSqlTcp\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 public static NpgsqlConnectionStringBuilder NewPostgreSqlTCPConnectionString()\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Equivalent connection string:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // \"Uid=<DB_USER>;Pwd=<DB_PASS>;Host=<INSTANCE_HOST>;Database=<DB_NAME>;\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var connectionString = new NpgsqlConnectionStringBuilder()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // secure - consider a more secure solution such as\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // keep secrets safe.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Host = Environment.GetEnvironmentVariable(\"INSTANCE_HOST\"), \u00a0 \u00a0 // e.g. '127.0.0.1'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Set Host to 'cloudsql' when deploying to App Engine Flexible environment\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Username = Environment.GetEnvironmentVariable(\"DB_USER\"), // e.g. 'my-db-user'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Password = Environment.GetEnvironmentVariable(\"DB_PASS\"), // e.g. 'my-db-password'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Database = Environment.GetEnvironmentVariable(\"DB_NAME\"), // e.g. 'my-database'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // The Cloud SQL proxy provides encryption between the proxy and instance.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 SslMode = SslMode.Disable,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 };\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 connectionString.Pooling = true;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Specify additional properties here.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return connectionString;\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }}\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/ruby-docs-samples/tree/master/cloud-sql/postgres/activerecord/README.md) .\n [  cloud-sql/postgres/activerecord/config/database_tcp.yml ](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) [View on GitHub](https://github.com/GoogleCloudPlatform/ruby-docs-samples/blob/HEAD/cloud-sql/postgres/activerecord/config/database_tcp.yml) \n```\ntcp: &tcp\u00a0 adapter: postgresql\u00a0 # Configure additional properties here.\u00a0 # Note: Saving credentials in environment variables is convenient, but not\u00a0 # secure - consider a more secure solution such as\u00a0 # Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 # keep secrets safe.\u00a0 username: <%= ENV[\"DB_USER\"] %> \u00a0# e.g. \"my-database-user\"\u00a0 password: <%= ENV[\"DB_PASS\"] %> # e.g. \"my-database-password\"\u00a0 database: <%= ENV.fetch(\"DB_NAME\") { \"vote_development\" } %>\u00a0 host: <%= ENV.fetch(\"INSTANCE_HOST\") { \"127.0.0.1\" }%> # '172.17.0.1' if deployed to GAE Flex\u00a0 port: <%= ENV.fetch(\"DB_PORT\") { 5432 }%>\n```To see this snippet in the context of a web application, view [the README on GitHub](https://github.com/GoogleCloudPlatform/php-docs-samples/tree/main/cloud_sql/postgres/pdo/README.md) .\n [  cloud_sql/postgres/pdo/src/DatabaseTcp.php ](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/DatabaseTcp.php) [View on GitHub](https://github.com/GoogleCloudPlatform/php-docs-samples/blob/HEAD/cloud_sql/postgres/pdo/src/DatabaseTcp.php) \n```\nnamespace Google\\Cloud\\Samples\\CloudSQL\\Postgres;use PDO;use PDOException;use RuntimeException;use TypeError;class DatabaseTcp{\u00a0 \u00a0 public static function initTcpDatabaseConnection(): PDO\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 try {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Note: Saving credentials in environment variables is convenient, but not\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // secure - consider a more secure solution such as\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Cloud Secret Manager (https://cloud.google.com/secret-manager) to help\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // keep secrets safe.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $username = getenv('DB_USER'); // e.g. 'your_db_user'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $password = getenv('DB_PASS'); // e.g. 'your_db_password'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $dbName = getenv('DB_NAME'); // e.g. 'your_db_name'\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $instanceHost = getenv('INSTANCE_HOST'); // e.g. '127.0.0.1' ('172.17.0.1' for GAE Flex)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Connect using TCP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $dsn = sprintf('pgsql:dbname=%s;host=%s', $dbName, $instanceHost);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Connect to the database\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $conn = new PDO(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $dsn,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $username,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $password,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 # ...\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 );\u00a0 \u00a0 \u00a0 \u00a0 } catch (TypeError $e) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 throw new RuntimeException(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sprintf(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'Invalid or missing configuration! Make sure you have set ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 '$username, $password, $dbName, and $instanceHost (for TCP mode). ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'The PHP error was %s',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getMessage()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getCode(),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 );\u00a0 \u00a0 \u00a0 \u00a0 } catch (PDOException $e) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 throw new RuntimeException(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 sprintf(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'Could not connect to the Cloud SQL Database. Check that ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'your username and password are correct, that the Cloud SQL ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'proxy is running, and that the database exists and is ready ' .\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'for use. For more assistance, refer to %s. The PDO error was %s',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'https://cloud.google.com/sql/docs/postgres/connect-external-app',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getMessage()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e->getCode(),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 $e\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 );\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return $conn;\u00a0 \u00a0 }}\n```\nYou can then create a Cloud Build step to run your code directly.\n [  sql-private-pool/cloudbuild.yaml ](https://github.com/GoogleCloudPlatform/cloud-build-samples/blob/HEAD/sql-private-pool/cloudbuild.yaml) [View on GitHub](https://github.com/GoogleCloudPlatform/cloud-build-samples/blob/HEAD/sql-private-pool/cloudbuild.yaml) \n```\nsteps:\u00a0 - id: \"docker-build\"\u00a0 \u00a0 name: \"gcr.io/cloud-builders/docker\"\u00a0 \u00a0 args: [\"build\", \"-t\", \"${_IMAGE_NAME}\", \"sql-private-pool/.\"]\u00a0 - id: \"docker-push\"\u00a0 \u00a0 name: \"gcr.io/cloud-builders/docker\"\u00a0 \u00a0 args: [\"push\", \"${_IMAGE_NAME}\"]\u00a0 - id: \"migration\"\u00a0 \u00a0 name: \"${_IMAGE_NAME}\"\u00a0 \u00a0 dir: sql-private-pool\u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 - \"DATABASE_NAME=mydatabase\"\u00a0 \u00a0 \u00a0 - \"DATABASE_USER=myuser\"\u00a0 \u00a0 \u00a0 - \"DATABASE_HOST=${_DATABASE_HOST}\"\u00a0 \u00a0 \u00a0 - \"DATABASE_TYPE=${_DATABASE_TYPE}\"\u00a0 \u00a0 secretEnv:\u00a0 \u00a0 \u00a0 - DATABASE_PASS\u00a0 \u00a0 entrypoint: python \u00a0 # for example\u00a0 \u00a0 args: [\"migrate.py\"] # for exampleoptions:\u00a0 pool:\u00a0 \u00a0 name: projects/$PROJECT_ID/locations/us-central1/workerPools/private-pool\u00a0 dynamic_substitutions: truesubstitutions:\u00a0 _DATABASE_PASSWORD_KEY: database_password\u00a0 _DATABASE_TYPE: postgres\u00a0 _IMAGE_NAME: gcr.io/${PROJECT_ID}/sample-private-poolavailableSecrets:\u00a0 secretManager:\u00a0 \u00a0 - versionName: projects/$PROJECT_ID/secrets/${_DATABASE_PASSWORD_KEY}/versions/latest\u00a0 \u00a0 \u00a0 env: DATABASE_PASS\n```\nThe Cloud Build code sample above shows how you might run a hypothetical **migrate** script after deploying the sample app above to update its Cloud SQL database using Cloud Build. To run this Cloud Build code sample the setup steps required are:- Create a folder name`sql-private-pool`\n- Create a`Dockerfile`file in the`sql-private-pool`folder with the following single line of code for its file contents:```\nFROM gcr.io/gcp-runtimes/ubuntu_20_0_4\n```\n- Create a`cloudbuild.yaml`file in the`sql-private-pool`folder.\n- Update the`cloudbuild.yaml`file:- Copy the sample Cloud Build code above and paste it into the`cloudbuild.yaml`file.\n- Replace the following placeholder values with the values used in your project:- `mydatabase`\n- `myuser`\n- `databasehost`, in the form`host:port`.\n- Create a secret named`database_password`in [Secret Manager](https://console.cloud.google.com/security/secret-manager/) .- In order for the Cloud Build service account to access this secret, you will have to grant it the [Secret Manager Secret Accessor](/iam/docs/understanding-roles#secret-manager-roles) role in [IAM](https://console.cloud.google.com/iam-admin/iam) . See [Using secrets from Secret Manager](/build/docs/securing-builds/use-secrets) for more information.\n- Create a **migrate.py** script file in the`sql-proxy`folder.- The script can reference the following environment variables and the secret created in the`cloudbuild.yaml`file using the following examples:- `os.getenv('DATABASE_NAME')`\n- `os.getenv('DATABASE_USER')`\n- `os.getenv('DATABASE_PASS')`\n- `os.getenv('DATABASE_HOST')`\n- To reference the same variables from a Bash script (for example:`migrate.sh`) use the following examples:- `$DATABASE_NAME`\n- `$DATABASE_USER`\n- `$DATABASE_PASS`\n- `$DATABASE_HOST`\n- Run the following [gcloud builds submit](/sdk/gcloud/reference/builds/submit) command to build a container with the Cloud SQL Auth Proxy, start the Cloud SQL Auth Proxy, and run the`migrate.py`script:```\ngcloud builds submit --config cloudbuild.yaml\n```## Best practices and other information\nYou can use the [Cloud SQL Auth Proxy](/sql/docs/postgres/sql-proxy) when testing your application locally. See the [quickstart for using the Cloud SQL Auth Proxy](/sql/docs/mysql/connect-instance-auth-proxy) for detailed instructions.\nYou can also test using the [Cloud SQL Proxy via a docker container](/sql/docs/postgres/connect-docker) .\n### Database schema migrations\nBy configuring Cloud Build to connect to Cloud SQL, you can run database schema migration tasks in Cloud Build using the same code you would deploy to any other serverless platform.\n### Using Secret Manager\nYou can use [Secret Manager](/build/docs/securing-builds/use-secrets) to include sensitive information in your builds.", "guide": "Cloud SQL"}