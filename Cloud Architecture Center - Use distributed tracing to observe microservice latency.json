{"title": "Cloud Architecture Center - Use distributed tracing to observe microservice latency", "url": "https://cloud.google.com/architecture/reference-patterns/overview", "abstract": "# Cloud Architecture Center - Use distributed tracing to observe microservice latency\nLast reviewed 2023-08-11 UTC\nWhen an application is rewritten to use microservices, the number of components and endpoints that are involved in a single user transaction increases. Therefore, observability is critical in order to operate user services reliably. This reference architecture shows how to capture trace information on microservice applications using OpenTelemetry and Cloud Trace.\nThis document is intended for developers, SREs, and DevOps engineers who want to understand the fundamentals of distributed tracing and who want to apply those principles to their services to improve service observability.\n**Note:** The [State of DevOps](/devops) reports identifies capabilities that drive software delivery performance. This architecture helps you with the [Monitoring and observability](https://dora.dev/devops-capabilities/technical/monitoring-and-observability/) and [Code maintainability](https://dora.dev/devops-capabilities/technical/code-maintainability/) capabilities.\n", "content": "## Architecture\nThe following diagram shows the architecture of an application that implements this architecture.\nAs illustrated in the preceding diagram, this architecture includes two GKE clusters. You deploy an application to each of the clusters. User traffic is sent to the frontend application on the frontend cluster. The frontend pod on the frontend cluster communicates to the backend pod on the backend cluster. The backend pod calls an external API endpoint.\nObservability data is exported to Cloud Trace, which tracks how requests propagate through the applications.\n## Design considerations\nFor services that run on [Kubernetes](https://kubernetes.io/) , you can use a service mesh like [Istio](https://istio.io/) to enable distributed tracing of service-to-service traffic without the need for dedicated instrumentation. However, you might have any of the following requirements:\n- You want to have more control over the traces than what Istio provides.\n- You might need to capture application internals in the trace information.\n- You might need to trace code that's not running on Kubernetes.\nFor these use cases, you can use [OpenTelemetry](https://opentelemetry.io/) , which is an open source library that can add instrumentation to distributed microservice applications to collect traces, metrics, and logs across a wide variety of languages, platforms, and environments.\n### Understanding traces, spans, and context\nThe concept of distributed tracing is described in the [Dapper research paper](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf) that's published by Google. As described in the paper, the following diagram shows five spans in a trace.\nA is the total of information that describes how a distributed system responds to a user request. Traces are composed of , where each span represents a specific request and response pair that's involved in serving the user request. The describes the latency as observed by the end user. Each of the describes how a particular service in the distributed system was called and responded to, with latency information captured for each.\nThe diagram shows a single frontend request that makes two backend requests. The second backend call requires two helper calls to complete. Each call is labeled with its span ID and the ID of the parent span.\nA challenge with tracing in distributed systems is that information about the original frontend request isn't automatically or inherently carried forward when subsequent requests are made to various backend services.\nWith some tools (for example, in the Go language), you can make requests with \u2014the cluster IP address and credentials. OpenTelemetry extends the concept of context to include , meaning that additional information is loaded in the HTTP header. Information about the parent span can then be included with each subsequent request. You can append child spans to compose the overall trace, so you can see how the user request traversed the system and was eventually served back to the user.\n## Deployment\nTo deploy this architecture, see [Deploy distributed tracing to observe microservice latency](/architecture/use-distributed-tracing-to-observe-microservice-latency-with-opentelemetry-and-cloud-trace/deployment) .\n## What's next\n- Learn about [OpenTelemetry](https://opentelemetry.io/) .\n- Learn more about the DevOps capabilities that are related to this architecture:- [Monitoring and observability](https://dora.dev/devops-capabilities/technical/monitoring-and-observability/) \n- [Code maintainability](https://dora.dev/devops-capabilities/technical/code-maintainability/) \n- Take the [DevOps quick check](https://www.devops-research.com/quickcheck.html) to understand where you stand in comparison with the rest of the industry.\n- For more reference architectures, diagrams, and best practices, explore the [Cloud Architecture Center](/architecture) .", "guide": "Cloud Architecture Center"}