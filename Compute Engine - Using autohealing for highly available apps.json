{"title": "Compute Engine - Using autohealing for highly available apps", "url": "https://cloud.google.com/compute/docs/instances", "abstract": "# Compute Engine - Using autohealing for highly available apps\nThis interactive tutorial shows how to use [autohealing](/compute/docs/instance-groups#autohealing) to build highly available apps on Compute Engine.\nHighly available apps are designed to serve clients with minimal latency and downtime. Availability is compromised when an app crashes or freezes. Clients of a compromised app can experience high latency or downtime.\nAutohealing lets you automatically restart apps that are compromised. It promptly detects failed instances and recreates them automatically, so clients can be served again. With autohealing, you no longer need to manually bring an app back to service after a failure.", "content": "## Objectives\n- Configure a health check and an autohealing policy.\n- Set up a demo web service on a managed instance group.\n- Simulate health check failures and witness the autohealing recovery process.\n## Costs\nThis tutorial uses billable components of Google Cloud including:\n- Compute Engine\n## Before you begin\nIf you prefer to work from the command line, install the Google Cloud CLI.- [Install](/sdk/docs/install) the Google Cloud CLI.\n- To [initialize](/sdk/docs/initializing) the gcloud CLI, run the following command:```\ngcloud init\n``` **Note:** You can run the gcloud CLI in  the Google Cloud console without installing the Google Cloud CLI. To run the  gcloud CLI in the Google Cloud console, [use  Cloud Shell](https://console.cloud.google.com/?cloudshell=true) .\n## App architectureThe app includes the following Compute Engine components:- [Health check](/load-balancing/docs/health-check-concepts) : an HTTP health check policy used by the autohealer to detect failed VM instances.\n- [Firewall rules](/vpc/docs/firewalls) : Google Cloud firewall rules let you allow or deny traffic to your instances.\n- [Managed instance group](/compute/docs/instance-groups#managed_instance_groups) : A group of instances running the same demo web service.\n- [Instance template](/compute/docs/instance-templates) : A template used to create each instance in the instance group.### How the health check probes the demo webserviceA health check sends probe requests to an instance using a specified protocol, such as HTTP(S), SSL, or TCP. For more information, see [how health checks work](/load-balancing/docs/health-check-concepts#method) and [health check categories, protocols, and ports](/load-balancing/docs/health-check-concepts#categories_protocols_ports) .\nThe health check in this tutorial is an HTTP health check that probes the HTTP path `/health` on port 80. For an HTTP health check, the probe request passes only if the path returns an `HTTP 200 (OK)` response. For this tutorial, the demo web server defines the path `/health` to return an `HTTP 200 (OK)` response when healthy or an `HTTP 500 (Internal Server Error)` response when unhealthy. For more information, see [success criteria for HTTP, HTTPS, and HTTP/2](/load-balancing/docs/health-check-concepts#criteria-protocol-http) .## Create the health checkTo set up autohealing, create a custom health check and configure the network firewall to allow health check probes. You can use either a [regional](/compute/docs/reference/rest/v1/regionHealthChecks) or a [global](/compute/docs/reference/rest/v1/healthChecks) health check. Regional health checks reduce cross-region dependencies and help to achieve data residency. Global health checks are convenient if you want to use the same health check for MIGs in multiple regions. In this tutorial, you create a global health check.\n **Pro Tip:** Use separate health checks for load balancing and for [autohealing](/compute/docs/instance-groups#autohealing) . Health checks for load balancing detect unresponsive instances and direct traffic away from them. Health checks for autohealing detect and recreate failed instances, so they should be less aggressive than load balancing health checks. Using the same health check for these services would remove the distinction between unresponsive instances and failed instances, causing unnecessary latency and unavailability for your users. For more information, see [What makes a good autohealing health check](#what_makes_a_good_autohealing_health_check) .\n- Create a health check.- In the Google Cloud console, go to the **Health checks** page. [Go to Health checks](https://console.cloud.google.com/compute/healthChecks) \n- Click **Create health check** .\n- In the **Name** field, enter `autohealer-check` .\n- Set the **Scope** to `Global` . For autohealing, you can use either a [regional](/compute/docs/reference/rest/v1/regionHealthChecks) or a [global](/compute/docs/reference/rest/v1/healthChecks) health check.\n- For **Protocol** select `HTTP` .\n- Set **Request path** to `/health` . This indicates what HTTP path the health check uses. For this tutorial, the demo web server defines the path `/health` to return either an `HTTP 200 (OK)` response when healthy or an `HTTP 500 (Internal Server Error)` response when unhealthy.\n- Set the **Health criteria** :- Set **Check interval** to`10`. This defines the amount of time from the start of one probe to the start of the next one.\n- Set **Timeout** to`5`. This defines the amount of time that Google Cloud waits for a response to a probe. This value must be less than or equal to the check interval.\n- Set **Healthy threshold** to`2`. This defines the number of sequential probes that must succeed for the instance to be considered healthy.\n- Set **Unhealthy threshold** to`3`. This defines the number of sequential probes that must fail for the instance to be considered unhealthy.\n- Click **Create** at the bottom.\n- Create a firewall rule to allow health check probes to make HTTP requests.- In the Google Cloud console, go to the **Create firewall rule** page. [Go to Create firewall rule](https://console.cloud.google.com/networking/firewalls/add) \n- For **Name** , enter `default-allow-http-health-check` .\n- For **Network** , select `default` .\n- For **Targets** , select `All instances in the network` .\n- For **Source filter** , select `IP ranges` .\n- For **Source IP ranges** , enter `130.211.0.0/22` and `35.191.0.0/16` .\n- In **Protocols and ports** , select **tcp** and enter `80` .\n- Click **Create** .\n **Note:** Health check probes come from addresses in the ranges `130.211.0.0/22` and `35.191.0.0/16` . For this tutorial, your health check uses the `HTTP` protocol, so make sure the firewall rule allows connections to port 80. For more information, see [setting up health checking and autohealing for managed instance groups](/compute/docs/instance-groups/autohealing-instances-in-migs) .\n- Create a global health check using the [health-checks create http command](/sdk/gcloud/reference/compute/health-checks/create/http) .```\ngcloud compute health-checks create http autohealer-check \\\n --global \\\n --check-interval 10 \\\n --timeout 5 \\\n --healthy-threshold 2 \\\n --unhealthy-threshold 3 \\\n --request-path \"/health\"\n```- `check-interval`defines the amount of time from the start of one probe to the start of the next one.\n- `timeout`defines the amount of time that Google Cloud waits for a response to a probe. This value must be less than or equal to the check interval.\n- `healthy-threshold`defines the number of sequential probes that must succeed for the instance to be considered healthy.\n- `unhealthy-threshold`defines the number of sequential probes that must fail for the instance to be considered unhealthy.\n- `request-path`indicates what HTTP path the health check uses. For this tutorial, the demo web server defines the path`/health`to return either an`HTTP 200 (OK)`response when healthy or an`HTTP 500 (Internal Server Error)`response when unhealthy.\n- Create a firewall rule to allow health check probes to make HTTP requests.```\ngcloud compute firewall-rules create default-allow-http-health-check \\\n --network default \\\n --allow tcp:80 \\\n --source-ranges 130.211.0.0/22,35.191.0.0/16\n``` **Note:** Health check probes come from addresses in the ranges `130.211.0.0/22` and `35.191.0.0/16` . For this tutorial, your health check uses the `HTTP` protocol, so make sure the firewall rule allows connections to port 80. For more information, see [setting up health checking and autohealing for managed instance groups](/compute/docs/instance-groups/autohealing-instances-in-migs) .### What makes a good autohealing health checkHealth checks used for autohealing should be conservative so they don't preemptively delete and recreate your instances. When an autohealer health check is too aggressive, the autohealer might mistake busy instances for failed instances and unnecessarily restart them, reducing availability.- `unhealthy-threshold`. Should be more than`1`. Ideally, set this value to`3`or more. This protects against rare failures like a network packet loss.\n- `healthy-threshold`. A value of`2`is sufficient for most apps.\n- `timeout`. Set this time value to a generous amount (five times or more than the expected response time). This protects against unexpected delays like busy instances or a slow network connection.\n- `check-interval`. This value should be between 1 second and two times the timeout (not too long nor too short). When a value is too long, a failed instance is not caught soon enough. When a value is too short, the instances and the network can become measurably busy, given the high number of health check probes being sent every second.\n## Set up the web serviceThis tutorial uses a web app that is stored on GitHub. If you would like learn more about how the app was implemented, see the [GoogleCloudPlatform/python-docs-samples](https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/compute/managed-instances/demo) GitHub repository.\nTo set up the demo web service, create an instance template that launches the demo web server on startup. Then, use this instance template to deploy a managed instance group and enable autohealing.\n- Create an instance template. Include a startup script that starts up the demo web server.- In the Google Cloud console, go to the **Instance templates** page. [Go to Instance templates](https://console.cloud.google.com/compute/instanceTemplates) \n- Click **Create instance template** .\n- Set the **Name** to `webserver-template` .\n- For **Machine configuration** select `micro` (e2-micro).\n- Under **Firewall** , select the **Allow HTTP traffic** checkbox.\n- Click **Management, security, disks, networking, sole tenancy** to reveal advanced settings. Several tabs appear.\n- On the **Management** tab, find **Automation** and enter the following **Startup script** :```\nsudo apt update && sudo apt -y install git gunicorn3 python3-pip\ngit clone https://github.com/GoogleCloudPlatform/python-docs-samples.git\ncd python-docs-samples/compute/managed-instances/demo\nsudo pip3 install -r requirements.txt\nsudo gunicorn3 --bind 0.0.0.0:80 app:app --daemon\n```\n- Click **Create** .\n- Deploy the web server as a managed instance group.- In the Google Cloud console, go to the **Instance groups** page. [Go to Instance groups](https://console.cloud.google.com/compute/instanceGroups) \n- Click **Create instance group** .\n- Set the **Name** to `webserver-group` .\n- For **Region** , select `europe-west1` .\n- For **Zone** , select `europe-west1-b` .\n- For **Instance template** , select `webserver-template` .\n- For **Autoscaling** , select **Don't autoscale** .\n- Set **Number of instances** to `3` .\n- For **Health check** , select `autohealer-check` .\n- Set **Initial delay** to `90` .\n- Click **Create** .\n **Note:** The is the number of seconds that a new VM takes to initialize and run its startup script. During a VM's initial delay period, the MIG ignores unsuccessful health checks because the VM might be in the startup process. This prevents the MIG from prematurely recreating a VM. If the health check receives a healthy response during the initial delay, it indicates that the startup process is complete and the VM is ready. The value of initial delay must be between 0 and 3600 seconds. In the console, the default value is 300. For the sample web server in this tutorial, 90 seconds should be enough time.\n- Create a firewall rule that allows HTTP requests to the web servers.- In the Google Cloud console, go to the **Create firewall rule** page. [Go to Create firewall rule](https://console.cloud.google.com/networking/firewalls/add) \n- For **Name** , enter `default-allow-http` .\n- For **Network** , select `default` .\n- For **Targets** , select `Specified target tags` .\n- For **Target Tags** , enter `http-server` .\n- For **Source filter** , select `IP ranges` .\n- For **Source IP ranges** , enter `0.0.0.0/0` .\n- In **Protocols and ports** , select **tcp** and enter `80` .\n- Click **Create** .- Create an instance template. Include a startup script that starts the demo web server.```\ngcloud compute instance-templates create webserver-template \\\n --machine-type e2-micro \\\n --tags http-server \\\n --metadata startup-script='\n sudo apt update && sudo apt -y install git gunicorn3 python3-pip\n git clone https://github.com/GoogleCloudPlatform/python-docs-samples.git\n cd python-docs-samples/compute/managed-instances/demo\n sudo pip3 install -r requirements.txt\n sudo gunicorn3 --bind 0.0.0.0:80 app:app --daemon'\n```\n- Create an instance group.```\ngcloud compute instance-groups managed create webserver-group \\\n --zone europe-west1-b \\\n --template webserver-template \\\n --size 3 \\\n --health-check autohealer-check \\\n --initial-delay 90\n``` **Note:** The is the number of seconds that a new VM takes to initialize and run its startup script. During a VM's initial delay period, the MIG ignores unsuccessful health checks because the VM might be in the startup process. This prevents the MIG from prematurely recreating a VM. If the health check receives a healthy response during the initial delay, it indicates that the startup process is complete and the VM is ready. The initial delay timer starts when the MIG changes the VM's [currentAction](/compute/docs/instance-groups/autohealing-instances-in-migs#current_actions_on_instances) field to `VERIFYING` . The value of initial delay must be between 0 and 3600 seconds. The default value is 0. For the sample web server in this tutorial, 90 seconds should be enough time.\n- Create a firewall rule that allows HTTP requests to the web servers.```\ngcloud compute firewall-rules create default-allow-http \\\n --network default \\\n --allow tcp:80 \\\n --target-tags http-server\n```\n## Simulate health check failuresTo simulate health check failures, the demo web server provides ways for you to force a health check failure.\n- Navigate to a web server instance.- In the Google Cloud console, go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Under the **External IP** column, click the IP address for any `webserver-group` instance. A new tab opens in your web browser. If the request times out or the web page is not available, wait a minute to let the server finish setting up and try again.\nThe demo web server displays a page similar to the following:\n- On the demo web page, click **Make unhealthy** .This causes the web server to fail the health check. Specifically, the web server makes the `/health` path return an `HTTP 500 (Internal Server Error)` . You can verify this yourself by quickly clicking the **Check health** button (this stops working after the autohealer has started rebooting the instance).\n- Wait for the autohealer to take action.- In the Google Cloud console, go to the **VM instances** page. [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Wait for the status of the web server instance to change. The green checkmark next to the instance name should change to a grey square, indicating that the autohealer has started rebooting the unhealthy instance.\n- Click **Refresh** at the top of the page periodically to get the most recent status.\n- The autohealing process is finished when the grey square changes back to a green checkmark, indicating the instance is healthy again.- Monitor the status of the instance group. (When you have finished, stop by pressing `Ctrl+C` .)```\nwhile : ; do \\\n gcloud compute instance-groups managed list-instances webserver-group \\\n --zone europe-west1-b \\\n ; done\n``````\nNAME     ZONE   STATUS ACTION INSTANCE_TEMPLATE VERSION_NAME LAST_ERROR\nwebserver-group-d5tz europe-west1-b RUNNING NONE webserver-template\nwebserver-group-q6t9 europe-west1-b RUNNING NONE webserver-template\nwebserver-group-tbpj europe-west1-b RUNNING NONE webserver-template\n```If any instances show a status that is not `RUNNING` , such as `STAGING` , wait a minute to let the instance finish setting up and try again.\n- Open a new Cloud Shell session with the Google Cloud CLI installed. **Note:** If you're using Cloud Shell, you can [open multiple sessions](/shell/docs/starting-cloud-shell#opening_multiple_sessions) .\n- Get the address of a web server instance.```\ngcloud compute instances list --filter webserver-group\n```Under the `EXTERNAL_IP` column, copy the IP address of any web server instance and save it as a local bash variable.```\nexport IP_ADDRESS=EXTERNAL_IP_ADDRESS\n```\n- Verify the web server has finished setting up. The server returns an `HTTP 200 OK` response.```\ncurl --head $IP_ADDRESS/health\n``````\nHTTP/1.1 200 OK\nServer: gunicorn/19.6.0\n...\n```If you get a `Connection refused` error, wait a minute to let the server finish setting up and try again.\n- Make the web server unhealthy.```\ncurl $IP_ADDRESS/makeUnhealthy > /dev/null\n```This causes the web server to fail the health check. Specifically, the web server makes the `/health` path return an `HTTP 500 INTERNAL SERVER ERROR` . You can verify this yourself by quickly making a request to `/health` (this stops working after the autohealer has started rebooting the instance).```\ncurl --head $IP_ADDRESS/health\n``````\nHTTP/1.1 500 INTERNAL SERVER ERROR\nServer: gunicorn/19.6.0\n...\n```\n- Return to your first shell session to monitor the instance group and wait for the autohealer to take action.- When the autohealing process has started, the `STATUS` and `ACTION` columns update, indicating that the autohealer has started rebooting the unhealthy instance.```\nNAME     ZONE   STATUS ACTION  INSTANCE_TEMPLATE VERSION_NAME LAST_ERROR\nwebserver-group-d5tz europe-west1-b RUNNING NONE  webserver-template\nwebserver-group-q6t9 europe-west1-b RUNNING NONE  webserver-template\nwebserver-group-tbpj europe-west1-b STOPPING RECREATING webserver-template\n```\n- The autohealing process has finished when the instance again reports a `STATUS` of `RUNNING` and an `ACTION` of `NONE` , indicating the instance is successfully restarted.```\nNAME     ZONE   STATUS ACTION INSTANCE_TEMPLATE VERSION_NAME LAST_ERROR\nwebserver-group-d5tz europe-west1-b RUNNING NONE webserver-template\nwebserver-group-q6t9 europe-west1-b RUNNING NONE webserver-template\nwebserver-group-tbpj europe-west1-b RUNNING NONE webserver-template\n```\n- When you have finished monitoring the instance group, stop by pressing `Ctrl+C` .\n **Note:** For more information about possible instance statuses and actions, see [Instance life cycle](/compute/docs/instances/instance-life-cycle) and [Current actions on instances](/compute/docs/instance-groups/updating-managed-instance-groups#current_actions_on_instances) .\nFeel free to repeat this exercise. Here are some ideas:- What happens if you make all instances unhealthy at one time? For more information about autohealing behavior during concurrent failures, see [autohealing behavior](/compute/docs/instance-groups/autohealing-instances-in-migs#autohealing_behavior) .\n- Can you update the health check configuration to heal instances as fast as possible? (In practice, you should set the health check parameters to use conservative values as explained in this tutorial. Otherwise, you may risk instances being mistakenly deleted and restarted when there is no real problem.)\n- The instance group has an `initial delay` configuration setting. Can you determine the minimum delay needed for this demo web server? (In practice, you should set the delay to somewhat longer (10%\u201320%) than it takes for an instance to boot and start serving app requests. Otherwise, you risk the instance getting stuck in an autohealing boot loop.)\n## View autohealer history (optional)To view a history of autohealer operations use the following `gcloud` command:\n```\ngcloud compute operations list --filter='operationType~compute.instances.repair.*'\n```\nFor more information, see [viewing historical autohealing operations](/compute/docs/instance-groups/autohealing-instances-in-migs#viewing_historical_autohealing_operations) ## Clean up\nAfter you finish the tutorial, you can clean up the resources that you created so that they stop using quota and incurring charges. The following sections describe how to delete or turn off these resources.If you created a separate project for this tutorial, delete the entire project. Otherwise, if the project has resources that you want to keep, only delete the specific resources created in this tutorial.\n### Deleting the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Deleting specific resourcesIf you can't delete the project used for this tutorial, delete the tutorial resources individually.- In the Google Cloud console, go to the **Instance groups** page. [Go to Instance groups](https://console.cloud.google.com/compute/instanceGroups/list) \n- Select the checkbox for   your`webserver-group`instance group.\n- To delete the instance group, clickdelete **Delete** .```\ngcloud compute instance-groups managed delete webserver-group --zone europe-west1-b -q\n``` **Note:** You must delete the instance group before deleting the instance template. You can't delete an instance template if a managed instance group uses it.- In the Google Cloud console, go to the **Instance templates** page. [Go to Instance templates](https://console.cloud.google.com/compute/instanceTemplates) \n- Click the checkbox next to the instance template.\n- Click delete **Delete** at the top of the page. In the new window, click **Delete** to confirm the deletion.\n```\ngcloud compute instance-templates delete webserver-template -q\n``` **Note:** You must delete the instance group before deleting the health check. You can't delete a health check if other resources use it.- In the Google Cloud console, go to the **Health checks** page. [Go to Health checks](https://console.cloud.google.com/compute/healthChecks) \n- Click the checkbox next to the health check.\n- Click delete **Delete** at the top of the page. In the new window, click **Delete** to confirm the deletion.\n```\ngcloud compute health-checks delete autohealer-check -q\n```\n- In the Google Cloud console, go to the **Firewall rules** page. [Go to Firewall rules](https://console.cloud.google.com/networking/firewalls) \n- Click the checkboxes next to the firewall rules named `default-allow-http` and `default-allow-http-health-check` .\n- Click delete **Delete** at the top of the page. In the new window, click **Delete** to confirm the deletion.\n```\ngcloud compute firewall-rules delete default-allow-http default-allow-http-health-check -q\n```## What's next\n- Try another tutorial:- [Using load balancing for highly available applications](/compute/docs/tutorials/high-availability-load-balancing) .\n- [Using autoscaling for highly scalable applications](/compute/docs/tutorials/high-scalability-autoscaling) .\n- Learn more about [managed instance groups](/compute/docs/instance-groups) .\n- Learn more about [designing robust systems](/compute/docs/tutorials/robustsystems) .\n- Learn more about [building scalable and resilient web apps on Google Cloud](/solutions/scalable-and-resilient-apps) .", "guide": "Compute Engine"}