{"title": "Google Cloud Observability - Overview", "url": "https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/sli-metrics/overview", "abstract": "# Google Cloud Observability - Overview\nThis section reviews the concept of service-level indicators (SLIs), defines what makes for a good or useful SLI, and provides examples of SLI implementations for selected services. This page is intended for people who want examples that implement service-specific SLIs.\n", "content": "## Introduction to SLIs\nThe reliability of a service is an abstract notion; what means depends on the service and the needs of its users. A (SLI) is a measure of that reliability to be used for both communicating about the reliability of the service and to manage the service.\nSLIs are measured over a time window. The size of the window typically depends upon the decision the information is being used to make. For example, you might measure a single SLI in the following ways:\n- Over the most recent hour, for creating alerting policies.\n- Over weeks, for making tactical decisions.\n- Over months, for making strategic decisions.\nWe recommend 28 days as a starting point for measuring your SLI; this value provides a good balance between the strategic and tactical use cases.\nFor more information, see the following sections of the [Site Reliability Engineering Workbook](https://landing.google.com/sre/workbook/toc) :\n- [Implementing SLOs](https://landing.google.com/sre/workbook/chapters/implementing-slos) \n- [Alerting on SLOs](https://landing.google.com/sre/workbook/chapters/alerting-on-slos) ## Properties of a good SLI\nWe consider \"good\" SLIs to be those measures that meet the following criteria:\n- **SLIs are good proxy measures for user happiness.** A good SLI correlates strongly with user happiness. You use the SLI as the basis for a (SLO), a threshold set on the SLI. You set the SLO so that, when the SLI is within a defined range, most of your users are happy. For this relationship to hold, the SLI must be a good proxy measure for user happiness.If the SLI is a good proxy for user happiness, then when there is an event that affects user happiness, the SLI changes in some direction. Likewise, when there are no events that affect user happiness, the SLI doesn't change.\n- **SLIs scale monotonically and linearly with user happiness.** A good SLI scales monotonically, and linearly, with user happiness. If the SLI improves, then user happiness improves. Similarly, if the SLI decreases, then user happiness decreases. The amount of improvement in the value of a good SLI corresponds to the amount of improvement in user happiness.\n- **SLIs produce measurements that range from 0% to 100%.** A good SLI produces a performance measurement that ranges from 0% to 100%: this range is intuitive and easy to work with. For example, SLI performance of 100% means that everything is working, and SLI performance of 0% means that nothing is working.Having a SLI that ranges from 0% to 100% makes setting a SLO on the SLI easy and clear: assign a percentage target such as 99.9%, and the SLI performance must be at or higher than that target for the service to be meeting its SLO.## Promises\nOne way of implementing an SLI that has these properties is to think of the SLI in terms of promises made to your users. By counting the promises that you made and upheld over a time window, you can derive a number that ranges from 0% to 100%. Such SLIs also translate well into error budgets: for a given SLO, your error budget is the number of promises you can fail to uphold over a time window while still meeting your SLO.\nExamples of promises include:\n- To return a response with an HTTP`200`status code to a customer's request.\n- To respond to a gRPC request in under 100 ms.\n- To complete the \"Create Virtual Machine\" workflow successfully.\n- To serve data that has been refreshed within the past 10 minutes.\n- To start running the scheduled batch job within one minute of its starting time.## SLI specifications and implementations\nAn SLI is you want to measure. The specification doesn't include the exact technical details of you are going to measure it. For example, the following is a specification of an SLI for page-loading time:\n- The percentage of home page requests that load in under 100 ms.\nThere can be many ways to measure an SLI, each with trade-offs and benefits. The ways of measuring the SLI are the SLI **Implementations** . For example, you might implement the page-loading specification as one of the following:\n- The latency field of the application server's request log.\n- Metrics exported by the application server.\n- Metrics exported by a load balancer in front of the application servers.\n- A black-box monitoring service that sends artificial requests to the system and times how long it takes to receive valid responses.\n- Application-specific code executed in the customer's browser that records timing information and sends it back to a collection service.\nEach of these choices involves trade-offs between the following characteristics:\n- Fidelity: how accurately it captures user experience.\n- Coverage: what proportion of user interactions are measured.\n- Cost: the amount of both money and engineering time required to build and maintain the solution.\nFidelity to user experience usually improves when the SLI is measured closer to the user. For example, the implementation that uses code in the user's browser results in a more accurate measurement of latency than the latency perceived by the user or by other measurement choices.\nThe tradeoff is that the browser-based measurement also includes any latency introduced by the user's connection to your service. For example, when a service is used over the public internet, this latency might vary significantly with geographic location or network conditions.\nThe result is that the browser-based signal is a good proxy for user happiness. However, this signal might not provide actionable information you can use to improve the reliability of your service.\nFor information about combining multiple measurements to balance this tradeoff, see this [post from The Telegraph](https://medium.com/the-telegraph-engineering/putting-customers-first-with-slis-and-slos-part-2-6b5c2452aecd) .\n## Bucketing\nYou might need multiple SLIs for a service when your service performs different kinds of work for different users, or when it performs a particular task with different possible outcomes.\n### Different tasks\nServices that perform multiple types of work, for different categories of users, and in which each type of work influences user happiness differently benefit from multiple SLIs.\nFor example, if your service handles both read and write requests, users performing those tasks might have different requirements:\n- Read requests have to be fast.\n- Write requests have to be successful.\nTo capture these different requirements, your SLI must be able to distinguish between these two cases. Typically, the SLI metric has a label that you can use to classify values into one of several buckets.\n### One task with different outcomes\nServices that perform a single type of work but where user expectations differ based on the response benefit from multiple SLIs.\nFor example, if your service offers only read access to data, users might have different tolerance for latency depending on the outcome of the request:\n- Users might be tolerant of errors that are returned quickly, because users can then immediately retry the request.\n- Users might be less tolerant of successful requests that take a long time.\n- Users are least tolerant of the worst-case scenario: requests that take a long time to return an error.\nIn this case, your latency SLI needs to be able to distinguish between successful and unsuccessful requests.\n## What's next\nFor information about implementing SLIs for Google Cloud services using Google Cloud metrics, see the following:\n- [Using Cloud Load Balancing metrics](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/lb-metrics) \n- [Using Google Cloud platform and service metrics](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/platform-svc-metrics) - [Data storage and retrieval services](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/data-storage-metrics) \n- [Data-processing services](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/data-proc-metrics) For information about implementing application-specific SLIs, see the following:\n- [Using logs-based metrics](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/logs-based-metrics) \n- [Using Prometheus](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/prometheus) \n- [Using OpenCensus](/stackdriver/docs/solutions/slo-monitoring/sli-metrics/open-census) \nFor an example that illustrates how to create a SLI for services that report custom metrics, see [Setting SLOs: observability using custom metrics](https://cloud.google.com/blog/products/management-tools/observability-using-custom-metrics) .", "guide": "Google Cloud Observability"}