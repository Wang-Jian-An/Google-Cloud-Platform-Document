{"title": "Cloud Architecture Center - Building internet connectivity for private VMs", "url": "https://cloud.google.com/architecture/reference-patterns/overview", "abstract": "# Cloud Architecture Center - Building internet connectivity for private VMs\nLast reviewed 2023-05-15 UTC\nThis document describes options for connecting to and from the internet using Compute Engine resources that have private IP addresses. This is helpful for developers who create Google Cloud services and for network administrators of Google Cloud environments.\nThis tutorial assumes you are familiar with deploying VPCs, with Compute Engine, and with basic TCP/IP networking.", "content": "## Objectives\n- Learn about the options available for connecting between private VMs outside their VPC.\n- Create an instance of Identity-Aware Proxy (IAP) for TCP tunnels that's appropriate for interactive services such as SSH.\n- Create a Cloud NAT instance to enable VMs to make outbound connections to the internet.\n- Configure an HTTP load balancer to support inbound connections from the internet to your VMs.\n## CostsThis tutorial uses billable components of Google Cloud, including:- [Compute Engine](/compute/all-pricing) \n- [Cloud NAT](/nat/pricing) \n- [Cloud Load Balancing](/vpc/network-pricing#lb) \nUse the [pricing calculator](/products/calculator) to generate a cost estimate based on your projected usage. We calculate that the total to run this tutorial is less than US$5 per day.## Before you begin\n## IntroductionPrivate IP addresses provide a number of advantages over public (external) IP addresses, including:- **Reduced attack surface** . Removing external IP addresses from VMs makes it more difficult for attackers to reach the VMs and exploit potential vulnerabilities.\n- **Increased flexibility** . Introducing a layer of abstraction, such as a load balancer or a NAT service, allows more reliable and flexible service delivery when compared with static, external IP addresses.\nThis solution discusses three scenarios, as described in the following table:\n| Interactive                               | Fetching                             | Serving                                 |\n|:--------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------|\n| An SSH connection is initiated from a remote host directly to a VM using IAP for TCP. Example: Remote administration using SSH or RDP | A connection is initiated by a VM to an external host on the internet using Cloud NAT. Example: OS updates, external APIs | A connection is initiated by a remote host to a VM through a global Google Cloud load balancer. Example: Application frontends, WordPress |\nSome environments might involve only one of these scenarios. However, many environments require all of these scenarios, and this is fully supported in Google Cloud.\nThe following sections describe a multi-region environment with an HTTP load-balanced service backed by two VMs in two regions. These VMs use Cloud NAT for outgoing communications. For administration, the VMs are accessible through SSH tunneled over IAP.\nThe following diagram provides an overview of all three use cases and the relevant components.## Creating VM instancesTo begin the tutorial, you create a total of four virtual machine (VM) instances\u2014two instances per region in two different regions. You give all of the instances the same tag, which is used later by a [firewall rule](/vpc/docs/firewalls) to allow incoming traffic to reach your instances.\nThe following diagram shows the VM instances and instance groups you create, distributed in two zones.The [startup script](/compute/docs/startupscript) that you add to each instance installs Apache and creates a unique home page for each instance.\nThe procedure includes instructions for using both the Google Cloud console and `gcloud` commands. The easiest way to use `gcloud` commands is to use [Cloud Shell](/shell/docs) .\n- In the Google Cloud console, go to the VM instances page: [GO TO THE VM INSTANCES PAGE](https://console.cloud.google.com/compute/instances) \n- Click **Create instance** .\n- Set **Name** to `www-1` .\n- Set the **Zone** to **us-central1-b** .\n- Click **Management, Security, Disks, Networking, Sole Tenancy** .\n- Click **Networking** and make the following settings:- For HTTP traffic, in the **Network tags** box, enter`http-tag`.\n- Under Network Interfaces, click.\n- Under **External IP** , select **None** .\n **Note:** Don't select the firewall boxes that allow HTTP or HTTPS traffic, because doing so creates unneeded firewall rules.\n- Click **Management** and set **Startup script** to the following:```\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo a2ensite default-ssl\nsudo a2enmod ssl\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>server 1</h1></body></html>' | sudo tee /var/www/html/index.html\n```\n- Click **Create** .\n- Create `www-2` with the same settings, except set **Startup script** to the following:```\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo a2ensite default-ssl\nsudo a2enmod ssl\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>server 2<h1></body></html>' | sudo tee /var/www/html/index.html\n```\n- Create `www-3` with the same settings, except set **Zone** to `europe-west1-b` and set **Startup script** to the following:```\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo a2ensite default-ssl\nsudo a2enmod ssl\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>server 3</h1></body></html>' | sudo tee /var/www/html/index.html\n```\n- Create `www-4` with the same settings, except set **Zone** to `europe-west1-b` and set **Startup script** to the following:```\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo a2ensite default-ssl\nsudo a2enmod ssl\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>server 4</h1></body></html>' | sudo tee /var/www/html/index.html\n```\n- Open Cloud Shell: [OPEN Cloud Shell](https://console.cloud.google.com/cloudshell) \n- Create an instance named `www-1` in `us-central1-b` with a basic startup script:```\ngcloud compute instances create www-1 \\\n --image-family debian-9 \\\n --image-project debian-cloud \\\n --zone us-central1-b \\\n --tags http-tag \\\n --network-interface=no-address \\\n --metadata startup-script=\"#! /bin/bash\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>www-1</h1></body></html>' | tee /var/www/html/index.html\nEOF\"\n```\n- Create an instance named `www-2` in `us-central1-b` :```\ngcloud compute instances create www-2 \\\n --image-family debian-9 \\\n --image-project debian-cloud \\\n --zone us-central1-b \\\n --tags http-tag \\\n --network-interface=no-address \\\n --metadata startup-script=\"#! /bin/bash\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>www-2</h1></body></html>' | tee /var/www/html/index.html\nEOF\"\n```\n- Create an instance named `www-3` , this time in `europe-west1-b` :```\ngcloud compute instances create www-3 \\\n --image-family debian-9 \\\n --image-project debian-cloud \\\n --zone europe-west1-b \\\n --tags http-tag \\\n --network-interface=no-address \\\n --metadata startup-script=\"#! /bin/bash\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>www-3</h1></body></html>' | tee /var/www/html/index.html\nEOF\"\n```\n- Create an instance named `www-4` , this one also in `europe-west1-b` :```\ngcloud compute instances create www-4 \\\n --image-family debian-9 \\\n --image-project debian-cloud \\\n --zone europe-west1-b \\\n --tags http-tag \\\n --network-interface=no-address \\\n --metadata startup-script=\"#! /bin/bash\nsudo apt-get update\nsudo apt-get install apache2 -y\nsudo service apache2 restart\necho '<!doctype html><html><body><h1>www-4</h1></body></html>' | tee /var/www/html/index.html\nEOF\"\n```\n- Open Cloud Shell: [OPEN Cloud Shell](https://console.cloud.google.com/cloudshell) \n- Clone the repository from GitHub:`git clone https://github.com/GoogleCloudPlatform/gce-public-connectivity-terraform`\n- Change the working directory to the repository directory:`cd iap`\n- Install [Terraform](https://learn.hashicorp.com/terraform/getting-started/install.html) .\n- Replace `[YOUR-ORGANIZATION-NAME]` in the `scripts/set_env_vars.sh` file with your Google Cloud organization name.\n- Set environment variables:`source scripts/set_env_vars.sh`\n- Apply the Terraform configuration:`terraform apply` **Note:** If you get an error, wait a few moments, and then run the `terraform apply` command a second time.\n## Configuring IAP tunnels for interacting with instancesTo log in to VM instances, you connect to the instances using tools like SSH or RDP. In the configuration you're creating in this tutorial, you can't directly connect to instances. However, you can use [TCP forwarding](/iap/docs/tcp-forwarding-overview) in [IAP](/iap) , which enables remote access for these interactive patterns.\nFor this tutorial, you use SSH.\nIn this section you do the following:- Connect to a Compute Engine instance using the IAP tunnel.\n- Add a second user with IAP tunneling permission in IAM.\nThe following diagram illustrates the architecture that you build in this section. The grey areas are discussed in other parts of this tutorial.\n### Limitations of IAP\n- Bandwidth: The IAP TCP forwarding feature isn't intended for bulk transfer of data. IAP reserves the right to rate-limit users who are deemed to be abusing this service.\n- Connection length: IAP won't disconnect active sessions unless required for maintenance.\n- Protocol: IAP for TCP doesn't support UDP.\n### Create firewall rules to allow tunnelingIn order to connect to your instances using SSH, you need to open an appropriate port on the firewall. IAP connections come from a specific set of IP addresses (35.235.240.0/20). Therefore, you can limit the rule to this CIDR range.\n- In the Google Cloud console, go to the **Firewall policies** page: [GO TO THE FIREWALL POLICIES PAGE](https://console.cloud.google.com/net-security/firewall-manager/firewall-policies/list) \n- Click **Create firewall rule** .\n- Set **Name** to `allow-ssh-from-iap` .\n- Leave **VPC network** as `default` .\n- Under **Targets** , select **Specified target tags** .\n- Set **Target tags** to `http-tag` .\n- Leave **Source filter** set to **IP ranges** .\n- Set **Source IP Ranges** to `35.235.240.0/20` .\n- Set **Allowed protocols and ports** to `tcp:22` .\n- Click **Create** .It might take a moment for the new firewall rule to be displayed in the console.\n- Create a firewall rule named `allow-ssh-from-iap` :```\ngcloud compute firewall-rules create allow-ssh-from-iap \\\n --source-ranges 35.235.240.0/20 \\\n --target-tags http-tag \\\n --allow tcp:22\n```\n- Copy the firewall rules Terraform file to the current directory:`cp iap/vpc_firewall_rules.tf .`\n- Apply the Terraform configuration:`terraform apply` **Note:** If you get an error, wait a few moments, and then run the `terraform apply` command a second time.### Test tunneling\n- In Cloud Shell, connect to instance `www-1` using IAP:```\ngcloud compute ssh www-1 \\\n --zone us-central1-b \\\n --tunnel-through-iap\n```\nIf the connection succeeds, you have an SSH session that is tunneled through IAP directly to your private VM.\n### Grant access to additional usersIAP uses your existing project roles and permissions when you connect to VM instances. By default, instance owners are the only users that have the **IAP Secured Tunnel User** role. If you want to allow other users to access your VMs using IAP tunneling, you need to grant this role to those users.- In the Google Cloud console, go to **Security** > **Identity-AwareProxy** : If you see a message that tells you that you need to configure the OAuth consent screen, disregard the message; it's not relevant to IAP for TCP.\n- Select the **SSH and TCP Resources** tab.\n- Select the VMs you've created: \n- On the right-hand side, click **Add Principal** .\n- Add the users you want to grant permissions to, select the **IAP-secured Tunnel User** role, and then click **Save** .\n### SummaryYou can now connect to your instances using SSH to administer the instances or troubleshoot them.\nMany applications need to make outgoing connections in order to download patches, connect with partners, or download resources. In the next section, you configure Cloud NAT to allow your VMs to reach these resources.## Deploying Cloud NAT for fetchingThe Cloud NAT service allows Google Cloud VM instances that don't have external IP addresses to connect to the internet. Cloud NAT implements outbound NAT in conjunction with a [default route](/vpc/docs/routes#routingpacketsinternet) to allow your instances to reach the internet. It doesn't implement inbound NAT. Hosts outside of your VPC network can respond only to established connections initiated by your instances; they cannot initiate their own connections to your instances using Cloud NAT. NAT is not used for traffic within Google Cloud.\nCloud NAT is a regional resource. You can configure it to allow traffic from all [primary and secondary IP address ranges](/vpc/docs/subnets#manually_created_subnet_ip_ranges) of subnets in a region, or you can configure it to apply to only some of those ranges.\nIn this section, you configure a Cloud NAT gateway in each region that you used earlier. The following diagram illustrates the architecture that you build in this section. The grey areas are discussed in other parts of this tutorial. **Note:** You can create Cloud NAT gateways in a subset of the regions you're using. You might do this if not all regions need to fetch data from the internet, or if some regions will use external IP addresses to access the internet.\n### Create a NAT configuration using Cloud RouterYou must create the Cloud Router instance in the same region as the instances that need to use Cloud NAT. Cloud NAT is only used to place NAT information onto the VMs; it's not used as part of the actual Cloud NAT gateway.\nThis configuration allows all instances in the region to use Cloud NAT for all primary and [alias IP](/vpc/docs/alias-ip) ranges. It also automatically allocates the external IP addresses for the NAT gateway. For more options, see the [gcloud compute routers](/sdk/gcloud/reference/compute/routers) documentation.\n **Note:** Cloud NAT uses Cloud Router only to group NAT configuration information (that is, for the control plane). Cloud NAT does not direct a Cloud Router to use [BGP](https://wikipedia.org/wiki/Border_Gateway_Protocol) or to add routes. NAT traffic does not pass a Cloud Router (the data plane).- Go to the **Cloud NAT** page: [GO TO THE CLOUD NAT PAGE](https://console.cloud.google.com/net-services/nat/list) \n- Click **Get started** or **Create NAT gateway** .\n- Set **Gateway name** to `nat-config` .\n- Set **VPC network** to `default` .\n- Set **Region** to `us-central1` .\n- Under **Cloud Router** , select **Create new router** , and then do the following:- Set **Name** to`nat-router-us-central1`.\n- Click **Create** .\n- Click **Create** .\n- Repeat the procedure, but substitute these values:- **Name** :`nat-router-europe-west1`\n- **Region** :`europe-west1`- Create Cloud Router instances in each region:```\ngcloud compute routers create nat-router-us-central1 \\\n --network default \\\n --region us-central1\ngcloud compute routers create nat-router-europe-west1 \\\n --network default \\\n --region europe-west1\n```\n- Configure the routers for Cloud NAT:```\ngcloud compute routers nats create nat-config \\\n --router-region us-central1 \\\n --router nat-router-us-central1 \\\n --nat-all-subnet-ip-ranges \\\n  --auto-allocate-nat-external-ips\ngcloud compute routers nats create nat-config \\\n --router-region europe-west1 \\\n --router nat-router-europe-west1 \\\n --nat-all-subnet-ip-ranges \\\n --auto-allocate-nat-external-ips\n```\n- Copy the Terraform NAT configuration file to the current directory:`cp nat/vpc_nat_gateways.tf .`\n- Apply the Terraform configuration:`terraform apply` **Note:** If you get an error, wait a few moments, and then run the `terraform apply` command a second time.### Test Cloud NAT configurationYou can now test that you're able to make outbound requests from your VM instances to the internet.- Wait up to 3 minutes for the NAT configuration to propagate to the VM.\n- In Cloud Shell, connect to your instance using the tunnel you created:```\ngcloud compute ssh www-1 --tunnel-through-iap\n```\n- When you're logged in to the instance, use the `curl` command to make an outbound request:```\ncurl example.com\n```You see the following output:```\n<html>\n<head>\n<title>Example Domain</title>\n...\n...\n...\n</head>\n<body>\n<div>\n <h1>Example Domain</h1>\n <p>This domain is established to be used for illustrative examples in documents.\n  You may use this domain in examples without prior coordination or asking for\n  permission.\n </p>\n <p><a href=\"http://www.iana.org/domains/example\">More information...</a></p>\n</div>\n</body>\n</html>\n```\nIf the command is successful, you've validated that your VMs can connect to the internet using Cloud NAT.\n### SummaryYour instances can now make outgoing connections in order to download patches, connect with partners, or download resources.\nIn the next section, you add load balancing to your deployment and configure it to allow remote clients to initiate requests to your servers.## Creating an HTTP load-balanced service for servingUsing [Cloud Load Balancing](/load-balancing) for your application has many advantages. It can provide seamless, scalable load balancing for over a million queries per second. It can also offload SSL overhead from your VMs, route queries to the best region for your users based on both location and availability, and support modern protocols such as HTTP/2 and QUIC.\nFor this tutorial, you take advantage of another key feature: global anycast IP connection proxying. This feature provides a single public IP address that's terminated on Google's globally distributed edge. Clients can then connect to resources hosted on private IP addresses anywhere in Google Cloud. This configuration helps protect instances from [DDoS](https://wikipedia.org/wiki/Denial-of-service_attack) attacks and direct attacks. It also enables features such as [Google Cloud Armor](/armor) for even more security.\nIn this section of the tutorial, you do the following:- Reset the VM instances to install the Apache web server.\n- Create a firewall rule to allow access from load balancers.\n- Allocate static, global IPv4 and IPv6 addresses for the load balancer.\n- Create an instance group for your instances.\n- Start sending traffic to your instances.\n **Note:** This is an example setup only. You should not run these commands on instances that serve production traffic.\nThe following diagram illustrates the architecture that you build in this section. The grey areas are discussed in other parts of this tutorial.\n### Reset VM instancesWhen you created the VM instances earlier in this tutorial, they didn't have access to the internet, because no external IP address was assigned and Cloud NAT was not configured. Therefore, the startup script that installs Apache could not complete successfully.\nThe easiest way to re-run the startup scripts is to reset those instances so that the Apache webserver can be installed and used in the next section.\n- In the Google Cloud console, go to the **VM instances** page: [Go to VM instances](https://console.cloud.google.com/compute/instances) \n- Select `www-1` , `www-2` , `www-3` , and `www-4` .\n- Click the **Reset** button at the top of the page.If you don't see a **Reset** button, click **More actions** more_vert and choose **Reset** .\n- Confirm the reset of the four instances by clicking **Reset** in the dialog.\n- Reset the four instances:```\ngcloud compute instances reset www-1 \\\n --zone us-central1-b\ngcloud compute instances reset www-2 \\\n --zone us-central1-b\ngcloud compute instances reset www-3 \\\n --zone europe-west1-b\ngcloud compute instances reset www-4 \\\n --zone europe-west1-b\n```### Open the firewallThe next task is to create a firewall rule to allow traffic from the load balancers to your VM instances. This rule allows traffic from the Google Cloud address range that's used both by load balancers and health checks. The firewall rule uses the `http-tag` tag that you created earlier; the firewall rule allows traffic to the designated port to reach instances that have the tag.\n- In the Google Cloud console, go to the **Firewall policies** page: [GO TO THE FIREWALL POLICIES PAGE](https://console.cloud.google.com/net-security/firewall-manager/firewall-policies/list) \n- Click **Create firewall rule** .\n- Set **Name** to `allow-lb-and-healthcheck` .\n- Leave the **VPC network** as `default` .\n- Under **Targets** , select **Specified target tags** .\n- Set **Target tags** to `http-tag` .\n- Leave **Source filter** set to **IP ranges** .\n- Set **Source IP Ranges** to `130.211.0.0/22` and `35.191.0.0/16` .\n- Set **Allowed protocols and ports** to `tcp:80` .\n- Click **Create** .It might take a moment for the new firewall rule to be displayed in the console.\n- Create a firewall rule named `allow-lb-and-healthcheck` :```\ngcloud compute firewall-rules create allow-lb-and-healthcheck \\\n --source-ranges 130.211.0.0/22,35.191.0.0/16 \\\n --target-tags http-tag \\\n  --allow tcp:80\n```\n **Note:** These steps configure the whole load balancer. Once you've completed them, you can skip to the \"Test the configuration\" section.- Copy the Terraform load-balancing configuration files to the current directory:`cp lb/* .`\n- Apply the Terraform configuration:`terraform apply` **Note:** If you get an error, wait a few moments, and then run the `terraform apply` command a second time.### Allocate an external IP address for load balancersIf you're serving traffic to the internet, you need to allocate an external address for the load balancer. You can allocate an IPv4 address, an IPv6 address, or both. In this section, you reserve static IPv4 and IPv6 addresses suitable for adding to DNS.\nThere is no additional charge for public IP addresses, because they are used with a load balancer.\n- In the Google Cloud console, go to the **External IP addresses** page: [GO TO THE EXTERNAL IP ADDRESSES PAGE](https://console.cloud.google.com/addresses/list) \n- Click **Reserve static address** to reserve an IPv4 address.\n- Set **Name** to `lb-ip-cr` .\n- Leave **Type** set to **Global** .\n- Click **Reserve** .\n- Click **Reserve static address** again to reserve an IPv6 address.\n- Set **Name** to `lb-ipv6-cr` .\n- Set **IP version** to **IPv6** .\n- Leave **Type** set to **Global** .\n- Click **Reserve** .\n- Create a static IP address named `lb-ip-cr` for IPv4:```\ngcloud compute addresses create lb-ip-cr \\\n --ip-version=IPV4 \\\n --global\n```\n- Create a static IP address named `lb-ipv6-cr` for IPv6:```\ngcloud compute addresses create lb-ipv6-cr \\\n --ip-version=IPV6 \\\n --global\n```### Create instance groups and add instancesGoogle Cloud load balancers require [instance groups](/compute/docs/instance-groups) to act as backends for traffic. In this tutorial, you use unmanaged instance groups for simplicity. However, you could also use managed instance groups to take advantage of features such as autoscaling, autohealing, regional (multi-zone) deployment, and auto-updating.\nIn this section, you create an instance group for each of the zones that you're using.\n- In the Google Cloud console, go to the **Instance groups** page: [GO TO THE INSTANCE GROUPS PAGE](https://console.cloud.google.com/compute/instanceGroups/list) \n- Click **Create instance group** .\n- On the left-hand side, click **New unmanaged instance group** .\n- Set **Name** to `us-resources-w` .\n- Set **Region** to `us-central1`\n- Set **Zone** to `us-central1-b` .\n- Select **Network** (default) and **Subnetwork** (default).\n- Under **VM instances** , do the following:- Click **Add an instance** , and then select **www-1** .\n- Click **Add an instance** again, and then select **www-2** .\n- Click **Create** .\n- Repeat this procedure to create a second instance group, but use the following values:- **Name** :`europe-resources-w`\n- **Zone** :`europe-west1-b`\n- **Instances** :`www-3`and`www-4`\n- In the **Instance groups** page, confirm that you have two instance groups, each with two instances.\n- Create the `us-resources-w` instance group:```\ngcloud compute instance-groups unmanaged create us-resources-w \\\n --zone us-central1-b\n```\n- Add the `www-1` and `www-2` instances:```\ngcloud compute instance-groups unmanaged add-instances us-resources-w \\\n --instances www-1,www-2 \\\n --zone us-central1-b\n```\n- Create the `europe-resources-w` instance group:```\ngcloud compute instance-groups unmanaged create europe-resources-w \\\n --zone europe-west1-b\n```\n- Add the `www-3` and `www-4` instances:```\ngcloud compute instance-groups unmanaged add-instances europe-resources-w \\\n --instances www-3,www-4 \\\n --zone europe-west1-b\n```### Configure the load balancing serviceLoad balancer functionality involves several connected services. In this section, you set up and connect the services. The services you will create are as follows:- [Named ports](/compute/docs/instance-groups/creating-groups-of-unmanaged-instances#assign_named_ports) , which the load balancer uses to direct traffic to your instance groups.\n- A [health check](/load-balancing/docs/health-checks) , which polls your instances to see if they are healthy. The load balancer sends traffic only to healthy instances.\n- [Backend services](/load-balancing/docs/backend-service) , which monitor instance usage and health. Backend services know whether the instances in the instance group can receive traffic. If the instances can't receive traffic, the load balancer redirects traffic, provided that instances elsewhere have sufficient capacity. A backend defines the capacity of the instance groups that it contains (maximum CPU utilization or maximum queries per second).\n- A [URL map](/load-balancing/docs/https/url-map) , which parses the URL of the request and can forward requests to specific backend services based on the host and path of the request URL. In this tutorial, because you aren't using content-based forwarding, the URL map contains only the default mapping.\n- A [target proxy](/load-balancing/docs/target-proxies) , which receives the request from the user and forwards it to the URL map.\n- Two [global forwarding rules](/load-balancing/docs/forwarding-rules) , one each for IPv4 and IPv6, that hold the global external IP address resources. Global forwarding rules forward the incoming request to the target proxy.\nIn this section you create the load balancer and configure a default [backend service](/compute/docs/reference/latest/backendServices) to handle your traffic. You also create a [health check](/load-balancing/docs/health-checks) .\n **Note:** You must configure at least one backend service to handle your traffic, or you won't be able to create the load balancer.- In the Google Cloud console, go to the **Create load balancer** page: [GO TO THE CREATE LOAD BALANCER PAGE](https://console.cloud.google.com/networking/loadbalancing/add) \n- In the **Application Load Balancer (HTTP/S)** section, click **Start configuration** .\n- Set **Name** to `web-map` .\n- In the left panel of the **Create global external Application Load Balancer** page, click **Backend configuration** .\n- In the **Create or select backend services & backend buckets** list, select **Backend services** , and then **Create a backend service** . You see the **Create Backend Service** dialog box.\n- Set **Name** to `web-map-backend-service` .\n- Set the **Protocol** . For HTTP protocol, leave the values set to the defaults.\n- For **Backend type** , select **Instance Groups** .\n- Under **Backends** , set **Instance group** to `us-resources-w` .\n- Click **Add backend** .\n- Select the **europe-resources-w** instance group and then do the following:- For HTTP traffic between the load balancer and the instances, make sure that **Port numbers** is set to`80`.\n- Leave the default values for the rest of the fields.\n- Click **Done** .\n- Under **Health check** , select **Create a health check** or **Createanother health check** .\n- Set the following health check parameters:- **Name** :`http-basic-check`\n- **Protocol** :`HTTP`\n- **Port** :`80`\n- Click **Create** .\n- For each instance group, define an HTTP service and map a port name to the relevant port:```\ngcloud compute instance-groups unmanaged set-named-ports us-resources-w \\\n --named-ports http:80 \\\n --zone us-central1-b\ngcloud compute instance-groups unmanaged set-named-ports europe-resources-w \\\n --named-ports http:80 \\\n --zone europe-west1-b\n```\n- Create a health check:```\ngcloud compute health-checks create http http-basic-check \\\n --port 80\n```\n- Create a backend service:```\ngcloud compute backend-services create web-map-backend-service \\\n --protocol HTTP \\\n --health-checks http-basic-check \\\n --global\n```You set the `--protocol` flag to `HTTP` because you're using HTTP to go to the instances. For the health check, you use the `http-basic-check` health check that you created earlier.\n- Add your instance groups as backends to the backend services:```\ngcloud compute backend-services add-backend web-map-backend-service \\\n --balancing-mode UTILIZATION \\\n --max-utilization 0.8 \\\n --capacity-scaler 1 \\\n --instance-group us-resources-w \\\n --instance-group-zone us-central1-b \\\n --global\ngcloud compute backend-services add-backend web-map-backend-service \\\n --balancing-mode UTILIZATION \\\n --max-utilization 0.8 \\\n --capacity-scaler 1 \\\n --instance-group europe-resources-w \\\n --instance-group-zone europe-west1-b \\\n --global\n```\n- In the left panel of the **Create global external Application Load Balancer** page, click **Host and path rules** .For this tutorial, you don't need to configure any host or path rules, because all traffic will go to the default rule. Therefore, you can accept [the pre-populated default values](/load-balancing/docs/https/url-map#path-matchers) .\n- Create a default URL map that directs all incoming requests to all of your instances:```\ngcloud compute url-maps create web-map \\\n --default-service web-map-backend-service\n```\n- Create a target HTTP proxy to route requests to the URL map:```\ngcloud compute target-http-proxies create http-lb-proxy \\\n --url-map web-map\n```\n- In the left panel of the **Create global external Application Load Balancer** page, click **Frontend configuration** .\n- Set **Name** to`http-cr-rule`.\n- Set **Protocol** to`HTTP`.\n- Set **IP version** to`IPv4`.\n- In the **IP address** list, select`lb-ip-cr`, the address that you created earlier.\n- Confirm that **Port** is set to`80`.\n- Click **Done** .\n- Click **Add frontend IP and port** .\n- Set **Name** to`http-cr-ipv6-rule`.\n- For **Protocol** , select **HTTP** .\n- Set **IP version** to`IPv6`.\n- In the **IP address** list, select`lb-ipv6-cr`, the other address that you created earlier.\n- Confirm that **Port** is set to`80`.\n- Click **Create** .\n- Click **Done** .\n- Get the static IP addresses that you created for your load balancer. Make a note of them, because you use them in the next step.```\ngcloud compute addresses list\n```\n- Create two global forwarding rules to route incoming requests to the proxy, one for IPv4 and one for IPv6. Replace in the command with the static IPv4 address you created, and replace with the IPv6 address you created.```\ngcloud compute forwarding-rules create http-cr-rule \\\n --address lb_ip_address \\\n --global \\\n --target-http-proxy http-lb-proxy \\\n --ports 80\ngcloud compute forwarding-rules create http-cr-ipv6-rule \\\n --address lb_ipv6_address \\\n --global \\\n --target-http-proxy http-lb-proxy \\\n --ports 80\n```\n- In the Google Cloud console, go to the **Create load balancer** page: [GO TO THE CREATE LOAD BALANCER PAGE](https://console.cloud.google.com/networking/loadbalancing/add) \n- In the left panel of the **Create global external Application Load Balancer** page, click **Review and finalize** .\n- Compare your settings to what you intended to create.\n- If the settings are correct, click **Create** .You are returned to the Load Balancing pages. After the load balancer is created, a green check mark next to it indicates that it's running.\nAfter you create the global forwarding rules, it can take several minutes for your configuration to propagate.\n### Test the configurationIn this section, you send an HTTP request to your instance to verify that the load-balancing configuration is working.\n- In the Google Cloud console, go to the **Load balancing** page: [GO TO THE LOAD BALANCING PAGE](https://console.cloud.google.com/networking/loadbalancing/list) \n- Select the load balancer named `web-map` to see details about the load balancer that you just created.\n- In the **Backend** section of the page, confirm that instances are healthy by viewing the **Healthy** column.It can take a few moments for the display to indicate that the instances are healthy.\n- When the display shows that the instances are healthy, copy the **IP:Port** value from the **Frontend** section and paste it into your browser.In your browser, you see your default content page.\n- Get the IP addresses of your global forwarding rules, and make a note of them for the next step:```\ngcloud compute forwarding-rules list\n```\n- Use the `curl` command to test the response for various URLs for your services. Try both IPv4 and IPv6. For IPv6, you must put `[]` around the address, such as `http://[2001:DB8::]/` .```\ncurl http://ipv4-address\ncurl -g -6 \"http://[ipv6-address]/\"\n```### SummaryYour VMs can now serve traffic to the internet and can fetch data from the internet. You can also access them using SSH in order to perform administration tasks. All of this functionality is achieved using only private IP addresses, which helps protect them from direct attacks by not exposing IP addresses that are reachable from the internet.## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project. **Note:** if you have used Terraform to complete this solution issue the `terraform destroy` command to remove all resources.## What's next\n- [Creating Cloud Load Balancing](/load-balancing/docs/https/cross-region-example) shows you how to create HTTPS and HTTP2 load balancers.\n- [Setting up a private cluster](/kubernetes-engine/docs/how-to/private-clusters) shows you how to set up a private Google Kubernetes Engine cluster.\n- [Using IAP for TCP forwarding](/iap/docs/using-tcp-forwarding) describes other uses for IAP for TCP, such as RDP or remote command execution.\n- [Using Cloud NAT](/nat/docs/set-up-network-address-translation) provides examples for Google Kubernetes Engine and describes how to modify parameter details.\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Cloud Architecture Center"}