{"title": "Vertex AI - Filter vector matches", "url": "https://cloud.google.com/vertex-ai/docs/vector-search/filtering", "abstract": "# Vertex AI - Filter vector matches\nIn Vector Search, you can restrict vector matching searches to a subset of the index by using Boolean rules. Boolean predicates tell Vector Search which vectors in the index to ignore. On this page you'll learn about how filtering works, see examples, and ways to efficiently query your data based on vector similarity.\nWith Vector Search you can restrict results by categorical and numeric restrictions. Adding restrictions, or \"filtering\" your index results are useful for multiple reasons, like the following examples:\n- **Improved result relevance** : Vector Search is a powerful tool for finding semantically similar items. Filtering can be used to remove irrelevant results from the search results, such as items that are not in the correct language, category, price, or date range.\n- **Reduced number of results** : Vector Search can return a large number of results, especially for large datasets. Filtering can be used to reduce the number of results to a more manageable number, while still returning the most relevant results.\n- **Segmented results** : Filtering can be used to personalize the search results to the user's individual needs and preferences. For example, a user might want to filter the results to only include items that they have rated highly in the past or that fall into a specific price range.", "content": "## Vector attributes\nIn a vector similarity search over a database of vectors, each vector is described by zero-or-more attributes. These attribute are known as for token restricts and for numeric restricts. These restricts can apply from each of several attribute categories, also known as .\nIn the following example application, vectors are tagged with a `color` , a `price` , and a `shape` :\n- `color`,`price`, and`shape`are.\n- `red`and`blue`arefrom the`color`namespace.\n- `square`and`circle`arefrom the`shape`namespace.\n- `100`and`50`arefrom the`price`namespace.\n### Specify vector attributes\n- To specify a \"red circle\":`{color: red}, {shape: circle}`.\n- To specify a \"red and blue square\":`{color: red, blue}, {shape: square}`.\n- To specify an object with no color, omit the \"color\" namespace in the`restricts`field.\n- To specify numeric restricts for an object, note the namespace and the value in the appropriate field for the type. Int value should be specified in`value_int`, float value should be specified in`value_float`, and double value should be specified in`value_double`. Only one number type should be used for a given namespace.\nFor information about the schema used to specify this data, see [Specify namespaces and tokens in the input data](/vertex-ai/docs/vector-search/filtering#specify-namespaces-tokens-or-values) .\n### Queries\n- Queries express an AND logical operator across namespaces and an OR logical operator within each namespace. A query that specifies`{color: red, blue}, {shape: square, circle}`, matches all database points that satisfy`(red || blue) && (square || circle)`.\n- A query that specifies`{color: red}`, matches all`red`objects of any kind, with no restriction on`shape`.\n- Numeric restricts in queries require`namespace`, one of number values from`value_int`,`value_float`, and`value_double`, and operator`op`.\n- Operator`op`is one of`LESS`,`LESS_EQUAL`,`EQUAL`,`GREATER_EQUAL`, and`GREATER`. For example, if the`LESS_EQUAL`operator is used, datapoints are eligible if their value is smaller or equal to the value used in the query.\nThe following code examples identify vector attributes in the sample application:\n```\n{\u00a0 namespace: \"price\"\u00a0 value_int: 20\u00a0 op: LESS}{\u00a0 namespace: \"length\"\u00a0 value_float: 0.3\u00a0 op: GREATER_EQUAL}{\u00a0 namespace: \"width\"\u00a0 value_double: 0.5\u00a0 op: EQUAL}\n```\n### Denylist\nTo enable more advanced scenarios, Google supports a form of negation known as . When a query denylists a token, matches are excluded for any datapoint that has the denylisted token. If a query namespace has only denylisted tokens, all points not explicitly denylisted, match, in exactly the same way that an empty namespace matches with all points.\nDatapoints can also denylist a token, excluding matches with any query specifying that token.\nFor example, define the following data points with the specified tokens:\n```\nA: {}     // empty set matches everything\nB: {red}    // only a 'red' token\nC: {blue}    // only a 'blue' token\nD: {orange}   // only an 'orange' token\nE: {red, blue}   // multiple tokens\nF: {red, !blue}  // deny the 'blue' token\nG: {red, blue, !blue} // An unlikely edge-case\nH: {!blue}    // deny-only (similar to empty-set)\n```\nThe system behaves as follows:\n- Empty query namespaces are match-all wildcards. For example, Q:`{}`matches DB:`{color:red}`.\n- Empty datapoint namespaces are not match-all wildcards. For example, Q: `{color:red}` doesn't match DB: `{}` .\n### Specify namespaces and tokens or values in the input data\nFor information about how to structure your input data overall, see [Input dataformat and structure](/vertex-ai/docs/vector-search/setup/format-structure) .\nThe following tabs show how to specify the namespaces and tokens associated with each input vector.\n- For each vector's record, add a field called `restricts` , to contain an array of objects, each of which is a namespace.- Each object must have a field named`namespace`. This field is the`TokenNamespace.namespace`, namespace.\n- The value of the field`allow`, if present, is an array of strings. This array of strings is the`TokenNamespace.string_tokens`list.\n- The value of the field`deny`, if present, is an array of strings. This array of strings is the`TokenNamespace.string_denylist_tokens`list.\nThe following are two example records in JSON format:\n```\n{\"id\": \"42\", \"embedding\": [0.5, 1.0], \"restricts\": [{\"namespace\": \"class\",\"allow\": [\"cat\", \"pet\"]},{\"namespace\": \"category\", \"allow\": [\"feline\"]}]}{\"id\": \"43\", \"embedding\": [0.6, 1.0], \"restricts\": [{\"namespace\":\"class\", \"allow\": [\"dog\", \"pet\"]},{\"namespace\": \"category\", \"allow\":[\"canine\"]}]}\n```- For each vector's record, add a field called `numeric_restricts` , to contain an array of objects, each of which is a numeric restrict.- Each object must have a field named`namespace`. This field is the`NumericRestrictNamespace.namespace`, namespace.\n- Each object must have one of`value_int`,`value_float`, and`value_double`.\n- Each object must not have a field named`op`. This field is only for query.\nThe following are two example records in JSON format:\n```\n{\"id\": \"42\", \"embedding\": [0.5, 1.0], \"numeric_restricts\":[{\"namespace\": \"size\", \"value_int\": 3},{\"namespace\": \"ratio\", \"value_float\": 0.1}]}{\"id\": \"43\", \"embedding\": [0.6, 1.0], \"numeric_restricts\": [{\"namespace\":\"weight\", \"value_double\": 0.3}]}\n```\nAvro records use the following schema:\n```\n{\u00a0 \"type\": \"record\",\u00a0 \"name\": \"FeatureVector\",\u00a0 \"fields\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"id\",\u00a0 \u00a0 \u00a0 \"type\": \"string\"\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"embedding\",\u00a0 \u00a0 \u00a0 \"type\": {\u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \u00a0 \"items\": \"float\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"restricts\",\u00a0 \u00a0 \u00a0 \"type\": [\u00a0 \u00a0 \u00a0 \u00a0 \"null\",\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"items\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"record\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"Restrict\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"fields\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"namespace\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"string\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"allow\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"null\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"items\": \"string\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"deny\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"null\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"items\": \"string\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"numeric_restricts\",\u00a0 \u00a0 \u00a0 \"type\": [\u00a0 \u00a0 \u00a0 \u00a0 \"null\",\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"array\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"items\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"NumericRestrict\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"record\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"fields\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"namespace\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"string\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"value_int\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": [ \"null\", \"int\" ],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"default\": null\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"value_float\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": [ \"null\", \"float\" ],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"default\": null\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"value_double\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": [ \"null\", \"double\" ],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"default\": null\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"default\": null\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"name\": \"crowding_tag\",\u00a0 \u00a0 \u00a0 \"type\": [\u00a0 \u00a0 \u00a0 \u00a0 \"null\",\u00a0 \u00a0 \u00a0 \u00a0 \"string\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 }\u00a0 ]}\n```- Token restricts- For each vector's record, add comma separated pairs of format `name=value` to specify token namespace restricts. The same name may be repeated if there are multiple values in a namespace.For example, `color=red,color=blue` represents this `TokenNamespace` :```\n{\u00a0 \"namespace\": \"color\"\u00a0 \"string_tokens\": [\"red\", \"blue\"]}\n```\n- For each vector's record, add comma separated pairs of format `name=!value` to specify excluded value for token namespace restricts.For example, `color=!red` represents this `TokenNamespace` :```\n{\u00a0 \"namespace\": \"color\"\u00a0 \"string_blacklist_tokens\": [\"red\"]}\n```\n- Numeric restricts- For each vector's record, add comma separated pairs of format `#name=numericValue` with number type suffix to specify numeric namespace restricts.Number type suffix is `i` for int, `f` for float, and `d` for double. The same name shouldn't be repeated as there should be a single value associated per namespace.For example, `#size=3i` represents this `NumericRestrictNamespace` :```\n{\u00a0 \"namespace\": \"size\"\u00a0 \"value_int\": 3}\n````#ratio=0.1f` represents this `NumericRestrictNamespace` :```\n{\u00a0 \"namespace\": \"ratio\"\u00a0 \"value_float\": 0.1}\n````#weight=0.3d` represents this `NumericRestriction` :```\n{\u00a0 \"namespace\": \"weight\"\u00a0 \"value_double\": 0.3}\n```\n### What's next\n- Learn [how to query your indexes to find their nearest neighbors](/vertex-ai/docs/vector-search/query-index-public-endpoint) .\n- Learn [how to select, query, and display these metrics in Metrics Explorer](/monitoring/charts/metrics-selector) .", "guide": "Vertex AI"}