{"title": "Cloud Architecture Center - Deploy a warm recoverable web server with Compute Engine and Cloud Storage", "url": "https://cloud.google.com/architecture/reference-patterns/overview", "abstract": "# Cloud Architecture Center - Deploy a warm recoverable web server with Compute Engine and Cloud Storage\nLast reviewed 2021-06-23 UTC\nThis document is intended for architects and people who work in operations and administrative teams. The document describes an example pattern that you can use for your own deployments in Google Cloud.\nIn this architecture, a load balancer directs traffic to [Compute Engine](/compute/docs) instances in [managed instance groups](/compute/docs/instance-groups) that serve the content. In an outage, you update the [external Application Load Balancer](/load-balancing/docs/https) configuration and fail over to a static site in [Cloud Storage](/storage/docs/introduction) .\nTo deploy this solution, you need a registered domain name that you control and want to use with this document.\nIn production deployments, your website likely includes many more files and additional application code on your managed instance group virtual machines (VMs) than is shown in this document. Cloud Storage then hosts a more limited static version that provides minimal functionality. In a warm failover scenario, users see this limited website until the managed instance groups recover and can serve traffic for the full website experience.", "content": "## ArchitectureIn this architecture, you deploy resources to create an environment as shown in the following image:When you need to fail over, you update the load balancer configuration to direct traffic to Cloud Storage, as shown in the following image:This warm failover pattern balances the cost of running another managed instance group in a different region that you only use when the primary regions fail. The cost of a static site using Cloud Storage is lower than running another managed instance group, but there's a short delay as you update the load balancer configuration between the hosting options. The limited website experience in Cloud Storage is better than an unavailable website and poor customer experience.\nFor an alternative approach that uses Cloud DNS instead of an external Application Load Balancer to control the failover, see [Deploy a warm recoverable web server using Cloud DNS with Compute Engine and Cloud Storage](/architecture/warm-recoverable-static-site-failover-cloud-dns) . This pattern is useful if you have, or want to use, Cloud DNS.\nTo run reliable applications in Google Cloud, we recommend that you design your application infrastructure to handle outages. Depending on your application and business needs, you might need a cold failover, warm failover, or hot failover pattern. For more information on how to determine the best approach for your own applications, see the [Disaster recovery planning guide](/architecture/dr-scenarios-planning-guide) .\nThis document uses a basic [Apache web server](https://httpd.apache.org/) , but the same approach to the infrastructure deployment applies to other application environments you need to create.## Objectives\n- Create regional managed instance groups with a custom VM image.\n- Create a Cloud Storage bucket.\n- Create and configure an external Application Load Balancer.\n- Test the warm web server failover with an updated load balancer configuration.\n- Test the recovery and failback with an updated load balancer configuration.\n## Costs\nIn this document, you use the following billable components of Google Cloud:- [Compute Engine](https://cloud.google.com/compute/vm-instance-pricing) \n- [Networking](https://cloud.google.com/vpc/pricing) \n- [Cloud Storage](https://cloud.google.com/storage/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . ## Before you begin- You can run the Google Cloud CLI in the [Google Cloud console](https://console.cloud.google.com/) without installing the Google Cloud CLI. To run the gcloud CLI in the Google Cloud console, use the Cloud Shell.## Prepare the environmentIn this section, you define some variables for your resource names and locations. These variables are used by the Google Cloud CLI commands as you deploy the resources.\nThroughout this document, unless otherwise noted, you enter all commands in [Cloud Shell](https://cloud.google.com/shell) or your local development environment.- Replace `` with your own project ID. If desired, provide your own name suffix for resources to help search for and identify them, such as `` .Specify two regions, such as `` and `` , and a zone within one of those regions, such as `` . This zone defines where the initial base VM is created that's used to create an image for the managed instance group.Finally, set a domain that's used for your static website, such as `` .```\nPROJECT_ID=PROJECT_IDNAME_SUFFIX=appREGION1=us-west1REGION2=us-west2ZONE=us-west1-aDOMAIN=example.com\n```\n## Create a VPC and subnetTo provide network access to the VMs, you create Virtual Private Cloud (VPC) and subnets. As you need managed instance groups in two regions, you create one subnet in each region. For more information on the advantages of the custom subnet mode to manage IP address ranges in use in your environment, see [Use custom mode VPC networks](/solutions/best-practices-vpc-design#custom-mode) .- Create the VPC with a custom subnet mode:```\ngcloud compute networks create network-$NAME_SUFFIX --subnet-mode=custom\n```\n- Now create two subnets in the new VPC, one for each region. Define your own address ranges, such as `` and `` , that fit in your network range:```\ngcloud compute networks subnets create \\\u00a0 \u00a0 subnet-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --network=network-$NAME_SUFFIX \\\u00a0 \u00a0 --range=10.1.0.0/20 \\\u00a0 \u00a0 --region=$REGION1gcloud compute networks subnets create \\\u00a0 \u00a0 subnet-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --network=network-$NAME_SUFFIX \\\u00a0 \u00a0 --range=10.2.0.0/20 \\\u00a0 \u00a0 --region=$REGION2\n```\n## Create firewall rulesTo let network traffic flow correctly in the VPC, use [firewall rules](/vpc/docs/firewalls) .- Create firewall rules to allow web traffic and health checks for the load balancer and managed instance groups:```\ngcloud compute firewall-rules create allow-http-$NAME_SUFFIX \\\u00a0 \u00a0 --network=network-$NAME_SUFFIX \\\u00a0 \u00a0 --direction=INGRESS \\\u00a0 \u00a0 --priority=1000 \\\u00a0 \u00a0 --action=ALLOW \\\u00a0 \u00a0 --rules=tcp:80 \\\u00a0 \u00a0 --source-ranges=0.0.0.0/0 \\\u00a0 \u00a0 --target-tags=http-servergcloud compute firewall-rules create allow-health-check-$NAME_SUFFIX \\\u00a0 \u00a0 --network=network-$NAME_SUFFIX \\\u00a0 \u00a0 --action=allow \\\u00a0 \u00a0 --direction=ingress \\\u00a0 \u00a0 --source-ranges=130.211.0.0/22,35.191.0.0/16 \\\u00a0 \u00a0 --target-tags=allow-health-check \\\u00a0 \u00a0 --rules=tcp:80\n```The HTTP rule allows traffic to any VM where the `http-server` tag is applied, and from any source using the `0.0.0.0/0` range. For the [health check rule](/load-balancing/docs/health-checks#firewall_rules) , default ranges for Google Cloud are set to allow the platform to correctly check the health of resources.\n- To allow SSH traffic for the initial configuration of a base VM image, scope the firewall rule to your environment using the `--source-range` parameter. You might need to work with your network team to determine what source ranges your organization uses. **Caution:** We don't recommend using a broad `0.0.0.0/0` range that would allow all traffic. To scope traffic to a single IP address, use a network mask, such as `35.230.62.163/32` .Replace `` with your own IP address scopes:```\ngcloud compute firewall-rules create allow-ssh-$NAME_SUFFIX \\\u00a0 \u00a0 --network=network-$NAME_SUFFIX \\\u00a0 \u00a0 --direction=INGRESS \\\u00a0 \u00a0 --priority=1000 \\\u00a0 \u00a0 --action=ALLOW \\\u00a0 \u00a0 --rules=tcp:22 \\\u00a0 \u00a0 --source-ranges=IP_ADDRESS_SCOPE\n```\n- After you create the firewall rules, verify that the three rules have been added:```\ngcloud compute firewall-rules list \\\u00a0 \u00a0 --project=$PROJECT_ID \\\u00a0 \u00a0 --filter=\"NETWORK=network-$NAME_SUFFIX\"\n```The following example output shows the three rules have been correctly created:```\nNAME     NETWORK  DIRECTION PRIORITY ALLOW\nallow-health-check-app network-app INGRESS 1000  tcp:80\nallow-http-app   network-app INGRESS 1000  tcp:80\nallow-ssh-app   network-app INGRESS 1000  tcp:22\n```\n## Create and configure a base VM imageTo create identical VMs that you deploy without additional configuration, you use a custom VM image. This image captures the OS and Apache configuration, and is used to create each VM in the managed instance group in the next steps.\n **Note:** In this document, you manually create and configure the base VM and images. In production deployments, use your existing deployment tools and pipelines to automate as much of this process as possible. For more information, see [Managing infrastructure as code with Terraform, Cloud Build, and GitOps](/architecture/managing-infrastructure-as-code) .\nOn the VM, you create a basic `index.html` file on the persistent disk and mount it to `/var/www/example.com` . An Apache configuration file at `/etc/apache2/sites-available/example.com.conf` serves web content from the mounted persistent disk location.\nThe following diagram shows the basic HTML page served by Apache that's stored on the persistent disk:You build this environment in the following steps.- Create a base VM with an attached persistent disk:```\ngcloud compute instances create vm-base-$NAME_SUFFIX \\\u00a0 \u00a0 --zone=$ZONE \\\u00a0 \u00a0 --machine-type=n1-standard-1 \\\u00a0 \u00a0 --subnet=subnet-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --tags=http-server \\\u00a0 \u00a0 --image=debian-10-buster-v20210420 \\\u00a0 \u00a0 --image-project=debian-cloud \\\u00a0 \u00a0 --boot-disk-size=10GB \\\u00a0 \u00a0 --boot-disk-type=pd-balanced \\\u00a0 \u00a0 --boot-disk-device-name=vm-base-$NAME_SUFFIX \\\u00a0 \u00a0 --create-disk=type=pd-ssd,name=disk-base-$NAME_SUFFIX,size=10GB,device-name=disk-base-$NAME_SUFFIX\n```You use parameters defined at the start of this document to name the VM and connect to the correct subnet. Names are also assigned from the parameters for the boot disk and data disk.\n- To install and configure the simple website, connect to the base VM using SSH:```\ngcloud compute ssh vm-base-$NAME_SUFFIX --zone=$ZONE\n```\n- In your SSH session to the VM, create a script to configure the VM in an editor of your choice. The following example uses [Nano](https://www.nano-editor.org/) as the editor:```\nnano configure-vm.sh\n```Paste the following configuration script into the file:```\n#!/bin/bashNAME_SUFFIX=app# Create directory for the basic website filessudo mkdir -p /var/www/example.comsudo chmod a+w /var/www/example.comsudo chown -R www-data: /var/www/example.com# Find the disk name, then format and mount itDISK_NAME=\"google-disk-base-$NAME_SUFFIX\"DISK_PATH=\"$(find /dev/disk/by-id -name \"${DISK_NAME}\" | xargs -I '{}' readlink -f '{}')\"sudo mkfs.ext4 -m 0 -E lazy_itable_init=0,lazy_journal_init=0,discard $DISK_PATHsudo mount -o discard,defaults $DISK_PATH /var/www/example.com# Install Apachesudo apt-get update && sudo apt-get -y install apache2# Write out a basic HTML file to the mounted persistent disksudo tee -a /var/www/example.com/index.html >/dev/null <<'EOF'<!doctype html><html lang=en><head><meta charset=utf-8>\u00a0 \u00a0 <title>HA / DR example</title></head><body>\u00a0 \u00a0 <p>Welcome to a Compute Engine website with warm failover to Cloud Storage!</p></body></html>EOF# Write out an Apache configuration filesudo tee -a /etc/apache2/sites-available/example.com.conf >/dev/null <<'EOF'<VirtualHost *:80>\u00a0 \u00a0 \u00a0 \u00a0 ServerName www.example.com\u00a0 \u00a0 \u00a0 \u00a0 ServerAdmin webmaster@localhost\u00a0 \u00a0 \u00a0 \u00a0 DocumentRoot /var/www/example.com\u00a0 \u00a0 \u00a0 \u00a0 ErrorLog ${APACHE_LOG_DIR}/error.log\u00a0 \u00a0 \u00a0 \u00a0 CustomLog ${APACHE_LOG_DIR}/access.log combined</VirtualHost>EOF# Enable the Apache configuration file and reload servicesudo a2dissite 000-defaultsudo a2ensite example.com.confsudo systemctl reload apache2\n```Update the `` variable to match the value set at the start of this document, such as .\n- Write out the file and exit your editor. For example, in Nano you use `Ctrl-O` to write out the file, then exit with `Ctrl-X` .\n- Make the configuration script executable, then run it:```\nchmod +x configure-vm.sh./configure-vm.sh\n```\n- Exit the SSH session to the VM:```\nexit\n```\n- Get the IP address of the VM and use `curl` to see the basic web page:```\ncurl $(gcloud compute instances describe vm-base-$NAME_SUFFIX \\\u00a0 \u00a0 --zone $ZONE \\\u00a0 \u00a0 --format=\"value(networkInterfaces.accessConfigs.[0].natIP)\")\n```The basic website is returned, as shown in the following example output:```\n<!doctype html>\n<html lang=en>\n<head>\n<meta charset=utf-8>\n <title>HA / DR example</title>\n</head>\n<body>\n <p>Welcome to a Compute Engine website with warm failover to Cloud Storage!</p>\n</body>\n</html>\n```This step confirms that Apache is configured correctly, and the page is loaded from the attached persistent disk. In the following sections, you create an image using this base VM and configure an instance template with a startup script.\n## Deploy the Compute Engine resourcesThis warm failover pattern uses managed instance groups to run the VMs. The managed instance groups run in two regions, and each group monitors the health of the VMs. If there's an outage and one of the VMs fails, the managed instance group recreates the VM. This configuration creates a highly available application, even without the warm failover to a static site in Cloud Storage.- Before you can create an image, you must stop the VM:```\ngcloud compute instances stop vm-base-$NAME_SUFFIX --zone=$ZONE\n```\n- Run the following set of commands to create the VM images, instance templates, and managed instance groups:```\n# Create the base VM imagesgcloud compute images create image-$NAME_SUFFIX \\\u00a0 \u00a0 --source-disk=vm-base-$NAME_SUFFIX \\\u00a0 \u00a0 --source-disk-zone=$ZONEgcloud compute images create image-disk-$NAME_SUFFIX \\\u00a0 \u00a0 --source-disk=disk-base-$NAME_SUFFIX \\\u00a0 \u00a0 --source-disk-zone=$ZONE# Create instance templatesgcloud compute instance-templates create template-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --machine-type=n1-standard-1 \\\u00a0 \u00a0 --subnet=projects/$PROJECT_ID/regions/$REGION1/subnetworks/subnet-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --region=$REGION1 \\\u00a0 \u00a0 --tags=http-server \\\u00a0 \u00a0 --metadata=^,@^startup-script=\\!\\#\\ /bin/bash$'\\n'echo\\ UUID=\\`blkid\\ -s\\ UUID\\ -o\\ value\\ /dev/sdb\\`\\ /var/www/example.com\\ ext4\\ discard,defaults,nofail\\ 0\\ 2\\ \\|\\ tee\\ -a\\ /etc/fstab$'\\n'mount\\ -a \\\u00a0 \u00a0 --image=image-$NAME_SUFFIX \\\u00a0 \u00a0 --create-disk=image=image-disk-$NAME_SUFFIX,auto-delete=yesgcloud compute instance-templates create template-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --machine-type=n1-standard-1 \\\u00a0 \u00a0 --subnet=projects/$PROJECT_ID/regions/$REGION2/subnetworks/subnet-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --region=$REGION2 \\\u00a0 \u00a0 --tags=http-server \\\u00a0 \u00a0 --metadata=^,@^startup-script=\\!\\#\\ /bin/bash$'\\n'echo\\ UUID=\\`blkid\\ -s\\ UUID\\ -o\\ value\\ /dev/sdb\\`\\ /var/www/example.com\\ ext4\\ discard,defaults,nofail\\ 0\\ 2\\ \\|\\ tee\\ -a\\ /etc/fstab$'\\n'mount\\ -a \\\u00a0 \u00a0 --image=image-$NAME_SUFFIX \\\u00a0 \u00a0 --create-disk=image=image-disk-$NAME_SUFFIX,auto-delete=yes# Create a health check for VM instancesgcloud compute health-checks create http http-basic-check-$NAME_SUFFIX \\\u00a0 \u00a0 --port 80# Create the managed instance groupsgcloud compute instance-groups managed create instance-group-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --template=template-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --size=2 \\\u00a0 \u00a0 --region=$REGION1 \\\u00a0 \u00a0 --health-check=http-basic-check-$NAME_SUFFIXgcloud compute instance-groups managed create instance-group-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --template=template-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --size=2 \\\u00a0 \u00a0 --region=$REGION2 \\\u00a0 \u00a0 --health-check=http-basic-check-$NAME_SUFFIX\n```\n## Create and configure a load balancerFor users to access your website, you need to allow traffic through to the VMs that run in the managed instance groups. You also want to automatically redirect traffic to new VMs if there's a zone failure in a managed instance group.\nIn the following section, you create an [external load balancer](/load-balancing/docs/load-balancing-overview) with a backend service for HTTP traffic on port 80, use the health check created in the previous steps, and map an external IP address through to the backend service.\nFor more information, see [How to set up a simple external HTTP load balancer](/load-balancing/docs/https/ext-http-lb-simple) .- Create and configure the load balancer for your application:```\n# Configure port rules for HTTP port 80gcloud compute instance-groups set-named-ports \\\u00a0 \u00a0 instance-group-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --named-ports http:80 \\\u00a0 \u00a0 --region $REGION1gcloud compute instance-groups set-named-ports \\\u00a0 \u00a0 instance-group-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --named-ports http:80 \\\u00a0 \u00a0 --region $REGION2# Create a backend service and add the managed instance groups to itgcloud compute backend-services create \\\u00a0 \u00a0 web-backend-service-$NAME_SUFFIX \\\u00a0 \u00a0 --protocol=HTTP \\\u00a0 \u00a0 --port-name=http \\\u00a0 \u00a0 --health-checks=http-basic-check-$NAME_SUFFIX \\\u00a0 \u00a0 --globalgcloud compute backend-services add-backend \\\u00a0 \u00a0 web-backend-service-$NAME_SUFFIX \\\u00a0 \u00a0 --instance-group=instance-group-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --instance-group-region=$REGION1 \\\u00a0 \u00a0 --globalgcloud compute backend-services add-backend \\\u00a0 \u00a0 web-backend-service-$NAME_SUFFIX \\\u00a0 \u00a0 --instance-group=instance-group-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --instance-group-region=$REGION2 \\\u00a0 \u00a0 --global# Create a URL map for the backend servicegcloud compute url-maps create web-map-http-$NAME_SUFFIX \\\u00a0 \u00a0 --default-service web-backend-service-$NAME_SUFFIX# Configure forwarding for the HTTP trafficgcloud compute target-http-proxies create \\\u00a0 \u00a0 http-lb-proxy-$NAME_SUFFIX \\\u00a0 \u00a0 --url-map web-map-http-$NAME_SUFFIXgcloud compute forwarding-rules create \\\u00a0 \u00a0 http-content-rule-$NAME_SUFFIX \\\u00a0 \u00a0 --global \\\u00a0 \u00a0 --target-http-proxy=http-lb-proxy-$NAME_SUFFIX \\\u00a0 \u00a0 --ports=80\n```\n- Get the IP address of the forwarding rule for the web traffic:```\nIP_ADDRESS=$(gcloud compute forwarding-rules describe http-content-rule-$NAME_SUFFIX \\\u00a0 \u00a0 --global \\\u00a0 \u00a0 --format=\"value(IPAddress)\")\n```\n- Use `curl` , or open your web browser, to view the website using the IP address of the load balancer from the previous step:```\ncurl $IP_ADDRESS\n```It takes a few minutes for the load balancer to finish deploying and to correctly direct traffic to your backend. An HTTP 404 error is returned if the load balancer is still deploying. If needed, wait a few minutes and try to access the website again.The basic website is returned, as shown in the following example output:```\n<!doctype html>\n<html lang=en>\n<head>\n<meta charset=utf-8>\n <title>HA / DR example</title>\n</head>\n<body>\n <p>Welcome to a Compute Engine website with warm failover to Cloud Storage!</p>\n</body>\n</html>\n```\n## Create and configure a storage bucket [Cloud Storage](/storage/docs/introduction) is used to hold static website files. In this basic example, you create a single file with slightly different text than on the VMs.\nIn production deployments, your website likely includes many more files and additional application code on your managed instance group VMs than is shown in this document. The static version hosted in Cloud Storage is often then a more limited version that provides minimal functionality. In a warm failover scenario, this limited website from Cloud Storage is displayed until the managed instance groups recover and can serve traffic for the full website experience.- [Verify the domain](/storage/docs/domain-name-verification#verification) that you want to use with your Cloud Storage bucket.\n- Create a Cloud Storage bucket to match the name of the domain you own and want to use:```\ngsutil mb gs://static-web.$DOMAIN\n```The `DOMAIN` variable defined at the start of this document is used, such as `` . This example stores the static files at `static-web.example.com` .\n- Create a local file that you copy to the Cloud Storage bucket in the next step:```\ncat <<EOF > index.html<!doctype html><html lang=en><head><meta charset=utf-8>\u00a0 \u00a0 <title>HA / DR example</title></head><body>\u00a0 \u00a0 <p>Welcome to a test static web server with warm failover from Cloud Storage!</p></body></html>EOF\n```\n- Upload the basic HTML file to the Cloud Storage bucket:```\ngsutil cp index.html gs://static-web.$DOMAIN\n```\n- To allow users to view the static web content, set the appropriate permissions on the Cloud Storage bucket:```\ngsutil iam ch allUsers:objectViewer gs://static-web.$DOMAIN\n```\n- Configure the Cloud Storage bucket to serve the `index.html` file as the default web page:```\ngsutil web set -m index.html gs://static-web.$DOMAIN\n```\n## Add the Cloud Storage bucket to the load balancerWith the Cloud Storage bucket created and configured to host static web content, the load balancer needs information on how to direct traffic to it.\nIn [Create and configure a load balancer](#create_and_configure_a_load_balancer) , you created a backend service for the managed instance groups. The backend service has a URL map, and an HTTP target proxy helps direct users through the load balancer to the VMs.\nTo get ready to direct traffic to the Cloud Storage bucket, configure the load balancer with a new backend and URL map for the storage bucket. When you need to fail over, you update the load balancer to use this configuration.- Add a backend for the Cloud Storage bucket:```\ngcloud compute backend-buckets create \\\u00a0 \u00a0 web-bucket-$NAME_SUFFIX \\\u00a0 \u00a0 --gcs-bucket-name=static-web.$DOMAIN\n```\n- Create a URL map that allows traffic to flow to the backend:```\ngcloud compute url-maps create \\\u00a0 \u00a0 web-map-http-bucket-$NAME_SUFFIX \\\u00a0 \u00a0 --default-backend-bucket=web-bucket-$NAME_SUFFIX\n```\n- Review the resource deployments before simulating a zone failure. All of the resources have been created to support the environment, as shown in the following image:- A load balancer directs traffic to two managed instance groups. The managed instance groups each contain two VMs that run a basic website.\n- A Cloud Storage bucket is configured to host static pages if there's an outage with the managed instance groups.\n- The load balancer is configured to use the static site in Cloud Storage, but doesn't currently direct traffic to the storage bucket.## Fail over to the Cloud Storage bucketIn a real environment, you might get an alert using [Cloud Monitoring](/monitoring/alerts) or other monitoring solution when there's a problem with the managed instance groups. This alert prompts a human to understand the scope of the failure before you update the load balancer to redirect traffic to the Cloud Storage-hosted static website. An alternative is to use your monitoring solution to automatically respond to outages with the managed instance groups.\nWhen you fail over, the external Application Load Balancer directs traffic to the Cloud Storage-hosted static website, as shown in the following image:When you or your monitoring solution determine the most appropriate action is to update the load balancer to direct traffic to the storage bucket, update the HTTP proxy target to use the URL map you created in the previous section. In this document, you manually update the load balancer to redirect traffic to the Cloud Storage-hosted static website.- Update the existing HTTP proxy target to use the URL map for the Cloud Storage bucket:```\ngcloud compute target-http-proxies update \\\u00a0 \u00a0 http-lb-proxy-$NAME_SUFFIX \\\u00a0 \u00a0 --url-map=web-map-http-bucket-$NAME_SUFFIX\n```\n- Now use `curl` , or open your web browser, to access the IP address of the load balancer:```\ncurl $IP_ADDRESS\n```The static website from Cloud Storage is returned, as shown in the following example output:```\n<!doctype html>\n<html lang=en>\n<head>\n<meta charset=utf-8>\n <title>HA / DR example</title>\n</head>\n<body>\n <p>Welcome to a test static web server with warm failover from Cloud Storage!</p>\n</body>\n</html>\n```It might take a few minutes for the load balancer to update the configuration and to correctly direct traffic to your Cloud Storage bucket. If needed, wait a few minutes and try to access the website again.\n## Fail back to the managed instance groupsAfter issues with the managed instance groups are resolved, you can fail back to content from the load-balanced managed instance groups by again updating the URL map configuration. Again, a human might make this decision using Cloud Monitoring insights for the health of the managed instance groups. Or, you could use automation to respond to the restored health of the managed instance group. In this document, you manually update the load balancer configuration.- Update the HTTP proxy target to use the URL map for the managed instance groups again:```\ngcloud compute target-http-proxies update \\\u00a0 \u00a0 http-lb-proxy-$NAME_SUFFIX \\\u00a0 \u00a0 --url-map=web-map-http-$NAME_SUFFIX\n```\n- Use `curl` again, or open your web browser, to access the IP address of the load balancer:```\ncurl $IP_ADDRESS\n```It might take a few minutes for the load balancer to update the configuration and to correctly direct traffic back to your managed instance groups. If needed, wait a few minutes and try to access the website again.The main website from the managed instance groups is returned, as shown in the following example output:```\n<!doctype html>\n<html lang=en>\n<head>\n<meta charset=utf-8>\n <title>HA / DR example</title>\n</head>\n<body>\n p>Welcome to a Compute Engine website with warm failover to Cloud Storage!</p>\n</body>\n</html>\n```\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\nTo delete the individual resources created in this document, complete the following steps:- Delete the Cloud Storage bucket:```\ngsutil rm -r gs://static-web.$DOMAIN\n```\n- Delete the load balancer configuration:```\ngcloud compute forwarding-rules delete \\\u00a0 \u00a0 http-content-rule-$NAME_SUFFIX --global --quietgcloud compute target-http-proxies delete \\\u00a0 \u00a0 http-lb-proxy-$NAME_SUFFIX --quietgcloud compute url-maps delete web-map-http-$NAME_SUFFIX --quietgcloud compute url-maps delete web-map-http-bucket-$NAME_SUFFIX --quietgcloud compute backend-services delete \\\u00a0 \u00a0 web-backend-service-$NAME_SUFFIX --global --quietgcloud compute backend-buckets delete web-bucket-$NAME_SUFFIX --quiet\n```\n- Delete the managed instance groups and health check:```\ngcloud compute instance-groups managed delete \\\u00a0 \u00a0 instance-group-$NAME_SUFFIX-$REGION1 \\\u00a0 \u00a0 --region=$REGION1 --quietgcloud compute instance-groups managed delete \\\u00a0 \u00a0 instance-group-$NAME_SUFFIX-$REGION2 \\\u00a0 \u00a0 --region=$REGION2 --quietgcloud compute health-checks delete http-basic-check-$NAME_SUFFIX --quiet\n```\n- Delete the instance templates, images, base VM, and persistent disks:```\ngcloud compute instance-templates delete \\\u00a0 \u00a0 template-$NAME_SUFFIX-$REGION1 --quietgcloud compute instance-templates delete \\\u00a0 \u00a0 template-$NAME_SUFFIX-$REGION2 --quietgcloud compute images delete image-$NAME_SUFFIX --quietgcloud compute images delete image-disk-$NAME_SUFFIX --quietgcloud compute instances delete vm-base-$NAME_SUFFIX \\\u00a0 \u00a0 --zone=$ZONE --quiet\n```\n- Delete the firewall rules.```\ngcloud compute firewall-rules delete \\\u00a0 \u00a0 allow-health-check-$NAME_SUFFIX --quietgcloud compute firewall-rules delete \\\u00a0 \u00a0 allow-ssh-$NAME_SUFFIX --quietgcloud compute firewall-rules delete \\\u00a0 \u00a0 allow-http-$NAME_SUFFIX --quiet\n```\n- Delete the subnet and VPC.```\ngcloud compute networks subnets delete \\\u00a0 \u00a0 subnet-$NAME_SUFFIX-$REGION1 --region=$REGION1 --quietgcloud compute networks subnets delete \\\u00a0 \u00a0 subnet-$NAME_SUFFIX-$REGION2 --region=$REGION2 --quietgcloud compute networks delete network-$NAME_SUFFIX --quiet\n```\n## What's next\n- For an alternative approach that uses Cloud DNS instead of an external Application Load Balancer to control the failover, see [Deploy a warm recoverable web server using Cloud DNS with Compute Engine and Cloud Storage](/architecture/warm-recoverable-static-site-failover-cloud-dns) . This pattern is useful if you have, or want to use, Cloud DNS.\n- To learn how how to determine the best approach for your own applications and which recovery method to use, see the [Disaster recovery planning guide](/architecture/dr-scenarios-planning-guide) .\n- To see other patterns for applications, such as cold and hot failover, see [Disaster recovery scenarios for applications](/architecture/dr-scenarios-for-applications) .\n- For more ways to handle scale and availability, see the [Patterns for scalable and resilient apps](/architecture/scalable-and-resilient-apps) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Cloud Architecture Center"}