{"title": "IAM - Restrict a credential's Cloud Storage permissions", "url": "https://cloud.google.com/iam/docs/downscoping-short-lived-credentials", "abstract": "# IAM - Restrict a credential's Cloud Storage permissions\nThis page explains how to use Credential Access Boundaries to , or restrict, the Identity and Access Management (IAM) permissions that a short-lived credential can use.\nYou can use Credential Access Boundaries to generate OAuth 2.0 access tokens that represent a service account but have fewer permissions than the service account. For example, if one of your customers needs to access Cloud Storage data that you control, you can do the following:\n- Create a service account that can access every Cloud Storage bucket that you own.\n- Generate an OAuth 2.0 access token for the service account.\n- Apply a Credential Access Boundary that only allows access to the bucket that contains your customer's data.", "content": "## How Credential Access Boundaries work\nTo downscope permissions, you define a Credential Access Boundary that specifies which resources the short-lived credential can access, as well as an upper bound on the permissions that are available on each resource. You can then create a short-lived credential, then exchange it for a new credential that respects the Credential Access Boundary.\n**Note:** Only Cloud Storage supports Credential Access Boundaries. Other Google Cloud services do not support this feature.\nIf you need to give principals a distinct set of permissions for each session, using Credential Access Boundaries can be more efficient than creating many different service accounts and granting each service account a different set of roles.\n## Examples of Credential Access Boundaries\nThe following sections show examples of Credential Access Boundaries for common use cases. You use the Credential Access Boundary when you [exchange an OAuth 2.0 access token for a downscoped token](#exchange-credential) .\n### Limit permissions for a bucket\nThe following example shows a simple Credential Access Boundary. It applies to the Cloud Storage bucket `example-bucket` , and it sets the upper bound to the permissions included in the Storage Object Viewer role ( `roles/storage.objectViewer` ):\n```\n{\u00a0 \"accessBoundary\": {\u00a0 \u00a0 \"accessBoundaryRules\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"availablePermissions\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"inRole:roles/storage.objectViewer\"\u00a0 \u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \u00a0 \"availableResource\": \"//storage.googleapis.com/projects/_/buckets/example-bucket\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\n### Limit permissions for multiple buckets\nThe following example shows a Credential Access Boundary that includes rules for multiple buckets:\n- The Cloud Storage bucket`example-bucket-1`: For this bucket, only the permissions in the Storage Object Viewer role (`roles/storage.objectViewer`) are available.\n- The Cloud Storage bucket`example-bucket-2`: For this bucket, only the permissions in the Storage Object Creator role (`roles/storage.objectCreator`) are available.\n```\n{\u00a0 \"accessBoundary\": {\u00a0 \u00a0 \"accessBoundaryRules\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"availablePermissions\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"inRole:roles/storage.objectViewer\"\u00a0 \u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \u00a0 \"availableResource\": \"//storage.googleapis.com/projects/_/buckets/example-bucket-1\"\u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"availablePermissions\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"inRole:roles/storage.objectCreator\"\u00a0 \u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \u00a0 \"availableResource\": \"//storage.googleapis.com/projects/_/buckets/example-bucket-2\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\n### Limit permissions for specific objects\nYou can also use [IAM Conditions](/iam/docs/conditions-overview) to specify which Cloud Storage objects a principal can access. For example, you can add a condition that makes permissions available for objects whose name starts with `customer-a` :\n```\n{\u00a0 \"accessBoundary\": {\u00a0 \u00a0 \"accessBoundaryRules\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"availablePermissions\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"inRole:roles/storage.objectViewer\"\u00a0 \u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \u00a0 \"availableResource\": \"//storage.googleapis.com/projects/_/buckets/example-bucket\",\u00a0 \u00a0 \u00a0 \u00a0 \"availabilityCondition\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"expression\" : \"resource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a')\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\n### Limit permissions when listing objects\nWhen you [list the objects in a Cloud Storage bucket](/storage/docs/json_api/v1/objects/list) , you are calling a method on a bucket resource, not an object resource. As a result, if a condition is evaluated for a list request, and the condition refers to the [resource name](/iam/docs/conditions-attribute-reference#resource-name) , then the resource name identifies the bucket, not an object within the bucket. For example, when you list objects in `example-bucket` , the resource name is `projects/_/buckets/example-bucket` .\nThis naming convention can lead to unexpected behavior when you list objects. For example, suppose you want a Credential Access Boundary that allows view access to objects in `example-bucket` with the prefix `customer-a/invoices/` . You might try to use the following condition in the Credential Access Boundary:\nIncomplete: Condition that checks only the resource name\n```\nresource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a/invoices/')\n```\nThis condition works for reading objects, but not for listing objects:\n- When a principal tries to read an object in`example-bucket`with the prefix`customer-a/invoices/`, the condition evaluates to`true`.\n- When a principal tries to list objects with that prefix, the condition evaluates to`false`. The value of`resource.name`is`projects/_/buckets/example-bucket`, which does not start with`projects/_/buckets/example-bucket/objects/customer-a/invoices/`.\nTo prevent this issue, in addition to using `resource.name.startsWith()` , your condition can check an [API attribute](/iam/docs/conditions-attribute-reference#api) named `storage.googleapis.com/objectListPrefix` . This attribute contains the value of the `prefix` parameter that was used to filter the list of objects. As a result, you can write a condition that refers to the value of the `prefix` parameter.\n**Warning:** API attributes for Cloud Storage are supported only in Credential Access Boundaries. If you use Cloud Storage API attributes in a conditional role binding, then Cloud Storage methods will work incorrectly and fail unexpectedly. In addition, it might take longer to check IAM permissions when you access Cloud Storage.\nThe following example shows how to use the API attribute in a condition. It allows reading listing objects in `example-bucket` with the prefix `customer-a/invoices/` :\nComplete: Condition that checks the resource name and the prefix\n```\nresource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a/invoices/') ||\n api.getAttribute('storage.googleapis.com/objectListPrefix', '')\n      .startsWith('customer-a/invoices/')\n```\nYou can now use this condition in a Credential Access Boundary:\n```\n{\u00a0 \"accessBoundary\": {\u00a0 \u00a0 \"accessBoundaryRules\": [\u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \"availablePermissions\": [\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"inRole:roles/storage.objectViewer\"\u00a0 \u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \u00a0 \"availableResource\": \"//storage.googleapis.com/projects/_/buckets/example-bucket\",\u00a0 \u00a0 \u00a0 \u00a0 \"availabilityCondition\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"expression\":\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"resource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a/invoices/') || api.getAttribute('storage.googleapis.com/objectListPrefix', '').startsWith('customer-a/invoices/')\"\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 ]\u00a0 }}\n```\n## Before you begin\nBefore you use Credential Access Boundaries, make sure you meet the following requirements:\n- You need to downscope permissions only for Cloud Storage, not for other Google Cloud services.If you need to downscope permissions for additional Google Cloud services, you can create multiple [service accounts](/iam/docs/service-accounts) and grant a different set of roles to each service account.\n- You can use [OAuth 2.0 access tokens](/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth) for authentication. Other types of short-lived credentials do not support Credential Access Boundaries.\nAlso, you must enable the required APIs:\n- Enable the IAM and Security Token Service APIs. [Enable the APIs](https://console.cloud.google.com/flows/enableapi?apiid=iam.googleapis.com,sts.googleapis.com&redirect=https://console.cloud.google.com) ## Create a downscoped short-lived credential\nTo create an OAuth 2.0 access token with downscoped permissions, follow these steps:\n- [Grant the appropriate IAM roles](#grant-roles) to a user or service account.\n- [Define a Credential Access Boundary](#define-boundary) that sets an upper bound on the permissions that are available to the user or service account.\n- [Create an OAuth 2.0 access token](#create-credential) for the user or service account.\n- [Exchange the OAuth 2.0 access token](#exchange-credential) for a new token that respects the Credential Access Boundary.\nYou can then use the new, downscoped OAuth 2.0 access token to authenticate requests to Cloud Storage.\n### Grant IAM roles\nA Credential Access Boundary sets an upper bound on the available permissions for a resource. It can subtract permissions from a principal, but it cannot add permissions that the principal does not already have.\nAs a result, you must also grant roles to the principal that provide the permissions they need, either [on a Cloud Storage bucket](/storage/docs/access-control/using-iam-permissions#bucket-add) or [on a higher-level resource](/iam/docs/granting-changing-revoking-access) , such as the project.\nFor example, suppose you need to create a downscoped short-lived credential that allows a service account to create objects in a bucket:\n- At a minimum, you must grant a role to the service account that includes the`storage.objects.create`permission, such as the Storage Object Creator role (`roles/storage.objectCreator`). The Credential Access Boundary must also include this permission.\n- You can also grant a role that includes more permissions, such as the Storage Object Admin role (`roles/storage.objectAdmin`). The service account can use only the permissions that appear in both the role grant and the Credential Access Boundary.\nTo learn about predefined roles for Cloud Storage, see [Cloud Storage roles](/iam/docs/understanding-roles#cloud-storage-roles) .\n### Components of a Credential Access Boundary\nA Credential Access Boundary is an object that contains a list of . Each rule contains the following information:\n- The resource that the rule applies to.\n- The upper bound of the permissions that are available on that resource.\n- Optional: A condition that further restricts permissions. A condition includes the following:- A condition expression that evaluates to`true`or`false`. If it evaluates to`true`, access is allowed; otherwise, access is denied.\n- Optional: A title that identifies the condition.\n- Optional: A description with more information about the condition.If you apply a Credential Access Boundary to a short-lived credential, then the credential can access only the resources in the Credential Access Boundary. No permissions are available on other resources.\nA Credential Access Boundary can contain up to 10 access boundary rules. You can apply only one Credential Access Boundary to each short-lived credential.\nWhen represented as a JSON object, a Credential Access Boundary contains the following fields:\n| Fields                 | Fields.1                                                                                                                               |\n|:-----------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| accessBoundary               | object A wrapper for the Credential Access Boundary.                                                                                                                    |\n| accessBoundary.accessBoundaryRules[]         | object A list of access boundary rules to apply to a short-lived credential.                                                                                                              |\n| accessBoundary.accessBoundaryRules[].availablePermissions[]   | string A list that defines the upper bound on the available permissions for the resource. Each value is the identifier for an IAM predefined role or custom role, with the prefix inRole:. For example: inRole:roles/storage.objectViewer. Only the permissions in these roles will be available. Note: You cannot specify the names of permissions directly. Instead, specify a role that the permission appears in. If necessary, create a custom role that includes only the permissions you need.     |\n| accessBoundary.accessBoundaryRules[].availableResource     | string The full resource name of the Cloud Storage bucket that the rule applies to. Use the format //storage.googleapis.com/projects/_/buckets/bucket-name.                                                                                          |\n| accessBoundary.accessBoundaryRules[].availabilityCondition    | object Optional. A condition that restricts the availability of permissions to specific Cloud Storage objects. Use this field if you want to make permissions available for specific objects, rather than all objects in a Cloud Storage bucket.                                                                    |\n| accessBoundary.accessBoundaryRules[].availabilityCondition.expression | string A condition expression that specifies the Cloud Storage objects where permissions are available. To learn how to refer to specific objects in a condition expression, see resource.name attribute. Note: If any of your applications list Cloud Storage objects and use the prefix parameter to filter the response, you must take extra steps to prevent a conflict between the IAM condition expression and the Cloud Storage filter. For details, see Limit permissions when listing objects on this page. |\n| accessBoundary.accessBoundaryRules[].availabilityCondition.title  | string Optional. A short string that identifies the purpose of the condition.                                                                                                              |\n| accessBoundary.accessBoundaryRules[].availabilityCondition.description | string Optional. Details about the purpose of the condition.                                                                                                                  |\nFor examples in JSON format, see [Examples of Credential Access Boundaries](#examples) on this page.\n### Create an OAuth 2.0 access token\nBefore you create a downscoped short-lived credential, you must create a normal OAuth 2.0 access token. You can then exchange the normal credential for a downscoped credential. When you create the access token, use the OAuth 2.0 scope `https://www.googleapis.com/auth/cloud-platform` .\nTo create an access token for a service account, you can [complete the server-to-server OAuth 2.0 flow](https://developers.google.com/identity/protocols/OAuth2ServiceAccount) , or you can use the Service Account Credentials API to [generate an OAuth 2.0 access token](/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth) .\nTo create an access token for a user, see [Obtaining OAuth 2.0 access tokens](https://developers.google.com/identity/protocols/OAuth2WebServer#obtainingaccesstokens) . You can also use the [OAuth 2.0 Playground](https://developers.google.com/oauthplayground/) to create an access token for your own Google Account.\n### Exchange the OAuth 2.0 access token\nAfter you create an OAuth 2.0 access token, you can exchange the access token for a downscoped token that respects the Credential Access Boundary. This process typically involves a and a :\n- The is responsible for defining the Credential Access Boundary and exchanging an access token for a downscoped token.The token broker can use a supported authentication library to [exchange access tokens automatically](#exchange-credential-auto) , or it can call the Security Token Service to [exchange tokens manually](#exchange-credential-manual) .\n- The requests a downscoped access token from the token broker, then uses the downscoped access token to perform another action.The token consumer can use a supported authentication library to [automatically refresh access tokens](#exchange-credential-auto) before they expire. Alternatively, it can [refresh tokens manually](#exchange-credential-manual) , or it can allow tokens to expire without refreshing them.If you create the token broker and token consumer with one of the following languages, you can use Google's authentication library to exchange and refresh tokens automatically:\nFor Go, you can exchange and refresh tokens automatically with version v0.0.0-20210819190943-2bc19b11175f or later of the [golang.org/x/oauth2 package](https://pkg.go.dev/golang.org/x/oauth2) .\nTo check which version of this package you are using, run the following command in your application directory:\n```\ngo list -m golang.org/x/oauth2\n```\nThe following example shows how a token broker can generate downscoped tokens:\n [  auth/downscoping/token_broker.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/auth/downscoping/token_broker.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/auth/downscoping/token_broker.go) \n```\nimport (\u00a0 \u00a0 \u00a0 \u00a0 \"context\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"golang.org/x/oauth2\"\u00a0 \u00a0 \u00a0 \u00a0 \"golang.org/x/oauth2/google\"\u00a0 \u00a0 \u00a0 \u00a0 \"golang.org/x/oauth2/google/downscope\")// createDownscopedToken would be run on the token broker in order to generate// a downscoped access token that only grants access to objects whose name begins with prefix.// The token broker would then pass the newly created token to the requesting token consumer for use.func createDownscopedToken(bucketName string, prefix string) error {\u00a0 \u00a0 \u00a0 \u00a0 // bucketName := \"foo\"\u00a0 \u00a0 \u00a0 \u00a0 // prefix := \"profile-picture-\"\u00a0 \u00a0 \u00a0 \u00a0 ctx := context.Background()\u00a0 \u00a0 \u00a0 \u00a0 // A condition can optionally be provided to further restrict access permissions.\u00a0 \u00a0 \u00a0 \u00a0 condition := downscope.AvailabilityCondition{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Expression: \u00a0\"resource.name.startsWith('projects/_/buckets/\" + bucketName + \"/objects/\" + prefix + \"')\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Title: \u00a0 \u00a0 \u00a0 prefix + \" Only\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Description: \"Restricts a token to only be able to access objects that start with `\" + prefix + \"`\",\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Initializes an accessBoundary with one Rule which restricts the downscoped\u00a0 \u00a0 \u00a0 \u00a0 // token to only be able to access the bucket \"bucketName\" and only grants it the\u00a0 \u00a0 \u00a0 \u00a0 // permission \"storage.objectViewer\".\u00a0 \u00a0 \u00a0 \u00a0 accessBoundary := []downscope.AccessBoundaryRule{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AvailableResource: \u00a0 \u00a0\"//storage.googleapis.com/projects/_/buckets/\" + bucketName,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AvailablePermissions: []string{\"inRole:roles/storage.objectViewer\"},\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Condition: \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0&condition, // Optional\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // This Source can be initialized in multiple ways; the following example uses\u00a0 \u00a0 \u00a0 \u00a0 // Application Default Credentials.\u00a0 \u00a0 \u00a0 \u00a0 var rootSource oauth2.TokenSource\u00a0 \u00a0 \u00a0 \u00a0 // You must provide the \"https://www.googleapis.com/auth/cloud-platform\" scope.\u00a0 \u00a0 \u00a0 \u00a0 rootSource, err := google.DefaultTokenSource(ctx, \"https://www.googleapis.com/auth/cloud-platform\")\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"failed to generate rootSource: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // downscope.NewTokenSource constructs the token source with the configuration provided.\u00a0 \u00a0 \u00a0 \u00a0 dts, err := downscope.NewTokenSource(ctx, downscope.DownscopingConfig{RootSource: rootSource, Rules: accessBoundary})\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"failed to generate downscoped token source: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Token() uses the previously declared TokenSource to generate a downscoped token.\u00a0 \u00a0 \u00a0 \u00a0 tok, err := dts.Token()\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"failed to generate token: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Pass this token back to the token consumer.\u00a0 \u00a0 \u00a0 \u00a0 _ = tok\u00a0 \u00a0 \u00a0 \u00a0 return nil}\n```\nThe following example shows how a token consumer can use a refresh handler to automatically obtain and refresh downscoped tokens:\n [  auth/downscoping/token_consumer.go ](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/auth/downscoping/token_consumer.go) [View on GitHub](https://github.com/GoogleCloudPlatform/golang-samples/blob/HEAD/auth/downscoping/token_consumer.go) \n```\nimport (\u00a0 \u00a0 \u00a0 \u00a0 \"context\"\u00a0 \u00a0 \u00a0 \u00a0 \"fmt\"\u00a0 \u00a0 \u00a0 \u00a0 \"io\"\u00a0 \u00a0 \u00a0 \u00a0 \"io/ioutil\"\u00a0 \u00a0 \u00a0 \u00a0 \"golang.org/x/oauth2/google\"\u00a0 \u00a0 \u00a0 \u00a0 \"golang.org/x/oauth2/google/downscope\"\u00a0 \u00a0 \u00a0 \u00a0 \"cloud.google.com/go/storage\"\u00a0 \u00a0 \u00a0 \u00a0 \"golang.org/x/oauth2\"\u00a0 \u00a0 \u00a0 \u00a0 \"google.golang.org/api/option\")// A token consumer should define their own tokenSource. In the Token() method,// it should send a query to a token broker requesting a downscoped token.// The token broker holds the root credential that is used to generate the// downscoped token.type localTokenSource struct {\u00a0 \u00a0 \u00a0 \u00a0 ctx \u00a0 \u00a0 \u00a0 \u00a0context.Context\u00a0 \u00a0 \u00a0 \u00a0 bucketName string\u00a0 \u00a0 \u00a0 \u00a0 brokerURL \u00a0string}func (lts localTokenSource) Token() (*oauth2.Token, error) {\u00a0 \u00a0 \u00a0 \u00a0 var remoteToken *oauth2.Token\u00a0 \u00a0 \u00a0 \u00a0 // Usually you would now retrieve remoteToken, an oauth2.Token, from token broker.\u00a0 \u00a0 \u00a0 \u00a0 // This snippet performs the same functionality locally.\u00a0 \u00a0 \u00a0 \u00a0 accessBoundary := []downscope.AccessBoundaryRule{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AvailableResource: \u00a0 \u00a0\"//storage.googleapis.com/projects/_/buckets/\" + lts.bucketName,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 AvailablePermissions: []string{\"inRole:roles/storage.objectViewer\"},\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 rootSource, err := google.DefaultTokenSource(lts.ctx, \"https://www.googleapis.com/auth/cloud-platform\")\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return nil, fmt.Errorf(\"failed to generate rootSource: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 dts, err := downscope.NewTokenSource(lts.ctx, downscope.DownscopingConfig{RootSource: rootSource, Rules: accessBoundary})\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return nil, fmt.Errorf(\"failed to generate downscoped token source: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Token() uses the previously declared TokenSource to generate a downscoped token.\u00a0 \u00a0 \u00a0 \u00a0 remoteToken, err = dts.Token()\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return nil, fmt.Errorf(\"failed to generate token: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 return remoteToken, nil}// getObjectContents will read the contents of an object in Google Storage// named objectName, contained in the bucket \"bucketName\".func getObjectContents(output io.Writer, bucketName string, objectName string) error {\u00a0 \u00a0 \u00a0 \u00a0 // bucketName := \"foo\"\u00a0 \u00a0 \u00a0 \u00a0 // prefix := \"profile-picture-\"\u00a0 \u00a0 \u00a0 \u00a0 ctx := context.Background()\u00a0 \u00a0 \u00a0 \u00a0 thisTokenSource := localTokenSource{\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ctx: \u00a0 \u00a0 \u00a0 \u00a0ctx,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bucketName: bucketName,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 brokerURL: \u00a0\"yourURL.com/internal/broker\",\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Wrap the TokenSource in an oauth2.ReuseTokenSource to enable automatic refreshing.\u00a0 \u00a0 \u00a0 \u00a0 refreshableTS := oauth2.ReuseTokenSource(nil, thisTokenSource)\u00a0 \u00a0 \u00a0 \u00a0 // You can now use the token source to access Google Cloud Storage resources as follows.\u00a0 \u00a0 \u00a0 \u00a0 storageClient, err := storage.NewClient(ctx, option.WithTokenSource(refreshableTS))\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"failed to create the storage client: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer storageClient.Close()\u00a0 \u00a0 \u00a0 \u00a0 bkt := storageClient.Bucket(bucketName)\u00a0 \u00a0 \u00a0 \u00a0 obj := bkt.Object(objectName)\u00a0 \u00a0 \u00a0 \u00a0 rc, err := obj.NewReader(ctx)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"failed to retrieve the object: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 defer rc.Close()\u00a0 \u00a0 \u00a0 \u00a0 data, err := ioutil.ReadAll(rc)\u00a0 \u00a0 \u00a0 \u00a0 if err != nil {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return fmt.Errorf(\"could not read the object's contents: %w\", err)\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 // Data now contains the contents of the requested object.\u00a0 \u00a0 \u00a0 \u00a0 output.Write(data)\u00a0 \u00a0 \u00a0 \u00a0 return nil}\n```For Java, you can exchange and refresh tokens automatically with version 1.1.0 or later of the [com.google.auth:google-auth-library-oauth2-http artifact](https://search.maven.org/artifact/com.google.auth/google-auth-library-oauth2-http) .\nTo check which version of this artifact you are using, run the following Maven command in your application directory:\n```\nmvn dependency:list -DincludeArtifactIds=google-auth-library-oauth2-http\n```\nThe following example shows how a token broker can generate downscoped tokens:\n [  auth/src/main/java/com/google/cloud/auth/samples/DownscopingExample.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/auth/src/main/java/com/google/cloud/auth/samples/DownscopingExample.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/auth/src/main/java/com/google/cloud/auth/samples/DownscopingExample.java) \n```\npublic static AccessToken getTokenFromBroker(String bucketName, String objectPrefix)\u00a0 \u00a0 throws IOException {\u00a0 // Retrieve the source credentials from ADC.\u00a0 GoogleCredentials sourceCredentials =\u00a0 \u00a0 \u00a0 GoogleCredentials.getApplicationDefault()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .createScoped(\"https://www.googleapis.com/auth/cloud-platform\");\u00a0 // Initialize the Credential Access Boundary rules.\u00a0 String availableResource = \"//storage.googleapis.com/projects/_/buckets/\" + bucketName;\u00a0 // Downscoped credentials will have readonly access to the resource.\u00a0 String availablePermission = \"inRole:roles/storage.objectViewer\";\u00a0 // Only objects starting with the specified prefix string in the object name will be allowed\u00a0 // read access.\u00a0 String expression =\u00a0 \u00a0 \u00a0 \"resource.name.startsWith('projects/_/buckets/\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + bucketName\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"/objects/\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + objectPrefix\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \"')\";\u00a0 // Build the AvailabilityCondition.\u00a0 CredentialAccessBoundary.AccessBoundaryRule.AvailabilityCondition availabilityCondition =\u00a0 \u00a0 \u00a0 CredentialAccessBoundary.AccessBoundaryRule.AvailabilityCondition.newBuilder()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setExpression(expression)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .build();\u00a0 // Define the single access boundary rule using the above properties.\u00a0 CredentialAccessBoundary.AccessBoundaryRule rule =\u00a0 \u00a0 \u00a0 CredentialAccessBoundary.AccessBoundaryRule.newBuilder()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setAvailableResource(availableResource)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .addAvailablePermission(availablePermission)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setAvailabilityCondition(availabilityCondition)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .build();\u00a0 // Define the Credential Access Boundary with all the relevant rules.\u00a0 CredentialAccessBoundary credentialAccessBoundary =\u00a0 \u00a0 \u00a0 CredentialAccessBoundary.newBuilder().addRule(rule).build();\u00a0 // Create the downscoped credentials.\u00a0 DownscopedCredentials downscopedCredentials =\u00a0 \u00a0 \u00a0 DownscopedCredentials.newBuilder()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setSourceCredential(sourceCredentials)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setCredentialAccessBoundary(credentialAccessBoundary)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .build();\u00a0 // Retrieve the token.\u00a0 // This will need to be passed to the Token Consumer.\u00a0 AccessToken accessToken = downscopedCredentials.refreshAccessToken();\u00a0 return accessToken;}\n```\nThe following example shows how a token consumer can use a refresh handler to automatically obtain and refresh downscoped tokens:\n [  auth/src/main/java/com/google/cloud/auth/samples/DownscopingExample.java ](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/auth/src/main/java/com/google/cloud/auth/samples/DownscopingExample.java) [View on GitHub](https://github.com/GoogleCloudPlatform/java-docs-samples/blob/HEAD/auth/src/main/java/com/google/cloud/auth/samples/DownscopingExample.java) \n```\npublic static void tokenConsumer(final String bucketName, final String objectName)\u00a0 \u00a0 throws IOException {\u00a0 // You can pass an `OAuth2RefreshHandler` to `OAuth2CredentialsWithRefresh` which will allow the\u00a0 // library to seamlessly handle downscoped token refreshes on expiration.\u00a0 OAuth2CredentialsWithRefresh.OAuth2RefreshHandler handler =\u00a0 \u00a0 \u00a0 new OAuth2CredentialsWithRefresh.OAuth2RefreshHandler() {\u00a0 \u00a0 \u00a0 \u00a0 @Override\u00a0 \u00a0 \u00a0 \u00a0 public AccessToken refreshAccessToken() throws IOException {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // The common pattern of usage is to have a token broker pass the downscoped short-lived\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // access tokens to a token consumer via some secure authenticated channel.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // For illustration purposes, we are generating the downscoped token locally.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // We want to test the ability to limit access to objects with a certain prefix string\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // in the resource bucket. objectName.substring(0, 3) is the prefix here. This field is\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // not required if access to all bucket resources are allowed. If access to limited\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // resources in the bucket is needed, this mechanism can be used.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return getTokenFromBroker(bucketName, objectName.substring(0, 3));\u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 };\u00a0 // Downscoped token retrieved from token broker.\u00a0 AccessToken downscopedToken = handler.refreshAccessToken();\u00a0 // Create the OAuth2CredentialsWithRefresh from the downscoped token and pass a refresh handler\u00a0 // which will handle token expiration.\u00a0 // This will allow the consumer to seamlessly obtain new downscoped tokens on demand every time\u00a0 // token expires.\u00a0 OAuth2CredentialsWithRefresh credentials =\u00a0 \u00a0 \u00a0 OAuth2CredentialsWithRefresh.newBuilder()\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setAccessToken(downscopedToken)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .setRefreshHandler(handler)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 .build();\u00a0 // Use the credentials with the Cloud Storage SDK.\u00a0 StorageOptions options = StorageOptions.newBuilder().setCredentials(credentials).build();\u00a0 Storage storage = options.getService();\u00a0 // Call Cloud Storage APIs.\u00a0 Blob blob = storage.get(bucketName, objectName);\u00a0 String content = new String(blob.getContent());\u00a0 System.out.println(\u00a0 \u00a0 \u00a0 \"Retrieved object, \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + objectName\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \", from bucket,\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + bucketName\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + \", with content: \"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 + content);}\n```For Node.js, you can exchange and refresh tokens automatically with version 7.9.0 or later of the [google-auth-library package](https://github.com/googleapis/google-auth-library-nodejs) .\nTo check which version of this package you are using, run the following command in your application directory:\n```\nnpm list google-auth-library\n```\nThe following example shows how a token broker can generate downscoped tokens:\n [  auth/downscoping.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/auth/downscoping.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/auth/downscoping.js) \n```\n// Imports the Google Auth libraries.const {GoogleAuth, DownscopedClient} = require('google-auth-library');/**\u00a0* Simulates token broker generating downscoped tokens for specified bucket.\u00a0*\u00a0* @param bucketName The name of the Cloud Storage bucket.\u00a0* @param objectPrefix The prefix string of the object name. This is used\u00a0* \u00a0 \u00a0 \u00a0 \u00a0to ensure access is restricted to only objects starting with this\u00a0* \u00a0 \u00a0 \u00a0 \u00a0prefix string.\u00a0*/async function getTokenFromBroker(bucketName, objectPrefix) {\u00a0 const googleAuth = new GoogleAuth({\u00a0 \u00a0 scopes: 'https://www.googleapis.com/auth/cloud-platform',\u00a0 });\u00a0 // Define the Credential Access Boundary object.\u00a0 const cab = {\u00a0 \u00a0 // Define the access boundary.\u00a0 \u00a0 accessBoundary: {\u00a0 \u00a0 \u00a0 // Define the single access boundary rule.\u00a0 \u00a0 \u00a0 accessBoundaryRules: [\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 availableResource: `//storage.googleapis.com/projects/_/buckets/${bucketName}`,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Downscoped credentials will have readonly access to the resource.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 availablePermissions: ['inRole:roles/storage.objectViewer'],\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Only objects starting with the specified prefix string in the object name\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // will be allowed read access.\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 availabilityCondition: {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 expression:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"resource.name.startsWith('projects/_/buckets/\" +\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 `${bucketName}/objects/${objectPrefix}')`,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 \u00a0 },\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 },\u00a0 };\u00a0 // Obtain an authenticated client via ADC.\u00a0 const client = await googleAuth.getClient();\u00a0 // Use the client to create a DownscopedClient.\u00a0 const cabClient = new DownscopedClient(client, cab);\u00a0 // Refresh the tokens.\u00a0 const refreshedAccessToken = await cabClient.getAccessToken();\u00a0 // This will need to be passed to the token consumer.\u00a0 return refreshedAccessToken;}\n```\nThe following example shows how a token consumer can provide a refresh handler that automatically obtains and refreshes downscoped tokens:\n [  auth/downscoping.js ](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/auth/downscoping.js) [View on GitHub](https://github.com/GoogleCloudPlatform/nodejs-docs-samples/blob/HEAD/auth/downscoping.js) \n```\n// Imports the Google Auth and Google Cloud libraries.const {OAuth2Client} = require('google-auth-library');const {Storage} = require('@google-cloud/storage');/**\u00a0* Simulates token consumer generating calling GCS APIs using generated\u00a0* downscoped tokens for specified bucket.\u00a0*\u00a0* @param bucketName The name of the Cloud Storage bucket.\u00a0* @param objectName The name of the object in the Cloud Storage bucket\u00a0* \u00a0 \u00a0 \u00a0 \u00a0to read.\u00a0*/async function tokenConsumer(bucketName, objectName) {\u00a0 // Create the OAuth credentials (the consumer).\u00a0 const oauth2Client = new OAuth2Client();\u00a0 // We are defining a refresh handler instead of a one-time access\u00a0 // token/expiry pair.\u00a0 // This will allow the consumer to obtain new downscoped tokens on\u00a0 // demand every time a token is expired, without any additional code\u00a0 // changes.\u00a0 oauth2Client.refreshHandler = async () => {\u00a0 \u00a0 // The common pattern of usage is to have a token broker pass the\u00a0 \u00a0 // downscoped short-lived access tokens to a token consumer via some\u00a0 \u00a0 // secure authenticated channel. For illustration purposes, we are\u00a0 \u00a0 // generating the downscoped token locally. We want to test the ability\u00a0 \u00a0 // to limit access to objects with a certain prefix string in the\u00a0 \u00a0 // resource bucket. objectName.substring(0, 3) is the prefix here. This\u00a0 \u00a0 // field is not required if access to all bucket resources are allowed.\u00a0 \u00a0 // If access to limited resources in the bucket is needed, this mechanism\u00a0 \u00a0 // can be used.\u00a0 \u00a0 const refreshedAccessToken = await getTokenFromBroker(\u00a0 \u00a0 \u00a0 bucketName,\u00a0 \u00a0 \u00a0 objectName.substring(0, 3)\u00a0 \u00a0 );\u00a0 \u00a0 return {\u00a0 \u00a0 \u00a0 access_token: refreshedAccessToken.token,\u00a0 \u00a0 \u00a0 expiry_date: refreshedAccessToken.expirationTime,\u00a0 \u00a0 };\u00a0 };\u00a0 const storageOptions = {\u00a0 \u00a0 projectId: process.env.GOOGLE_CLOUD_PROJECT,\u00a0 \u00a0 authClient: oauth2Client,\u00a0 };\u00a0 const storage = new Storage(storageOptions);\u00a0 const downloadFile = await storage\u00a0 \u00a0 .bucket(bucketName)\u00a0 \u00a0 .file(objectName)\u00a0 \u00a0 .download();\u00a0 console.log(downloadFile.toString('utf8'));}\n```For Python, you can exchange and refresh tokens automatically with version 2.0.0 or later of the [google-auth package](https://github.com/googleapis/google-auth-library-python) .\nTo check which version of this package you are using, run the following command in the environment where the package is installed:\n```\npip show google-auth\n```\nThe following example shows how a token broker can generate downscoped tokens:\n [  auth/downscoping/snippets.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/auth/downscoping/snippets.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/auth/downscoping/snippets.py) \n```\nimport google.authfrom google.auth import downscopedfrom google.auth.transport import requestsdef get_token_from_broker(bucket_name, object_prefix):\u00a0 \u00a0 \"\"\"Simulates token broker generating downscoped tokens for specified bucket.\u00a0 \u00a0 Args:\u00a0 \u00a0 \u00a0 \u00a0 bucket_name (str): The name of the Cloud Storage bucket.\u00a0 \u00a0 \u00a0 \u00a0 object_prefix (str): The prefix string of the object name. This is used\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to ensure access is restricted to only objects starting with this\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 prefix string.\u00a0 \u00a0 Returns:\u00a0 \u00a0 \u00a0 \u00a0 Tuple[str, datetime.datetime]: The downscoped access token and its expiry date.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 # Initialize the Credential Access Boundary rules.\u00a0 \u00a0 available_resource = f\"//storage.googleapis.com/projects/_/buckets/{bucket_name}\"\u00a0 \u00a0 # Downscoped credentials will have readonly access to the resource.\u00a0 \u00a0 available_permissions = [\"inRole:roles/storage.objectViewer\"]\u00a0 \u00a0 # Only objects starting with the specified prefix string in the object name\u00a0 \u00a0 # will be allowed read access.\u00a0 \u00a0 availability_expression = (\u00a0 \u00a0 \u00a0 \u00a0 \"resource.name.startsWith('projects/_/buckets/{}/objects/{}')\".format(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 bucket_name, object_prefix\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 )\u00a0 \u00a0 availability_condition = downscoped.AvailabilityCondition(availability_expression)\u00a0 \u00a0 # Define the single access boundary rule using the above properties.\u00a0 \u00a0 rule = downscoped.AccessBoundaryRule(\u00a0 \u00a0 \u00a0 \u00a0 available_resource=available_resource,\u00a0 \u00a0 \u00a0 \u00a0 available_permissions=available_permissions,\u00a0 \u00a0 \u00a0 \u00a0 availability_condition=availability_condition,\u00a0 \u00a0 )\u00a0 \u00a0 # Define the Credential Access Boundary with all the relevant rules.\u00a0 \u00a0 credential_access_boundary = downscoped.CredentialAccessBoundary(rules=[rule])\u00a0 \u00a0 # Retrieve the source credentials via ADC.\u00a0 \u00a0 source_credentials, _ = google.auth.default()\u00a0 \u00a0 if source_credentials.requires_scopes:\u00a0 \u00a0 \u00a0 \u00a0 source_credentials = source_credentials.with_scopes(\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [\"https://www.googleapis.com/auth/cloud-platform\"]\u00a0 \u00a0 \u00a0 \u00a0 )\u00a0 \u00a0 # Create the downscoped credentials.\u00a0 \u00a0 downscoped_credentials = downscoped.Credentials(\u00a0 \u00a0 \u00a0 \u00a0 source_credentials=source_credentials,\u00a0 \u00a0 \u00a0 \u00a0 credential_access_boundary=credential_access_boundary,\u00a0 \u00a0 )\u00a0 \u00a0 # Refresh the tokens.\u00a0 \u00a0 downscoped_credentials.refresh(requests.Request())\u00a0 \u00a0 # These values will need to be passed to the token consumer.\u00a0 \u00a0 access_token = downscoped_credentials.token\u00a0 \u00a0 expiry = downscoped_credentials.expiry\u00a0 \u00a0 return (access_token, expiry)\n```\nThe following example shows how a token consumer can provide a refresh handler that automatically obtains and refreshes downscoped tokens:\n [  auth/downscoping/snippets.py ](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/auth/downscoping/snippets.py) [View on GitHub](https://github.com/GoogleCloudPlatform/python-docs-samples/blob/HEAD/auth/downscoping/snippets.py) \n```\nfrom google.cloud import storagefrom google.oauth2 import credentialsdef token_consumer(bucket_name, object_name):\u00a0 \u00a0 \"\"\"Tests token consumer readonly access to the specified object.\u00a0 \u00a0 Args:\u00a0 \u00a0 \u00a0 \u00a0 bucket_name (str): The name of the Cloud Storage bucket.\u00a0 \u00a0 \u00a0 \u00a0 object_name (str): The name of the object in the Cloud Storage bucket\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to read.\u00a0 \u00a0 \"\"\"\u00a0 \u00a0 # Create the OAuth credentials from the downscoped token and pass a\u00a0 \u00a0 # refresh handler to handle token expiration. We are passing a\u00a0 \u00a0 # refresh_handler instead of a one-time access token/expiry pair.\u00a0 \u00a0 # This will allow the consumer to obtain new downscoped tokens on\u00a0 \u00a0 # demand every time a token is expired, without any additional code\u00a0 \u00a0 # changes.\u00a0 \u00a0 def refresh_handler(request, scopes=None):\u00a0 \u00a0 \u00a0 \u00a0 # The common pattern of usage is to have a token broker pass the\u00a0 \u00a0 \u00a0 \u00a0 # downscoped short-lived access tokens to a token consumer via some\u00a0 \u00a0 \u00a0 \u00a0 # secure authenticated channel.\u00a0 \u00a0 \u00a0 \u00a0 # For illustration purposes, we are generating the downscoped token\u00a0 \u00a0 \u00a0 \u00a0 # locally.\u00a0 \u00a0 \u00a0 \u00a0 # We want to test the ability to limit access to objects with a certain\u00a0 \u00a0 \u00a0 \u00a0 # prefix string in the resource bucket. object_name[0:3] is the prefix\u00a0 \u00a0 \u00a0 \u00a0 # here. This field is not required if access to all bucket resources are\u00a0 \u00a0 \u00a0 \u00a0 # allowed. If access to limited resources in the bucket is needed, this\u00a0 \u00a0 \u00a0 \u00a0 # mechanism can be used.\u00a0 \u00a0 \u00a0 \u00a0 return get_token_from_broker(bucket_name, object_prefix=object_name[0:3])\u00a0 \u00a0 creds = credentials.Credentials(\u00a0 \u00a0 \u00a0 \u00a0 None,\u00a0 \u00a0 \u00a0 \u00a0 scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\u00a0 \u00a0 \u00a0 \u00a0 refresh_handler=refresh_handler,\u00a0 \u00a0 )\u00a0 \u00a0 # Initialize a Cloud Storage client with the oauth2 credentials.\u00a0 \u00a0 storage_client = storage.Client(credentials=creds)\u00a0 \u00a0 # The token broker has readonly access to the specified bucket object.\u00a0 \u00a0 bucket = storage_client.bucket(bucket_name)\u00a0 \u00a0 blob = bucket.blob(object_name)\u00a0 \u00a0 print(blob.download_as_bytes().decode(\"utf-8\"))\n```\nA token broker can use the Security Token Service API to exchange an access token for a downscoped access token. It can then provide the downscoped token to a token consumer.\nTo exchange the access token, use the following HTTP method and URL:\n```\nPOST https://sts.googleapis.com/v1/token\n```\nSet the `Content-Type` header in the request to `application/x-www-form-urlencoded` . Include the following fields in the request body:\n| Fields    | Fields.1                   |\n|:---------------------|:-----------------------------------------------------------------------------------|\n| grant_type   | string Use the value urn:ietf:params:oauth:grant-type:token-exchange.   |\n| options    | string A JSON-format Credential Access Boundary, encoded with percent encoding. |\n| requested_token_type | string Use the value urn:ietf:params:oauth:token-type:access_token.    |\n| subject_token  | string The OAuth 2.0 access token that you want to exchange.      |\n| subject_token_type | string Use the value urn:ietf:params:oauth:token-type:access_token.    |\nThe response is a JSON object that contains the following fields:\n| Fields   | Fields.1                                                                   |\n|:------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| access_token  | string A downscoped OAuth 2.0 access token that respects the Credential Access Boundary.                                               |\n| expires_in  | number The amount of time until the downscoped token expires, in seconds. This field is present only if the original access token represents a service account. When this field is not present, the downscoped token has the same time to expire as the original access token. |\n| issued_token_type | string Contains the value urn:ietf:params:oauth:token-type:access_token.                                                   |\n| token_type  | string Contains the value Bearer.                                                             |\nFor example, if a JSON-format Credential Access Boundary is stored in the file `./access-boundary.json` , you can use the following [curl](https://curl.haxx.se/) command to exchange the access token. Replace `` with the original access token:\n```\ncurl -H \"Content-Type:application/x-www-form-urlencoded\" \\\u00a0 \u00a0 -X POST \\\u00a0 \u00a0 https://sts.googleapis.com/v1/token \\\u00a0 \u00a0 -d \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange&subject_token_type=urn:ietf:params:oauth:token-type:access_token&requested_token_type=urn:ietf:params:oauth:token-type:access_token&subject_token=original-token\" \\\u00a0 \u00a0 --data-urlencode \"options=$(cat ./access-boundary.json)\"\n```\nThe response is similar to the following example:\n```\n{\u00a0 \"access_token\": \"ya29.dr.AbCDeFg-123456...\",\u00a0 \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\u00a0 \"token_type\": \"Bearer\",\u00a0 \"expires_in\": 3600}\n```\nWhen a token consumer requests a downscoped token, the token broker should respond with both the downscoped token and the number of seconds until it expires. To refresh the downscoped token, the consumer can request a downscoped token from the broker before the existing token expires.\n## What's next\n- Learn about [access control for Cloud Storage](/storage/docs/access-control) .\n- Create a [short-lived service account credential](/iam/docs/creating-short-lived-service-account-credentials) .\n- Create an OAuth 2.0 access token for a service account, using the [server-to-server OAuth 2.0 flow](https://developers.google.com/identity/protocols/OAuth2ServiceAccount) or the [Service Account Credentials API](/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth) .\n- Create an OAuth 2.0 access token [for a user](https://developers.google.com/identity/protocols/OAuth2WebServer#obtainingaccesstokens) .\n- See the [permissions in each predefined role](/iam/docs/understanding-roles#predefined_roles) .\n- Learn about [custom roles](/iam/docs/understanding-custom-roles) .", "guide": "IAM"}