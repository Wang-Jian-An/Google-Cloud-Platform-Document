{"title": "IAM - Understanding allow policies", "url": "https://cloud.google.com/iam/docs/policies", "abstract": "# IAM - Understanding allow policies\nYou can grant access to Google Cloud resources by using , also known as , which are attached to resources. You can attach only one allow policy to each resource. The allow policy controls access to the resource itself, as well as any descendants of that resource that [inherit the allow policy](#inheritance) .\nThis page shows allow policies in JSON format. You can also use the Google Cloud CLI to retrieve allow policies in YAML format.\n[](None)\n", "content": "## Policy structure\nAn allow policy is a collection of and metadata. A role binding specifies what access should be granted to a resource. It associates, or , one or more with a single IAM and any context-specific that change how and when the role is granted. The metadata includes additional information about the allow policy, such as an and to facilitate policy management.\nEach role binding can include the following fields:\n- A [principal](/iam/docs/overview#concepts_related_identity) , also known as a member or identity, which can be a user account, service account, Google group, or domain.\n- A [role](/iam/docs/understanding-roles) , which is a named collection of permissions that provide the ability to perform actions on Google Cloud resources.\n- A [condition](/iam/docs/conditions-overview) , which is an optional logic expression that further constrains the role binding based on attributes about the request, such as its origin, the target resource, and so on. Conditions are typically used to control whether access is granted based on the context for a request.If a role binding contains a condition, it is referred to as a .Some Google Cloud services do not accept conditions in allow policies. For a list of services and resource types that accept conditions, see [Resource types that accept conditional role bindings](/iam/docs/resource-types-with-conditional-roles) .\nChanges to a principal's access are [eventually consistent](https://wikipedia.org/wiki/Eventual_consistency) . This means that it takes time for access changes to propagate through the system. To learn how long it takes, on average, for access changes to propagate, see [Access change propagation](/iam/docs/access-change-propagation) .\n### Limits on principals\nEach allow policy can contain up to 1,500 principals.  For the purposes of this limit, IAM counts appearances of each principal in the allow policy's role bindings, as well as the principals that the allow policy [exempts from Data Accessaudit logging](/logging/docs/audit/configure-data-access#config-console-exempt) . It does deduplicate principals that appear in more than one role binding. For example, if an allow policy contains only role bindings for the principal `group:my-group@example.com` , and this principal appears in 50 role bindings, then you can add another 1,450 principals to the role bindings in the allow policy.\n**Note:** Each domain or Google group is counted as a single principal, regardless of the number of individual members in the domain or group.\nUp to 250 of the principals in an allow policy can be domains and Google groups.   For the purposes of this limit, domains and Google groups are counted as follows:\n- For domains, IAM countsappearances of each domain in the allow  policy's role bindings. It doesdeduplicate domains that appear in more than one  role binding. For example, if an allow policy contains only one domain,`domain:example.com`, and the domain appears in the allow policy  10 times, then you can add another 240  domains before you reach the limit.\n- For Google groups, each unique group is counted only once, regardless of how many times the  group appears in the allow policy. For example, if an allow policy contains only one group,`group:my-group@example.com`, and the group appears in the allow policy 10 times,  then you can add another 249 unique groups before you reach the  limit.If you use IAM Conditions, or if you grant roles to many principals with unusually long identifiers, then IAM might allow fewer principals in the allow policy.\n### Policy metadata\nThe metadata for an allow policy includes the following fields:\n- An`etag`field, which is used for concurrency control, and ensures that allow policies are updated consistently. For details, see [Using etags in a policy](#etag) on this page.\n- A`version`field, which specifies the schema version for a given allow policy. For details, see [Policy versions](#versions) on this page.\nFor organizations, folders, projects, and billing accounts, the allow policy can also contain an `auditConfig` field, which specifies the types of activity that generate [audit logs](/logging/docs/audit) for each service. To learn how to configure this part of an allow policy, see [Configuring Data Access audit logs](/logging/docs/audit/configure-data-access) .\n### Using etags in a policy\nWhen multiple systems try to write to the same allow policy at the same time, there is a risk that those systems might overwrite each other's changes. This risk exists because allow policies are updated using the [read-modify-writepattern](/iam/docs/granting-changing-revoking-access#programmatic) , which involves multiple operations:\n- **Reading** the existing allow policy\n- **Modifying** the allow policy\n- **Writing** the entire allow policy\nIf System A reads an allow policy, and System B immediately writes an updated version of that allow policy, then System A will not be aware of the changes from System B. When System A writes its own changes to the allow policy, System B's changes could be lost.\nTo help prevent this issue, Identity and Access Management (IAM) supports concurrency control through the use of an `etag` field in the allow policy. Every allow policy contains an `etag` field, and the value of this field changes each time an allow policy is updated. If an allow policy contains an `etag` field, but no role bindings, then the allow policy does not grant any IAM roles.\nThe `etag` field contains a value such as `BwUjMhCsNvY=` . When you update the allow policy, be sure to include the `etag` field in the updated allow policy. If the allow policy has been modified since you retrieved it, the `etag` value will not match, and the update will fail. For the REST API, you receive the HTTP status code `409 Conflict` , and the response body is similar to the following:\n```\n{\u00a0 \"error\": {\u00a0 \u00a0 \"code\": 409,\u00a0 \u00a0 \"message\": \"There were concurrent policy changes. Please retry the whole read-modify-write with exponential backoff.\",\u00a0 \u00a0 \"status\": \"ABORTED\"\u00a0 }}\n```\nIf you receive this error, retry the entire series of operations: read the allow policy again, modify it as needed, and write the updated allow policy. You should [perform retries automatically](/iam/docs/retry-strategy) , with exponential backoff, in any tools that you use to manage allow policies.\n### Example: Simple policy\nConsider the following allow policy that binds a principal to a role:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:jie@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/owner\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nIn the example above, `jie@example.com` is granted the [Owner basic role](/iam/docs/understanding-roles#basic-definitions) without any conditions. This role gives `jie@example.com` almost unlimited access.\n**Caution:** Basic roles include thousands of permissions across all Google Cloud services. In production environments, do not grant basic roles unless there is no alternative. Instead, grant the most limited [predefined roles](/iam/docs/understanding-roles#predefined_roles) or [custom roles](/iam/docs/understanding-custom-roles) that meet your needs.### Example: Policy with multiple role bindings\nConsider the following allow policy that contains more than one role binding. Each role binding grants a different role:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:jie@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/resourcemanager.organizationAdmin\"\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:raha@example.com\",\u00a0 \u00a0 \u00a0 \u00a0 \"user:jie@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/resourcemanager.projectCreator\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nIn the example above, Jie ( `jie@example.com` ) is granted the [OrganizationAdmin](/iam/docs/understanding-roles#resource-manager-roles) predefined role ( `roles/resourcemanager.organizationAdmin` ) in the first role binding. This role contains permissions for organizations, folders, and limited projects operations. In the second role binding, both Jie and Raha ( `raha@example.com` ) are granted the ability to create projects via the Project Creator role ( `roles/resourcemanager.projectCreator` ). Together, these role bindings grant fine-grained access to both Jie and Raha, and Jie is granted more access than Raha.\n### Example: Policy with conditional role binding\nConsider the following allow policy, which binds principals to a predefined role and uses a condition expression to constrain the role binding:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"group:prod-dev@example.com\",\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:prod-dev-example@appspot.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/appengine.deployer\",\u00a0 \u00a0 \u00a0 \"condition\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"title\": \"Expires_July_1_2022\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"description\": \"Expires on July 1, 2022\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"expression\":\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"request.time < timestamp('2022-07-01T00:00:00.000Z')\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"version\": 3}\n```\nIn this example, the `version` field is set to `3` , because the allow policy contains a condition expression. The role binding in the allow policy is conditional; it grants the role to the Google group `prod-dev@example.com` and the service account `prod-dev-example@appspot.gserviceaccount.com` , but only until July 1, 2022.\nFor details about the features that each allow policy version supports, see [Policy versions](#versions) on this page.\n### Example: Policy with conditional and unconditional role bindings\nConsider the following allow policy, which contains both conditional and unconditional role bindings for the same role:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:prod-dev-example@appspot.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 \u00a0],\u00a0 \u00a0 \u00a0 \u00a0\"role\": \"roles/appengine.deployer\"\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"group:prod-dev@example.com\",\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:prod-dev-example@appspot.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/appengine.deployer\",\u00a0 \u00a0 \u00a0 \"condition\": {\u00a0 \u00a0 \u00a0 \u00a0 \"title\": \"Expires_July_1_2022\",\u00a0 \u00a0 \u00a0 \u00a0 \"description\": \"Expires on July 1, 2022\",\u00a0 \u00a0 \u00a0 \u00a0 \"expression\":\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"request.time < timestamp('2022-07-01T00:00:00.000Z')\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"version\": 3}\n```\nIn this example, the service account `serviceAccount:prod-dev-example@appspot.gserviceaccount.com` is included in two role bindings for the same role. The first role binding does not have a condition. The second role binding has a condition that only grants the role until July 1, 2022.\nEffectively, this allow policy always grants the role to the service account. In IAM, conditional role bindings do not override role bindings with no conditions. If a principal is bound to a role, and the role binding does not have a condition, then the principal always has that role. Adding the principal to a conditional role binding for the same role has no effect.\nIn contrast, the Google group `group:prod-dev@example.com` is included only in the conditional role binding. Therefore, it has the role only before July 1, 2022.\n### Example: Policy that binds a role to a deleted principal\nConsider the following allow policy. This allow policy binds a role to a user, `donald@example.com` , whose account was deleted. As a result, the user's identifier now has a `deleted:` prefix:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"deleted:user:donald@example.com?uid=123456789012345678901\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/owner\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nIf you create a new user named `donald@example.com` , the allow policy's role bindings for the deleted user do not apply to the new user. This behavior prevents new users from inheriting roles that were granted to deleted users. If you want to grant roles to the new user, add the new user to the allow policy's role bindings, as shown in [Policies with deleted principals](#handle-deleted-members) on this page.\nIn addition, the user's name now includes the prefix `deleted:` and the suffix `?uid=` `` , where `` is the deleted user's unique numeric ID. In this example, instead of `user:donald@example.com` , the allow policy shows the identifier `deleted:user:donald@example.com?uid=123456789012345678901` .\nService accounts and groups have the same behavior as users. If you delete a service account or group, then view an allow policy that includes that principal, the deleted principal's name has the prefix `deleted:` and the suffix `?uid=` `` .\n## Default policies\nAll [resources that accept allow policies](/iam/docs/resource-types-with-policies) are created with default allow policies. Most resources' default allow policies are empty. However, some resources' default allow policies automatically contain certain role bindings. For example, when you create a new project, the allow policy for the project automatically has a role binding that grants you the Owner role ( `roles/owner` ) on the project.\nThese role bindings are created by the system, so the user doesn't need `getIamPolicy` or `setIamPolicy` permissions on the resource for the role bindings to be created.\nTo learn if a resource is created with an allow policy, refer to the resource's documentation.\n## Policy inheritance and the resource hierarchy\nGoogle Cloud resources are organized hierarchically, where the organization node is the root node in the hierarchy, then optionally folders, then projects. Most of other resources are created and managed under a project. Each resource has exactly one parent, except the organization. The organization, as the root node in the hierarchy, has no parent. See the [ResourceHierarchy](/resource-manager/docs/cloud-platform-resource-hierarchy) topic for more information.\nThe resource hierarchy is important to consider when setting an allow policy. When setting an allow policy at a higher level in the hierarchy, such as at the organization level, folder level, or project level, the granted access scope includes the resource level where this allow policy is attached to and all resources under that level. For example, an allow policy set at the organization level applies to the organization and all resources under the organization. Similarly, an allow policy set at the project level applies to the project and all resources in the project.\nis the term that describes how allow policies apply to resources beneath their level in the resource hierarchy. is the term that describes how all parent allow policies in the resource hierarchy are inherited for a resource. It is the union of the following:\n- The allow policy set on the resource\n- The allow policies set on all of resource's ancestry resource levels in the hierarchy\nEach new role binding (inherited from parent resources) that affect the resource's effective allow policy are evaluated independently. A specific access request to the resource is granted if any of the higher-level role bindings grant access to the request.\nIf a new role binding is introduced to any level of a resource's inherited allow policy, the access grant scope increases.\n[](None)\n### Example: Policy inheritance\nTo understand allow policy inheritance, consider a scenario where you grant a user, Raha, two different IAM roles at two different levels in the resource hierarchy.\nTo grant Raha a role at the **organization level** , you [set the following allowpolicy](/iam/docs/granting-changing-revoking-access#setting-policy) on your organization:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:raha@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/storage.objectViewer\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nThis allow policy grants Raha the Storage Object Viewer role ( `roles/storage.objectViewer` ), which contains `get` and `list` permissions for projects and Cloud Storage objects. Because you set the allow policy on your organization, Raha can use these permissions for all projects and all Cloud Storage objects in your organization.\nTo grant Raha a role at the **project level** , you [set the following allowpolicy](/iam/docs/granting-changing-revoking-access#setting-policy) on the project `myproject-123` :\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:raha@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/storage.objectCreator\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nThis allow policy grants Raha the Storage Object Creator role ( `roles/storage.objectCreator` ), which lets them create Cloud Storage objects. Because you set the allow policy on `myproject-123` , Raha can create Cloud Storage objects only in `myproject-123` .\nNow that there are two role bindings that grant Raha access to the target Cloud Storage objects under `myproject-123` , the following allow policies apply:\n- An allow policy at the organization level grants the ability to list and get all Cloud Storage objects under this organization.\n- An allow policy at the project level, for the project`myproject-123`, grants the ability to create objects within that project.\nThe table below summarizes Raha's effective policy:\n| Permissions granted via \"storage.objectViewer\" role at organization level        | Permissions granted via \"storage.objectCreator\" role at \"myproject-123\"    | Effective grant scope for Raha under \"myproject-123\"                   |\n|:-------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------|\n| resourcemanager.projects.get resourcemanager.projects.list storage.objects.get storage.objects.list | resourcemanager.projects.get resourcemanager.projects.list storage.objects.create | resourcemanager.projects.get resourcemanager.projects.list storage.objects.get storage.objects.list storage.objects.create |\n## Policy versions\nOver time, IAM might add new features that significantly add or change fields in the allow policy schema. To avoid breaking your existing integrations that rely on consistency in the allow policy structure, such changes are introduced in new allow policy schema versions.\nIf you are integrating with IAM for the first time, we recommend using the most recent allow policy schema version available at that time. Below, we'll discuss the different versions available and how to use each. We'll also describe how to specify your desired version and walk you through some troubleshooting scenarios.\nEvery existing allow policy specifies a `version` field as part of the allow policy's metadata. Consider the highlighted portion below:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:jie@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/owner\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nThis field specifies the of the allow policy. Each version of the allow policy contains a specific syntax schema that can be used by role bindings. The newer version can contain role bindings with the newer syntax schema that is unsupported by earlier versions. This field is not intended to be used for any purposes other than controlling the syntax schema for the allow policy.\n### Valid policy versions\nAllow policies can use the following allow policy versions:\n| Version | Description                                              |\n|----------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|   1 | The first version of the IAM syntax schema for policies. Supports binding one role to one or more principals. Does not support conditional role bindings.          |\n|   2 | Reserved for internal use.                                          |\n|   3 | Introduces the condition field in the role binding, which constrains the role binding via context-based and attribute-based rules. For more information, see the overview of IAM Conditions. |\n[](None)\n### Specifying a policy version when getting a policy\nFor the REST API and client libraries, when you [get an allow policy](/iam/docs/granting-changing-revoking-access#getting-policy) , we recommend that you specify an allow policy version in the request. When a request specifies an allow policy version, IAM assumes that the caller is aware of the features in that allow policy version and can handle them correctly.\n**Note:** When you use the Google Cloud console or the gcloud CLI, you do not need to specify an allow policy version. These tools specify the version automatically.\nIf the request does not specify an allow policy version, IAM assumes that the caller wants a version `1` allow policy.\nWhen you get an allow policy, IAM checks the allow policy version in the request, or the default version if the request did not specify a version. IAM also checks the allow policy for fields that are not supported in a version `1` allow policy. It uses this information to decide what type of response to send:\n- If the allow policy does not contain any conditions, then IAM always returns a version`1`allow policy, regardless of the version number in the request.\n- If the allow policy contains conditions, and the caller requested a version`3`allow policy, then IAM returns a version`3`allow policy that includes the conditions. For an example, see [scenario 1](#get-scenario-1) on this page.\n- If the allow policy contains conditions, and the caller requested a version `1` allow policy or did not specify a version, then IAM returns a version `1` allow policy.For role bindings that include a condition, IAM appends the string `_withcond_` to the role name, followed by a hash value; for example, `roles/iam.serviceAccountAdmin_withcond_2b17cc25d2cd9e2c54d8` . The condition itself is not present. For an example, see [scenario 2](#get-scenario-2) on this page.Suppose you call the following REST API method to get the allow policy for a project:\n```\nPOST https://cloudresourcemanager.googleapis.com/v1/projects/project-id:getIamPolicy\n```\nThe request body contains the following text:\n```\n{\u00a0 \"options\": {\u00a0 \u00a0 \"requestedPolicyVersion\": 3\u00a0 }}\n```\nThe response contains the project's allow policy. If the allow policy contains at least one conditional role binding, its `version` field is set to `3` :\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:user@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.securityReviewer\",\u00a0 \u00a0 \u00a0 \"condition\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"title\": \"Expires_July_1_2022\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"description\": \"Expires on July 1, 2022\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"expression\": \"request.time < timestamp('2022-07-01T00:00:00.000Z')\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"version\": 3}\n```\nIf the allow policy does not contain conditional role bindings, its `version` field is set to `1` , even though the request specified version `3` :\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:user@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.securityReviewer\",\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"version\": 1}\n```\nSuppose you call the following REST API method to get the allow policy for a project:\n```\nPOST https://cloudresourcemanager.googleapis.com/v1/projects/project-id:getIamPolicy\n```\nThe request body is empty; it does not specify a version number. As a result, IAM uses the default allow policy version, `1` .\nThe allow policy contains a conditional role binding. Because the allow policy version is `1` , the condition does not appear in the response. To indicate that the role binding uses a condition, IAM appends the string `_withcond_` to the role name, followed by a hash value:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:user@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.securityReviewer_withcond_58e135cabb940ad9346c\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"version\": 1}\n```\n[](None)\n### Specifying a policy version when setting a policy\nWhen you [set an allow policy](/iam/docs/granting-changing-revoking-access#setting-policy) , we recommend that you specify an allow policy version in the request. When a request specifies an allow policy version, IAM assumes that the caller is aware of the features in that allow policy version and can handle them correctly.\n**Note:** When you use the Google Cloud console or the gcloud CLI, you do not need to specify an allow policy version. These tools specify the version automatically.\nIf the request does not specify an allow policy version, IAM accepts only the fields that can appear in a version `1` allow policy. As a best practice, do not change conditional role bindings in a version `1` allow policy; because the allow policy does not show the condition for each role binding, you do not know when or where the role binding is actually granted. Instead, get the version `3` representation of the allow policy, which shows the condition for each role binding, and use that representation to update the role bindings.\n**Important:** If you use IAM Conditions, always specify allow policy version `3` , and always include the `etag` field when you use a client library or the REST API to set an allow policy. If you omit the `etag` field, then IAM allows you to overwrite a version `3` allow policy with a version `1` allow policy, which deletes all of the conditions from the allow policy.\nSuppose you use the REST API to get an allow policy, and you specify version `3` in the request. The response contains the following allow policy, which uses version `3` :\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:raha@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/storage.admin\",\u00a0 \u00a0 \u00a0 \"condition\": {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"title\": \"Weekday_access\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"description\": \"Monday thru Friday access only in America/Chicago\",\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"expression\": \"request.time.getDayOfWeek('America/Chicago') >= 1 && request.time.getDayOfWeek('America/Chicago') <= 5\"\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 3}\n```\nYou decide that `raha@example.com` should have the Storage Admin role ( `roles/storage.admin` ) throughout the week, not just on weekdays. You remove the condition from the role binding and send a REST API request to set the allow policy; once again, you specify version `3` in the request:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:raha@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/storage.admin\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 3}\n```\nThe response contains the updated allow policy:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:raha@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/storage.admin\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwWd8I+ZUAQ=\",\u00a0 \"version\": 1}\n```\nThe allow policy in the response uses version `1` , even though the request specified version `3` , because the allow policy uses only fields that are supported in a version `1` allow policy.\n## Policies with deleted principals\nIf a role binding in an allow policy includes a deleted principal, and you add a role binding for a new principal with the same name, the role binding is always applied to the new principal.\nFor example, consider this allow policy that includes a role binding to a deleted user, `donald@example.com` , and a deleted service account, `my-service-account@project-id.iam.gserviceaccount.com` . As a result, the identifier for each principal has a `deleted:` prefix:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"deleted:serviceAccount:my-service-account@project-id.iam.gserviceaccount.com?uid=123456789012345678901\",\u00a0 \u00a0 \u00a0 \u00a0 \"deleted:user:donald@example.com?uid=234567890123456789012\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/owner\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nSuppose you create a new user that is also named `donald@example.com` , and you want to grant the Project Creator role ( `roles/resourcemanager.projectCreator` ), which enables principals to create Google Cloud projects, to the new user. To grant the role to the new user, update the allow policy as shown in this example:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"deleted:serviceAccount:my-service-account@project-id.iam.gserviceaccount.com?uid=123456789012345678901\",\u00a0 \u00a0 \u00a0 \u00a0 \"deleted:user:donald@example.com?uid=234567890123456789012\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/owner\"\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:donald@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/resourcemanager.projectCreator\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\nTo make it easier to audit your IAM allow policies, you can also remove the deleted user from the role binding to the Owner role:\n```\n{\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"deleted:serviceAccount:my-service-account@project-id.iam.gserviceaccount.com?uid=123456789012345678901\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/owner\"\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:donald@example.com\"\u00a0 \u00a0 \u00a0 ],\u00a0 \u00a0 \u00a0 \"role\": \"roles/resourcemanager.projectCreator\"\u00a0 \u00a0 }\u00a0 ],\u00a0 \"etag\": \"BwUjMhCsNvY=\",\u00a0 \"version\": 1}\n```\n**Note:** If you remove a deleted principal from a role binding, then undelete the principal, the principal is not added back to the role binding.\n## Policy best practices\nThe following best practices apply to organizations with many Google Cloud users:\n- When managing multiple user accounts with the same access configurations, use Google groups instead. Put each individual user account into the group, and grant the intended roles to the group instead of individual user accounts.\n- **Permissions granted at the organization level** : Carefully consider which principals are granted access permissions at the organization level. For most organizations, only a few specific teams (such as Security and Network teams) should be granted access at this level of the resource hierarchy.\n- **Permissions granted at the folder levels** : Consider reflecting your organization's operation structure by using tiers of folders, where each parent/child folder can be configured with different sets of access grants that are aligned with business and operation needs. For example, a parent folder might reflect a department, one of its child folder might reflect resource access and operation by a group, and another child folder might reflect a small team. Both of these two folders might contain projects for their team's operation needs. Using folders in this way can ensure proper access separation, while respecting allow policies inherited from parent folder(s) and the organization. This practice requires less maintenance of allow policies when creating and managing Google Cloud resources.\n- **Permissions granted at the project level** : Grant role bindings at the project level when necessary to follow the principle of least privilege. For example, if a principal needs access to 3 of the 10 projects in a folder, you should grant access to each of the 3 projects individually; in contrast, if you granted a role on the folder, the principal would gain access that they don't need to another 7 projects.Alternatively, you can use [IAM Conditions](/iam/docs/conditions-overview) to grant roles at the organization or folder level, but only for a subset of folders or projects.## What's next\n- Learn how to [troubleshoot allow policies that contain the string withcond](/iam/docs/troubleshooting-withcond) in role names.\n- Find out how to [manage the role bindings in an allow policy](/iam/docs/granting-changing-revoking-access#modifying-policy) .\n- Get an overview of [IAM Conditions](/iam/docs/conditions-overview) , which use version`3`allow policies.\n- Explore the [Policy Intelligence tools](/iam/docs/policy-intelligence-tools) , which help you understand and manage your allow policies to proactively improve your security configuration.\n- Use the Cloud Asset API to [search allow policies](/asset-inventory/docs/searching-iam-policies) .\n- Use the Cloud Asset API to [view effective allow policies](/asset-inventory/docs/view-effective-iam-policies) .", "guide": "IAM"}