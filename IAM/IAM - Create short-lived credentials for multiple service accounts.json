{"title": "IAM - Create short-lived credentials for multiple service accounts", "url": "https://cloud.google.com/iam/docs/create-short-lived-credentials-delegated", "abstract": "# IAM - Create short-lived credentials for multiple service accounts\nThis page explains how to create short-lived credentials for a service account based on a delegation chain of service accounts. You can use this approach when you need to issue a series of token generation calls to obtain a token with the permissions you need to accomplish your task.\nAfter you get a short-lived credential, you can use it to [impersonate theservice account](/iam/docs/service-account-impersonation) .\nIf you can generate a token with the required permissions with a single token generation call, you should [create short-lived credentials for that serviceaccount directly](/iam/docs/create-short-lived-credentials-direct) .\n", "content": "## About creating short-lived credentials\nDepending on the type of token you create, you can use short-lived credentials to authenticate calls to Google APIs, third-party APIs, or applications that require ID tokens. Short-lived credentials have a limited lifetime, with durations of just a few hours or shorter, and are not automatically refreshed. Short-lived service account credentials are useful for scenarios where you need to grant limited access to resources for trusted service accounts. They also create less risk than long-lived credentials, such as service account keys.\nYou can create the following types of short-lived credentials for a service account:\n- OAuth 2.0 access tokensAccess tokens are accepted for authentication by most Google APIs. When you generate an access token for a service account, the access token comes without a refresh token, which means that when the token expires, you must repeat the token creation process to generate a new one.For more information, see [Access tokens](/docs/authentication/token-types#access) .\n- OpenID Connect (OIDC) ID tokensID tokens follow the [OpenID Connect (OIDC) specification](https://openid.net/connect/) . ID tokens are accepted by a limited number of services and applications.For more information, see [ID tokens](/docs/authentication/token-types#id) and [Authentication for applications hosted on Cloud Run or Cloud Functions](/docs/authentication/use-cases#run-functions) .\n- Self-signed JSON Web Tokens (JWTs)You can use self-signed JWTs to authenticate to some Google APIs without getting an access token from the Authorization Server. APIs deployed with API Gateway require them.\n- Self-signed binary blobsSelf-signed blobs are useful in scenarios when you need to securely transmit arbitrary binary data, usually for authentication purposes.## Delegated request flow\nThe delegated request flow lets you chain [direct requests](/iam/docs/create-short-lived-credentials-direct) using a single request, instead of needing to make several direct requests in sequence. In this flow, the request for a service account credential is delegated to one or more service accounts in a before generating a credential for the final service account. The resulting credential only represents the final service account, and not the intermediate service accounts in the delegation chain.\nEach service account in the delegation chain must have the required permissions on the next service account in the chain, so that it can pass along the request.\nIf one service account provides all of the permissions you need, you should use the simpler flow described in [Create short-lived credentials from a service account](/iam/docs/create-short-lived-credentials-direct) .\n## Before you begin\n- Enable the IAM and Service Account Credentials APIs. [Enable the APIs](https://console.cloud.google.com/flows/enableapi?apiid=iam.googleapis.com,iamcredentials.googleapis.com&redirect=https://console.cloud.google.com) \n- Understand [IAM service accounts](/iam/docs/service-accounts) \n- If you haven't already, enable billing and the IAM API by following the steps in the [quickstart](/iam/docs/grant-role-console#before-you-begin) .\n- Identify the service accounts you will use in your delegation chain.You can [create a new service account](/iam/docs/creating-managing-service-accounts#creating) and include it in the delegation chain if needed.## Provide required permissions\nA [delegated request](#sa-credentials-delegated) involves more than two identities: the caller, one or more service accounts in a , and finally the service account for which a credential is created. In this flow, consider the following identities:\n- Service Account 1 (``), the caller who issues a request for the short-lived credentials.\n- Service Account 2 (``), an intermediary service account that will delegate the initial request to``. This account only passes on the request\u2014it doesn't give``or``any additional access.\n- Service Account 3 (``), the limited-privilege account for whom the credential is created.\nTo allow delegation, each account must grant the Service Account Token Creator role ( `roles/iam.serviceAccountTokenCreator` ) to the previous account in the chain.\nIn this particular example, `` must be granted the Service Account Token Creator role ( `roles/iam.serviceAccountTokenCreator` ) on `` . This is an example of the `` service account being treated as a resource: when you grant the role on `` , you update its allow policy the same way that you would update any other resource.\nIn this example flow, there is only one intermediary service account. To delegate access through more than one service account, you must also assign this role to any other service account in the chain.\nNext, `` must also be granted the Service Account Token Creator role ( `roles/iam.serviceAccountTokenCreator` ) on `` . This allows `` to create short-lived credentials for `` .\nThe following steps use the REST API to grant the roles. However, you can also use the Google Cloud console or the [gcloud CLI](/sdk/gcloud) .\n**First, get the allow policy for SA_2 (theintermediary service account):** \nThe ` [serviceAccounts.getIamPolicy](/iam/docs/reference/rest/v1/projects.serviceAccounts/getIamPolicy) ` method gets a service account's allow policy.\nBefore using any of the request data, make the following replacements:- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: The name of Service Account 2.\n- ``: The policy version to be returned. Requests should specify the most recent policy version, which is policy version 3. See [Specifyinga policy version when getting a policy](/iam/docs/policies#specifying-version-get) for details.\nHTTP method and URL:\n```\nPOST https://iam.googleapis.com/v1/projects/PROJECT_ID/serviceAccounts/SA_2@PROJECT_ID.iam.gserviceaccount.com:getIamPolicy\n```\nRequest JSON body:\n```\n{\n \"options\": {\n \"requestedPolicyVersion\": POLICY_VERSION\n }\n}\n```\nTo send your request, expand one of these options:\nYou should receive a JSON response similar to the following:\n```\n{\n \"version\": 1,\n \"etag\": \"BwWKmjvelug=\",\n \"bindings\": [ {\n  \"role\": \"roles/serviceAccountAdmin\",\n  \"members\": [  \"user:admin@example.com\"\n  ]\n }\n ]\n}\n```\nIf you have not granted a role to the service account, the response contains only an `etag` value. Include that `etag` value in the next step.\n **Next, modify the allow policy to grant SA_1 theService Account Token Creator role** ( `roles/iam.serviceAccountTokenCreator` ).\nFor example, to modify the sample response from the previous step, add the following:\n```\n{\u00a0 \"version\": 1,\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/serviceAccountAdmin\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:admin@example.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.serviceAccountTokenCreator\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:SA_1@PROJECT_ID.iam.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 }\u00a0 ]}\n```\n **Then, write the updated allow policy for SA_2:** \nThe ` [serviceAccounts.setIamPolicy](/iam/docs/reference/rest/v1/projects.serviceAccounts/setIamPolicy) ` method sets an updated allow policy for the service account.\nBefore using any of the request data, make the following replacements:- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: The name of Service Account 2.\n- `` : A JSON representation of the policy that you want to set. For more information about the format of a policy, see the [Policy reference](/iam/docs/reference/rest/v1/Policy) .For example, to set the allow policy shown in the previous step, replace `` with the following:```\n{\u00a0 \"version\": 1,\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/serviceAccountAdmin\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:admin@example.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.serviceAccountTokenCreator\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:SA_1@PROJECT_ID.iam.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 }\u00a0 ]}\n```\nHTTP method and URL:\n```\nPOST https://iam.googleapis.com/v1/projects/PROJECT_ID/serviceAccounts/SA_2@PROJECT_ID.iam.gserviceaccount.com:setIamPolicy\n```\nRequest JSON body:\n```\n{\n \"policy\": POLICY\n}\n```\nTo send your request, expand one of these options:\nThe response contains the updated allow policy.\n **Note:** If you treat policies as code and store them in a version-control system, you should store the policy that is returned, not the policy that you sent in the request. **Now, get the allow policy for SA_3 (the serviceaccount for whom the credential is created):** \nThe ` [serviceAccounts.getIamPolicy](/iam/docs/reference/rest/v1/projects.serviceAccounts/getIamPolicy) ` method gets a service account's allow policy.\nBefore using any of the request data, make the following replacements:- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: The name of Service Account 3.\n- ``: The policy version to be returned. Requests should specify the most recent policy version, which is policy version 3. See [Specifyinga policy version when getting a policy](/iam/docs/policies#specifying-version-get) for details.\nHTTP method and URL:\n```\nPOST https://iam.googleapis.com/v1/projects/PROJECT_ID/serviceAccounts/SA_3@PROJECT_ID.iam.gserviceaccount.com:getIamPolicy\n```\nRequest JSON body:\n```\n{\n \"options\": {\n \"requestedPolicyVersion\": POLICY_VERSION\n }\n}\n```\nTo send your request, expand one of these options:\nYou should receive a JSON response similar to the following:\n```\n{\n \"version\": 1,\n \"etag\": \"BwWKmjvelug=\",\n \"bindings\": [ {\n  \"role\": \"roles/serviceAccountAdmin\",\n  \"members\": [  \"user:admin@example.com\"\n  ]\n }\n ]\n}\n```\nIf you have not assigned a role to the service account, the response contains only an `etag` value. Include that `etag` value in the next step.\n **Next, modify the allow policy to grant SA_2 theService Account Token Creator role** ( `roles/iam.serviceAccountTokenCreator` ).\nFor example, to modify the sample response from the previous step, add the following:\n```\n{\u00a0 \"version\": 1,\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/serviceAccountAdmin\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:admin@example.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.serviceAccountTokenCreator\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:SA_2@PROJECT_ID.iam.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 }\u00a0 ]}\n```\n **Finally, write the updated allow policy:** \nThe ` [serviceAccounts.setIamPolicy](/iam/docs/reference/rest/v1/projects.serviceAccounts/setIamPolicy) ` method sets an updated allow policy for the service account.\nBefore using any of the request data, make the following replacements:- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: The name of Service Account 3.\n- `` : A JSON representation of the policy that you want to set. For more information about the format of a policy, see the [Policy reference](/iam/docs/reference/rest/v1/Policy) .For example, to set the allow policy shown in the previous step, replace `` with the following:```\n{\u00a0 \"version\": 1,\u00a0 \"etag\": \"BwWKmjvelug=\",\u00a0 \"bindings\": [\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/serviceAccountAdmin\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"user:admin@example.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 },\u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \"role\": \"roles/iam.serviceAccountTokenCreator\",\u00a0 \u00a0 \u00a0 \"members\": [\u00a0 \u00a0 \u00a0 \u00a0 \"serviceAccount:SA_2@PROJECT_ID.iam.gserviceaccount.com\"\u00a0 \u00a0 \u00a0 ]\u00a0 \u00a0 }\u00a0 ]}\n```\nHTTP method and URL:\n```\nPOST https://iam.googleapis.com/v1/projects/PROJECT_ID/serviceAccounts/SA_3@PROJECT_ID.iam.gserviceaccount.com:setIamPolicy\n```\nRequest JSON body:\n```\n{\n \"policy\": POLICY\n}\n```\nTo send your request, expand one of these options:\nThe response contains the updated allow policy.\n **Note:** If you treat policies as code and store them in a version-control system, you should store the policy that is returned, not the policy that you sent in the request.\n## Request short-lived credentials\nAfter you have granted the appropriate roles to each identity, you can request short-lived credentials for the desired service account. The following credential types are supported:\n- [OAuth 2.0 access tokens](#sa-credentials-oauth) \n- [OpenID Connect ID tokens](#sa-credentials-oidc) \n- [Self-signed JSON Web Tokens (JWTs)](#sa-credentials-jwt) \n- [Self-signed binary objects (blobs)](#sa-credentials-blob) \nTo understand how to specify a delegation chain for these requests, see the [Specifying a delegation chain](#sa-credentials-delegated-chain) section on this page.\n### Generate an OAuth 2.0 access token\nBy default, OAuth 2.0 access tokens are valid for a maximum of 1 hour (3,600 seconds). However, you can extend the maximum lifetime for these tokens to 12 hours (43,200 seconds). To do so, identify the service accounts that need an extended lifetime for tokens, then [add these service accounts to an organization policy](/resource-manager/docs/organization-policy/restricting-service-accounts#setting_a_list_constraint) that includes the `constraints/iam.allowServiceAccountCredentialLifetimeExtension` list constraint. You can then specify a lifetime up to 43,200 seconds when you create a token for these service accounts.\nTo generate an OAuth 2.0 access token for a service account, do the following:\nThe Service Account Credentials API's ` [serviceAccounts.generateAccessToken](/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateAccessToken) ` method generates an OAuth 2.0 access token for a service account.\nBefore using any of the request data, make the following replacements:- ``: The name of the service account that you want to create a  token for.\n- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: If you are using a [delegated request flow](#sa-credentials-delegated) , see [Specifying a delegation chain](#sa-credentials-delegated-chain) on this page. If you are using a [direct request flow](#sa-credentials-direct) with no delegation, omit the`delegates`field in the request body.\n- `` : The amount of time until the access token expires, in  seconds. For example, `300s` .By default, the maximum token lifetime is 1 hour  (3,600 seconds). To extend the maximum lifetime for these tokens to  12 hours (43,200 seconds), [  add the service account to an organization policy](/resource-manager/docs/organization-policy/restricting-service-accounts#setting_a_list_constraint) that includes the `constraints/iam.allowServiceAccountCredentialLifetimeExtension` list constraint.\nHTTP method and URL:\n```\nPOST https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/SA_NAME@PROJECT_ID.iam.gserviceaccount.com:generateAccessToken\n```\nRequest JSON body:\n```\n{\n \"delegates\": [ DELEGATES\n ],\n \"scope\": [ \"https://www.googleapis.com/auth/cloud-platform\"\n ],\n \"lifetime\": \"LIFETIME\"\n}\n```\nTo send your request, expand one of these options:\nIf the `generateAccessToken` request was successful, the response body contains an OAuth 2.0 access token and an expiration time. The `accessToken` can then be used to authenticate a request on behalf of the service account until the `expireTime` has been reached:\n```\n{\n \"accessToken\": \"eyJ0eXAi...NiJ9\",\n \"expireTime\": \"2020-04-07T15:01:23.045123456Z\"\n}\n```\n### Generate OpenID Connect ID tokens\nOpenID Connect ID tokens are valid for 1 hour (3,600 seconds). To generate an ID token for a service account, do the following:\nThe Service Account Credentials API's ` [serviceAccounts.generateIdToken](/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken) ` method generates an OIDC ID token for a service account.\nBefore using any of the request data, make the following replacements:- ``: The email address of the privilege-bearing service account for  which the short-lived token is created.\n- ``: The audience for the token, usually the URL of the  application or service that the token will be used to access.\nHTTP method and URL:\n```\nPOST https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/PRIV_SA:generateIdToken\n```\nRequest JSON body:\n```\n{\n \"audience\": \"AUDIENCE_NAME\",\n \"includeEmail\": \"true\"\n}\n```\nTo send your request, expand one of these options:\nIf the `generateId` request was successful, the response body contains an ID token that is valid for 1 hour. The `token` can then be used to authenticate a request on behalf of the service account:\n```\n{\n \"token\": \"eyJ0eXAi...NiJ9\"\n}\n```\n### Create a self-signed JSON Web Token (JWT)\nSelf-signed JSON Web Tokens (JWTs) are useful in a variety of scenarios, such as:\n- Authenticating a call to a Google API as described in [Google's Authentication Guide](https://developers.google.com/identity/protocols/OAuth2ServiceAccount#jwt-auth) .\n- Securely communicating between Google Cloud or non-Google services, such as App Engine applications. In this scenario, one application can sign a token that can be verified by another application for authentication purposes.\n- Treating a service account as an identity provider by signing a JWT that contains arbitrary claims about a user, account, or device.\nTo generate a self-signed JWT for a service account, do the following:\nThe Service Account Credentials API's ` [serviceAccounts.signJwt](/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signJwt) ` method signs a JWT using a service account's system-managed private key.\nBefore using any of the request data, make the following replacements:- ``: The name of the service account that you want to create a  token for.\n- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: If you are using a [delegated request flow](#sa-credentials-delegated) , see [Specifying a delegation chain](#sa-credentials-delegated-chain) on this page. If you are using a [direct request flow](#sa-credentials-direct) with no delegation, omit the`delegates`field in the request body.\n- `` : The JWT payload to sign, which is a JSON object that  contains a JWT Claims Set. Include the claims that are necessary for your desired use case and  to meet the validation requirements for the service you are calling. If you are calling a  Google API, see [  Google's Authentication Guide](https://developers.google.com/identity/protocols/OAuth2ServiceAccount#jwt-auth) for claim requirements.The `exp` (expiration time) claim must be no more than 12 hours in the future.  If you are calling a Google API, the `exp` claim must be set no more than 1 hour in  the future.The following example payload contains claims to call a Google API, where `` is an integer timestamp representing the expiration time:```\n{ \\\"iss\\\": \\\"SA_NAME@PROJECT_ID.iam.gserviceaccount.com\\\", \\\"sub\\\": \\\"SA_NAME@PROJECT_ID.iam.gserviceaccount.com\\\", \\\"aud\\\": \\\"https://firestore.googleapis.com/\\\", \\\"iat\\\": 1529350000, \\\"exp\\\": EXP }\n```\nHTTP method and URL:\n```\nPOST https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/SA_NAME@PROJECT_ID.iam.gserviceaccount.com:signJwt\n```\nRequest JSON body:\n```\n{\n \"delegates\": [ DELEGATES\n ],\n \"payload\": \"JWT_PAYLOAD\"\n}\n```\nTo send your request, expand one of these options:\nIf the `signJwt` request was successful, the response body contains a signed JWT and the signing key ID that was used to sign the JWT. You can use the `signedJwt` value as a bearer token to directly authenticate a request on behalf of the service account. The token is valid up to the expiration time specified in the request:\n```\n{\n \"keyId\": \"42ba1e...fc0a\",\n \"signedJwt\": \"eyJ0eXAi...NiJ9\"\n}\n```\n### Create a self-signed blob\nSelf-signed blobs are useful in scenarios when you need to securely transmit arbitrary binary data, usually for authentication purposes. For example, if you want to use a custom protocol/token type (not JWT), you can include that data in a signed blob for use by a downstream service.\nTo generate a self-signed blob for a service account, do the following:\nThe Service Account Credentials API's ` [serviceAccounts.signBlob](/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob) ` method signs a blob using a service account's system-managed private key.\nBefore using any of the request data, make the following replacements:- ``: The name of the service account that you want to create a  token for.\n- ``: Your Google Cloud project ID. Project IDs are alphanumeric strings, like`my-project`.\n- ``: If you are using a [delegated request flow](#sa-credentials-delegated) , see [Specifying a delegation chain](#sa-credentials-delegated-chain) on this page. If you are using a [direct request flow](#sa-credentials-direct) with no delegation, omit the`delegates`field in the request body.\n- ``: A base64-encoded string of bytes. For example,`VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2cu`.\nHTTP method and URL:\n```\nPOST https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/SA_NAME@PROJECT_ID.iam.gserviceaccount.com:signBlob\n```\nRequest JSON body:\n```\n{\n \"delegates\": [ DELEGATES\n ],\n \"payload\": \"BLOB_PAYLOAD\"\n}\n```\nTo send your request, expand one of these options:\nIf the `signBlob` request was successful, the response body contains a signed blob and the signing key ID that was used to sign the blob. You can use the `signedBlob` value as a bearer token to directly authenticate a request on behalf of the service account. The token is valid until the service account's system-managed private key expires. This key's ID is the value of the `keyId` field in the response.\n```\n{\n \"keyId\": \"42ba1e...fc0a\",\n \"signedBlob\": \"eyJ0eXAi...NiJ9\"\n}\n```\n### Specify a delegation chain\nWhen using a [delegated request flow](#sa-credentials-delegated) to create short-lived service account credentials, the request body for each API must specify the service account delegation chain in the correct order and in the following format:\n`projects/-/serviceAccounts/` ``\nReplace `` with either the service account's unique numeric ID or the service account's email address.\nFor example, in a delegation chain that flows from `` (caller) to `` (delegated) to `` (delegated) to `` , the `delegates[]` field would contain `` and `` in the following order:\n```\n{\u00a0 \"delegates\": [\u00a0 \u00a0 \"projects/-/serviceAccounts/SA_2@PROJECT_ID.iam.gserviceaccount.com\",\u00a0 \u00a0 \"projects/-/serviceAccounts/SA_3@PROJECT_ID.iam.gserviceaccount.com\"\u00a0 ]}\n```\nThe caller and the service account for whom the credential is created are not included in the delegation chain.", "guide": "IAM"}