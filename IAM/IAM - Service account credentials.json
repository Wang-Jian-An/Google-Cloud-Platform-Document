{"title": "IAM - Service account credentials", "url": "https://cloud.google.com/iam/docs/service-account-creds", "abstract": "# IAM - Service account credentials\nLike any principal, a service account can authenticate itself to Google, obtain an OAuth 2.0 access token, and call Google APIs. However, this process works differently for service accounts than for users.\nService accounts authenticate by doing one of the following:\n- Obtaining [short-lived credentials](#short-lived-credentials) \n- Using a [service account key](#key-types) to sign a JSON Web Token (JWT) and exchange it for an access token", "content": "## Short-lived service account credentials\nThe most secure way to authenticate as a service account is to obtain short-lived credentials for the service account in the form of an OAuth 2.0 access token. By default, these tokens expire after 1 hour.\nShort-lived service account credentials are useful for scenarios where you need to grant limited access to resources for trusted service accounts. They also create less risk than long-lived credentials, such as service account keys.\nIn many cases, these credentials are obtained automatically\u2014you don't need to create or manage them yourself. Here are some examples:\n- If you run a Google Cloud CLI command, and you include the [--impersonate-service-account flag](/sdk/gcloud/reference#--impersonate-service-account) , then the gcloud CLI creates short-lived credentials for the service account and runs the command with those credentials.\n- If you [attach a service account](/iam/docs/attach-service-accounts) to a Compute Engine virtual machine (VM) instance, then workloads on that instance can use the Cloud Client Libraries to access Google Cloud services. The Cloud Client Libraries use Application Default Credentials (ADC) to obtain short-lived credentials for the service account.For details about this process, see [Authenticating applications using service account credentials](/compute/docs/access/create-enable-service-accounts-for-instances#authenticate-with-service-account) .\n- If you configured [workload identityfederation](/iam/docs/workload-identity-federation) , then the Cloud Client Libraries can use credentials from your identity provider to generate short-lived service account credentials.\nYou can also use the Service Account Credentials API to [create short-livedcredentials manually](/iam/docs/create-short-lived-credentials-direct) . For example, you could create a service that gives users short-lived service account credentials to let them temporarily access Google Cloud resources.\nThe Service Account Credentials API can create the following types of credentials:\n- OAuth 2.0 access tokens\n- OpenID Connect (OIDC) ID tokens\n- Self-signed JSON Web Tokens (JWTs)\n- Self-signed binary blobs\nFor more information, see [Creating short-lived service accountcredentials](/iam/docs/create-short-lived-credentials-direct) .\n### Interpreting audit logs\nCloud Audit Logs help you answer the questions \"who did what, where, and when?\" for your Google Cloud resources.\nWhen you use short-lived credentials to impersonate a service account, most Google Cloud services create log entries that show the following identities:- The service account that the short-lived credentials are impersonating\n- The identity that created the short-lived credentialsYou can use these log entries to identify the principal that created the short-lived credentials, as well as the service account that the principal impersonated.\n**Note:** Some Google Cloud services, including App Engine and Google Kubernetes Engine, do not log the identity that created the short-lived credentials.\nFor examples of audit log entries that show service account impersonation, see [Impersonating a service account to access Google Cloud](/iam/docs/audit-logging/examples-service-accounts#auth-as-service-account) .\n### Self-impersonation\nis when you use a service account's own credentials to generate a new credential for the service account.\nThe Service Account Credentials API prohibits the following kinds of self-impersonation:\n- Using a short-lived credential for a service account to generate a new [accesstoken](/docs/authentication/token-types#access) for the service account. [Self-signed JSON Web Tokens (JWTs)](/docs/authentication/token-types#self-signed) are the exception to this rule\u2014you can use a self-signed JWT for a service account to generate a new access token for the service account.\n- Using a short-lived credential for a service account to sign a binary object (blob) or JWT that can be used to call the following APIs:- [Identity and Access Management API](/iam/docs/reference/rest) \n- [Service Account Credentials API](/iam/docs/reference/credentials/rest) \n- [OAuth 2.0 API](https://developers.google.com/identity/protocols/oauth2) Google Cloud prohibits this kind of self-impersonation because it lets malicious actors refresh stolen tokens indefinitely.\nIf you try to use self-impersonation in one of the prohibited ways, you might encounter the following error:\n```\nFAILED_PRECONDITION: You can't create a token for the same service account that\nyou used to authenticate the request.\n```\nIf you encounter this error, try using different credentials to generate the new short-lived credential for your service account\u2014for example, your end-user credentials or a different service account's credentials.\n## Service account keys\nEach service account is associated with a public/private RSA key pair. The Service Account Credentials API uses this internal key pair to create short-lived service account credentials, and to sign blobs and JSON Web Tokens (JWTs). This key pair is known as the .\nIn addition, you can create multiple public/private RSA key pairs, known as , and use the private key to authenticate with Google APIs. This private key is known as a .\n### Google-managed key pairs\nGoogle-managed key pairs are used by the Service Account Credentials API, and by Google Cloud services such as App Engine and Compute Engine, to generate [short-lived credentials for service accounts](#short-lived-credentials) .\nGoogle-managed key pairs are automatically rotated and used for signing for a maximum of two weeks. The rotation process is probabilistic; usage of the new key will gradually ramp up and down over the key's lifetime.\nThe private key in a Google-managed key pair is always held in escrow, and you can never access it directly.\nThe public key in a Google-managed key pair is publicly accessible, so that anyone can verify signatures that are created with the private key. You can access the public key in several different formats:\n- X.509 certificate:`https://www.googleapis.com/service_accounts/v1/metadata/x509/` ``\n- JSON Web Key (JWK):`https://www.googleapis.com/service_accounts/v1/jwk/` ``\n- Raw format:`https://www.googleapis.com/service_accounts/v1/metadata/raw/` ``\nIf you download and cache the public key, we recommend caching it for at most 24 hours to ensure that you always have the current key. Regardless of when you retrieve the public key, it will be valid for at least 24 hours after you retrieve it.\n### User-managed key pairs\nYou can create user-managed key pairs for a service account, then use the private key from each key pair to authenticate with Google APIs. This private key is known as a .\nThe Cloud Client Libraries can use service account keys to obtain an OAuth 2.0 access token automatically. You can also use a service account key to sign a JWT manually, then use the signed JWT to request an access token. For details, see [Using OAuth 2.0 for server to server applications](https://developers.google.com/identity/protocols/oauth2/service-account) .\n**Caution:** Service account keys are a security risk if not managed correctly. You should [ choose a more secure alternative to service account keys](/docs/authentication#auth-decision-tree) whenever possible. If you must authenticate with a service account key, you are responsible for the security of the private key and for other management operations such as [key rotation](/iam/docs/key-rotation) . For more information, see [best practices for managingservice account keys](/iam/docs/best-practices-for-managing-service-account-keys) .\nEach service account can have up to 10 service account keys. Google stores only the public portion of a user-managed key pair.\nThere are a few different ways to create a user-managed key pair for a service account:\n- Use the IAM API to [create a user-managed key pair automatically](/iam/docs/creating-managing-service-account-keys#creating) . Google generates a public/private key pair; stores only the public key; and returns the private key to you.\n- Create a user-managed key pair yourself, then [upload only the public key](/iam/docs/keys-upload) . Google never sees the private key.\nUser-managed keys are extremely powerful credentials. To limit the use of user-managed keys, you can enforce the following [organization policy constraints](/resource-manager/docs/organization-policy/org-policy-constraints) in an organization, project, or folder:\n- `constraints/iam.disableServiceAccountKeyCreation`: Prevents principals from creating user-managed service account keys.\n- `constraints/iam.disableServiceAccountKeyUpload`: Prevents principals from uploading a public key for a service account.\nIf you enforce these constraints because you are using [workload identityfederation](/iam/docs/workload-identity-federation) , consider using the [organizationpolicy constraints for workload identityfederation](/iam/docs/manage-workload-identity-pools-providers#constraints) to specify which identity providers are allowed.\nBy default, when you create a user-managed service account key, the key never expires. You can change this default by setting an expiry time for all newly created keys in your project, folder, or organization. An expiry time specifies the number of hours for which a newly created key is valid.\nUse expiry times when you need temporary access to a system that requires a service account key. For example, use expiry times when you're doing the following:\n- Developing code in a non-production environment for an application that can only authenticate with service account keys\n- Using a third-party tool that can only authenticate with service account keys\nAvoid using expiry times for these scenarios:\n- Production workloads. In production, an expired service account key could cause an accidental outage. Instead, use keys that do not expire, and manage their lifecycle with key rotation.\n- Non-production workloads that need permanent access, such as a continuous integration (CI) pipeline.\n- Key-rotation systems that prevent a key from being used after a specified amount of time. To learn about recommended key rotation strategies, see [Service account key rotation](/iam/docs/key-rotation) .\nTo help prevent outages, we recommend that you do not set an expiry time unless the `constraints/iam.disableServiceAccountKeyCreation` [organization policy constraint](/resource-manager/docs/organization-policy/org-policy-constraints) has been in place for an extended period of time. When you set an expiry time, you must also stop enforcing the `constraints/iam.disableServiceAccountKeyCreation` constraint. For details about this constraint, see [Limit lifetime of service account keys](/resource-manager/docs/organization-policy/restricting-service-accounts#limit_key_expiry) .\n**Important:** If the `constraints/iam.disableServiceAccountKeyCreation` constraint was not in place, you must work closely with the users of the project, folder, or organization to confirm that none of their existing resources require permanent service account keys. If a resource requires permanent service account keys, and you set an expiry time, you are likely to cause an outage.\nTo set an expiry time, do the following:\n- Identify the project, folder, or organization where you want to set an expiry time for service account keys.\n- [Add an organization policy](/resource-manager/docs/organization-policy/creating-managing-policies#list_constraints) that enforces the [constraints/iam.serviceAccountKeyExpiryHours constraint](/resource-manager/docs/organization-policy/restricting-service-accounts#limit_key_expiry) . After you enforce this constraint for your project, folder, or organization, the expiry time applies to all newly created service account keys within that parent resource. Existing keys are not affected.\nExpiry times are measured in hours. As a best practice, use short expiry times, such as 8 hours; 24 hours (1 day); or 168 hours (7 days). Short expiry times help ensure that your team has a well-tested process for updating keys. Start with the shortest expiry time that meets your needs, and increase it only if necessary.", "guide": "IAM"}