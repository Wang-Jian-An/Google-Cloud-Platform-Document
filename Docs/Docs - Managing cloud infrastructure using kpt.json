{"title": "Docs - Managing cloud infrastructure using kpt", "url": "https://cloud.google.com/architecture/managing-cloud-infrastructure-using-kpt", "abstract": "# Docs - Managing cloud infrastructure using kpt\nLast reviewed 2023-03-15 UTC\nThis tutorial introduces\n [kpt](https://kpt.dev) \n, an open source tool by Google that lets you work with Kubernetes configurations (also known as manifests): package them, pull them, update them, and modify them. kpt is an alternative to template-based tools when you want to keep a clean separation between configurations and operations on those configurations. kpt lets you reuse and share code that is acting on the configurations (either to modify or inspect them).\nThis tutorial also showcases how you can combine kpt with other Google solutions like [Config Sync](/kubernetes-engine/docs/add-on/config-sync/overview) and [GKE Enterprise security blueprints](https://github.com/GoogleCloudPlatform/anthos-security-blueprints) . Whether you are a developer working with Kubernetes or a platform engineer managing a Kubernetes-based platform, this tutorial lets you discover how you can use kpt in your own Kubernetes-related workflows. This tutorial assumes that you are familiar with Kubernetes and Google Cloud.\nDeclarative configuration for cloud infrastructure is a well-established practice in the IT industry. It brings a powerful abstraction of the underlying systems. This abstraction frees you from having to manage low-level configuration details and dependencies. Therefore, declarative configuration has an advantage compared to imperative approaches, such as operations performed in graphical and command line interfaces.\nThe [Kubernetes resource model](https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/resource-management.md) has been influential in making declarative configuration approaches mainstream. Because the Kubernetes API is fully declarative by nature, you only tell Kubernetes what you want, not to achieve what you want. The Kubernetes API lets you cleanly separate the (whether desired or real) from on the configuration (adding, removing, and modifying objects). In other words, in the Kubernetes resource model, the configuration is , and code.\nThis separation of configuration from operations has many advantages: people and automated systems can understand and work on the configuration, and the software modifying the configuration is easily reusable. This separation also lets you easily implement a GitOps methodology (as defined in the [GitOps-style continuous delivery with Cloud Build](/kubernetes-engine/docs/tutorials/gitops-cloud-build) tutorial).\nIn this tutorial, you explore this separation of configuration declaration from configuration operations using kpt. This tutorial highlights the following features of kpt:- Package management: download and update Kubernetes configuration packages.\n- Functions: run arbitrary pieces of code to either modify or validate your configurations.\n- Function pipeline: a set of functions that the package author has included with the package.\n- Resource management: apply, update, and delete the resources that correspond to your configurations in a Kubernetes cluster.\n", "content": "## Objectives\n- Create a Google Kubernetes Engine (GKE) cluster.\n- Use kpt to download an existing set of Kubernetes configurations.\n- Use kpt functions to customize the configurations.\n- Apply your configuration to the GKE cluster.\n- Use kpt to pull in some upstream changes for your configuration.\n- Use kpt in a real-world scenario to harden your GKE cluster.\n## CostsIn this document, you use the following billable components of Google Cloud:- Google Kubernetes Engine\nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . ## Before you begin- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) At the bottom of the Google Cloud console, a [Cloud Shell](/shell/docs/how-cloud-shell-works) session starts and displays a command-line prompt. Cloud Shell is a shell environment  with the Google Cloud CLI  already installed and with values already set for  your current project. It can take a few seconds for the session to initialize.\n- Configure Cloud Shell to use your project:```\ngcloud config set project PROJECT_ID\n```\n- In Cloud Shell, enable the Google Kubernetes Engine and Cloud Source Repositories  APIs:```\ngcloud services enable container.googleapis.com \\\u00a0 \u00a0sourcerepo.googleapis.com\n```\nWhen you finish this tutorial, you can avoid continued billing by deleting the resources that you created. For more details, see [Cleaning up](#clean-up) .## Creating a GKE clusterIn this section, you create the GKE cluster where you deploy configurations later in the tutorial.- In Cloud Shell, create a GKE cluster:```\ngcloud container clusters create kpt-tutorial \\\u00a0 \u00a0--num-nodes=1 --machine-type=n1-standard-4 \\\u00a0 \u00a0--zone=us-central1-a --enable-network-policy\n```\n- Verify that you have access to the cluster. The following command returns information about the node or nodes that are in the cluster.```\nkubectl get nodes\n```\n## Applying a kpt packageIn this section, you use kpt to download a set of configurations, customize them, and apply them to the cluster that you created in the previous section. `kpt` should be installed inside your Cloud Shell environment. If it's not, install it with the following commands:- In Cloud Shell, install kpt:```\nsudo apt update && sudo apt-get install google-cloud-sdk-kpt\n```\n- Download an example set of configurations. For more information, see [kpt pkg get](https://kpt.dev/reference/cli/pkg/get/) .```\nkpt pkg get https://github.com/GoogleContainerTools/kpt.git/package-examples/wordpress@v0.9\n```The preceding command downloads the `wordpress` sample package that is available in the [kpt GitHub repository](https://github.com/GoogleContainerTools/kpt/tree/package-examples/wordpress%2Fv0.9/package-examples/wordpress) , at the version tagged `v0.9` .\n- Examine the package contents: [kpt pkg tree](https://kpt.dev/reference/cli/pkg/tree/) .```\nkpt pkg tree wordpress\n```The output looks like the following:```\nPackage \"wordpress\"\n\u251c\u2500\u2500 [Kptfile] Kptfile wordpress\n\u251c\u2500\u2500 [service.yaml] Service wordpress\n\u251c\u2500\u2500 deployment\n\u2502 \u251c\u2500\u2500 [deployment.yaml] Deployment wordpress\n\u2502 \u2514\u2500\u2500 [volume.yaml] PersistentVolumeClaim wp-pv-claim\n\u2514\u2500\u2500 Package \"mysql\"\n \u251c\u2500\u2500 [Kptfile] Kptfile mysql\n \u251c\u2500\u2500 [deployment.yaml] PersistentVolumeClaim mysql-pv-claim\n \u251c\u2500\u2500 [deployment.yaml] Deployment wordpress-mysql\n \u2514\u2500\u2500 [deployment.yaml] Service wordpress-mysql\n```The package contains two packages the top level one `wordpress` and a subpackage `wordpress/mysql` , both of these packages contain a metadata file `Kptfile` . `Kptfile` is only consumed by kpt itself and has data about the upstream source, customization and validation of the package\n- Update the label of the packageThe author of the package added a rendering pipeline which is often used to convey the expected customizations.```\nless wordpress/Kptfile\n```The contents should look something like this:```\napiVersion: kpt.dev/v1kind: Kptfilemetadata:\u00a0 name: wordpressupstream:\u00a0 type: git\u00a0 git:\u00a0 \u00a0 repo: https://github.com/GoogleContainerTools/kpt\u00a0 \u00a0 directory: /package-examples/wordpress\u00a0 \u00a0 ref: v0.9\u00a0 updateStrategy: resource-mergeupstreamLock:\u00a0 type: git\u00a0 git:\u00a0 \u00a0 repo: https://github.com/GoogleContainerTools/kpt\u00a0 \u00a0 directory: /package-examples/wordpress\u00a0 \u00a0 ref: package-examples/wordpress/v0.9\u00a0 \u00a0 commit: b9ea0bca019dafa9f9f91fd428385597c708518cinfo:\u00a0 emails:\u00a0 \u00a0 - kpt-team@google.com\u00a0 description: This is an example wordpress package with mysql subpackage.pipeline:\u00a0 mutators:\u00a0 \u00a0 - image: gcr.io/kpt-fn/set-labels:v0.1\u00a0 \u00a0 \u00a0 configMap:\u00a0 \u00a0 \u00a0 \u00a0 app: wordpress\u00a0 validators:\u00a0 \u00a0 - image: gcr.io/kpt-fn/kubeval:v0.3\n```You can use your favorite editor to change the parameters of the set-label function from `app: wordpress` to `app: my-wordpress`\n- Edit the MySQL deployment `wordpress/mysql/deployment.yaml` using your favorite code editor to change the MySQL version. Also, to further strengthen the security, change the `MYSQL_ROOT_PASSWORD` variable to `MYSQL_PASSWORD` , and add the following variables:- `MYSQL_USER`\n- `MYSQL_RANDOM_ROOT_PASSWORD`\n- `MYSQL_DATABASE`\nBefore:```\n[...]\u00a0 containers:\u00a0 \u00a0 - name: mysql\u00a0 \u00a0 \u00a0 image: mysql:5.6\u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - name: mysql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 containerPort: 3306\u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: MYSQL_ROOT_PASSWORD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: mysql-pass\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password[...]\n```After:```\n[...]\u00a0 containers:\u00a0 \u00a0 - name: mysql\u00a0 \u00a0 \u00a0 image: mysql:8.0\u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - name: mysql\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 containerPort: 3306\u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: MYSQL_PASSWORD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: mysql-pass\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password\u00a0 \u00a0 \u00a0 \u00a0 - name: MYSQL_RANDOM_ROOT_PASSWORD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: '1'\u00a0 \u00a0 \u00a0 \u00a0 - name: MYSQL_USER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: wordpress\u00a0 \u00a0 \u00a0 \u00a0 - name: MYSQL_DATABASE\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: wordpress[...]\n```\n- Edit the Wordpress deployment `wordpress/deployment/deployment.yaml` using your favorite code editor to change the Wordpress version and add a `WORDPRESS_DB_USER` variable.Before:```\n[...]\u00a0 containers:\u00a0 \u00a0 - name: wordpress\u00a0 \u00a0 \u00a0 image: wordpress:6.1-apache\u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - name: wordpress\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 containerPort: 80\u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: WORDPRESS_DB_HOST\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: wordpress-mysql\u00a0 \u00a0 \u00a0 \u00a0 - name: WORDPRESS_DB_PASSWORD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: mysql-pass\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password[...]\n```After:```\n[...]\u00a0 containers:\u00a0 \u00a0 - name: wordpress\u00a0 \u00a0 \u00a0 image: wordpress:4.8-apache\u00a0 \u00a0 \u00a0 ports:\u00a0 \u00a0 \u00a0 \u00a0 - name: wordpress\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 protocol: TCP\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 containerPort: 80\u00a0 \u00a0 \u00a0 env:\u00a0 \u00a0 \u00a0 \u00a0 - name: WORDPRESS_DB_HOST\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: wordpress-mysql\u00a0 \u00a0 \u00a0 \u00a0 - name: WORDPRESS_DB_PASSWORD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 valueFrom:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 secretKeyRef:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name: mysql-pass\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: password\u00a0 \u00a0 \u00a0 \u00a0 - name: WORDPRESS_DB_USER\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 value: wordpress[...]\n```Unlike tools that operate only through parameters, kpt allows you to edit files in place using an editor and then will still merge the upstream updates. You can edit the `deployment.yaml` directly without having to craft a patch or creating a function in the pipeline.\n- Annotate the configuration with `sample-annotation: sample-value` .```\nkpt fn eval wordpress --image gcr.io/kpt-fn/set-annotations:v0.1 \\\u00a0 -- sample-annotation=sample-value\n```The output should look something like this:```\n[RUNNING] \"gcr.io/kpt-fn/set-annotations:v0.1\"\n[PASS] \"gcr.io/kpt-fn/set-annotations:v0.1\"\n```To see the new annotation you can examine any configuration value, a simple one to see is `wordpress/service.yaml`In this example we did a customization using a function in a way that the package author didn't plan for. kpt is able to support declarative and imperative function execution to allow for a wide range of scenarios.If this package was developed using infrastructure-as-code we would need to go to the source of the package and edit code there.\n- Run the pipeline and validate the changes using [kubeval](https://www.kubeval.com/) through kpt.```\nkpt fn render wordpress\n```The package author has included a validation step in the pipeline:```\n...\nvalidators:\n - image: gcr.io/kpt-fn/kubeval:v0.3\n```The successful output of this rendering pipeline looks like this:```\nPackage \"wordpress/mysql\":\n[RUNNING] \"gcr.io/kpt-fn/set-labels:v0.1\"\n[PASS] \"gcr.io/kpt-fn/set-labels:v0.1\" in 1.3s\nPackage \"wordpress\":\n[RUNNING] \"gcr.io/kpt-fn/set-labels:v0.1\"\n[PASS] \"gcr.io/kpt-fn/set-labels:v0.1\" in 1.3s\n[RUNNING] \"gcr.io/kpt-fn/kubeval:v0.3\"\n[PASS] \"gcr.io/kpt-fn/kubeval:v0.3\" in 3.7s\nSuccessfully executed 3 function(s) in 2 package(s).\n``` **Note:** To see the result of the preceding command for an invalid configuration, edit the `wordpress/service.yaml` file and change the `apiVersion` to `v2` . Save the file, and then rerun the command. Remember to revert your change before you proceed to the next step.This step is an example of the benefits of the Kubernetes resource model: because your configurations are represented in this well-known model, you can use existing Kubernetes tools like kubeval.\n- Examine the differences between your local version of the configurations and the upstream configuration:```\nkpt pkg diff wordpress\n```\n- Initialize the package for deployment:```\nkpt live init wordpress\n```The preceding command builds an inventory of the configurations that are in the package. Among other things, kpt uses the inventory to prune configurations when you remove them from the package. For more information, see [kpt live](https://kpt.dev/reference/cli/live/) .\n- Create a secret that contains the MySQL password:```\nkubectl create secret generic mysql-pass --from-literal=password=foobar\n```\n- Apply the configurations to your GKE cluster:```\nkpt live apply wordpress\n```The output looks like the following:```\ninstalling inventory ResourceGroup CRD.\ninventory update started\ninventory update finished\napply phase started\nservice/wordpress apply successful\nservice/wordpress-mysql apply successful\ndeployment.apps/wordpress apply successful\ndeployment.apps/wordpress-mysql apply successful\npersistentvolumeclaim/mysql-pv-claim apply successful\npersistentvolumeclaim/wp-pv-claim apply successful\napply phase finished\nreconcile phase started\nservice/wordpress reconcile successful\nservice/wordpress-mysql reconcile successful\ndeployment.apps/wordpress reconcile pending\ndeployment.apps/wordpress-mysql reconcile pending\npersistentvolumeclaim/mysql-pv-claim reconcile pending\npersistentvolumeclaim/wp-pv-claim reconcile pending\npersistentvolumeclaim/wp-pv-claim reconcile successful\npersistentvolumeclaim/mysql-pv-claim reconcile successful\ndeployment.apps/wordpress-mysql reconcile successful\ndeployment.apps/wordpress reconcile successful\nreconcile phase finished\ninventory update started\ninventory update finished\napply result: 6 attempted, 6 successful, 0 skipped, 0 failed\nreconcile result: 6 attempted, 6 successful, 0 skipped, 0 failed, 0 timed out\n```\n- Wait a few minutes, and then verify that everything is running as expected:```\nkpt live status wordpress\n```The output looks like the following:```\ninventory-88521939/deployment.apps/default/wordpress is Current: Deployment is available. Replicas: 1\ninventory-88521939/persistentvolumeclaim/default/wp-pv-claim is Current: PVC is Bound\ninventory-88521939/service/default/wordpress-mysql is Current: Service is ready\ninventory-88521939/persistentvolumeclaim/default/mysql-pv-claim is Current: PVC is Bound\ninventory-88521939/deployment.apps/default/wordpress-mysql is Current: Deployment is available. Replicas: 1\ninventory-88521939/service/default/wordpress is Current: Service is ready\n```\n## Updating your local packageIn this section, you update your local version of the package with some changes from the upstream package.- Create a Git repository for your configurations and configure your email and name. You need a local Git repository to be able to update the package. Replace `` with your email address and replace `` with your name.```\ncd wordpress/git init -b maingit config user.email \"YOUR_EMAIL\"git config user.name \"YOUR_NAME\"\n```\n- Commit your configurations:```\ngit add .git commit -m \"First version of Wordpress package\"cd ..\n```\n- Update your local package. In this step, you pull the `v0.10` version from upstream.```\nkpt pkg update wordpress@v0.10\n```\n- Observe that updates from upstream are applied to your local package:```\ncd wordpress/git diff\n```In this case, the update has changed the wordpress deployment volume from 3Gi to 4Gi. You can also see you own changes.\n- Commit your changes:```\ngit commit -am \"Update to package version v0.10\"\n```\n- Apply the new version of the package:```\nkpt live apply .\n```\n## Removing a resource and a packageBecause kpt tracks the resources that it creates, it can prune resources from the cluster when you delete resources from the package. It can also completely remove a package from the cluster. In this section, you remove a resource from the package, and then remove the package.- Remove the `service.yaml` file from the package:```\ngit rm service.yamlgit commit -m \"Remove service\"\n```\n- Apply the change, and then verify that kpt pruned the wordpress service:```\nkpt live apply .kubectl get svc\n```\n- Remove the rest of the package from the cluster, and then verify that you have nothing left in the cluster:```\nkpt live destroy .kubectl get deployment\n```\n## Using kpt to harden your GKEThe `kpt live` command is not the only way that you can apply a package to a Kubernetes cluster. In this section, you use kpt with [Config Sync](/anthos-config-management/docs/config-sync-overview) in a basic but realistic scenario. The Config Sync tool lets you manage your configuration centrally, uniformly, and declaratively for all your Kubernetes clusters from a Git repository. GKE Enterprise (which you use in this tutorial) includes [Config Sync](/anthos/config-management) .\nThe [GKE Enterprise security blueprints](https://github.com/GoogleCloudPlatform/anthos-security-blueprints) provide you with a range of prepackaged security settings for your GKE Enterprise-based workloads. In this section, you use the [restricting traffic](/architecture/blueprints/anthos-restricting-traffic-blueprint) blueprint (and [its directory in the GitHub repository](https://github.com/GoogleCloudPlatform/anthos-security-blueprints/tree/master/restricting-traffic) ). You use kpt to download the `default-deny` package. The package uses Kubernetes [network policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) to deny any traffic in your GKE cluster by default (except for DNS resolution). To apply the configurations, you then commit the configurations to the Config Sync Git repository.\n### Install Config SyncIn this section, you create the Git repository that Config Sync needs, and then you install Config Sync on your GKE cluster.- In Cloud Shell, use Cloud Source Repositories to create a Git repository for Config Sync:```\ncd ~gcloud source repos create config-management\n```\n- Generate an SSH key pair to authenticate against the Git repository:```\ncd ~ssh-keygen -t rsa -b 4096 \u00a0-N '' \\\u00a0 \u00a0-f cloud_source_repositories_key\n``` **Note:** SSH is one of the ways that Config Sync can authenticate against a Git repository. Depending on the Git provider, you can also use authentication methods like personal access tokens (PATs) or Google service accounts. For more information about alternative authentication methods, see [Granting Operator read-only access to Git](/anthos-config-management/docs/how-to/installing-config-sync#git-creds-secret) .\n- Create the Kubernetes Secret that contains the SSH private key to access the Git repository:```\nkubectl create ns config-management-system && \\kubectl create secret generic git-creds \\\u00a0 --namespace=config-management-system \\\u00a0 --from-file=ssh=cloud_source_repositories_key\n```\n- Display the public key, and then copy it:```\ncat cloud_source_repositories_key.pub\n```\n- Go to the Cloud Source Repositories [Manage SSH Keys](https://source.cloud.google.com/user/ssh_keys?register=true) page.\n- In the **Register SSH Key** dialog that appears, enter the following values:- In the **Key name** field, enter`config-management`.\n- In the **Key** field, paste the public key.\n- Click **Register** .\n- Clone the Git repository to Cloud Shell:```\ngcloud source repos clone config-managementcd config-managementgit checkout -b main\n```\n- Download the Config Sync command-line tool called `nomos` . `nomos` should be installed inside your Cloud Shell environment. If it's not, install it with the following commands:```\nsudo apt update && sudo apt-get install google-cloud-sdk-nomos\n```\n- Initialize the Config Sync repository:```\nnomos initgit add .git commit -m \"Config Management directory structure\"git push -u origin main\n```\n- Deploy the Config Sync operator:```\ngsutil cp gs://config-management-release/released/latest/config-management-operator.yaml /tmp/config-management-operator.yamlkubectl apply -f /tmp/config-management-operator.yaml\n```\n### Configure Config Sync\n- Create a ConfigManagement custom resource to configure Config Sync:```\nPROJECT=$(gcloud config get-value project)EMAIL=$(gcloud config get-value account)cat <<EOF > /tmp/config-management.yamlapiVersion: configmanagement.gke.io/v1kind: ConfigManagementmetadata:\u00a0 name: config-managementspec:\u00a0 clusterName: kpt-tutorial\u00a0 git:\u00a0 \u00a0 syncRepo: ssh://${EMAIL}@source.developers.google.com:2022/p/${PROJECT}/r/config-management\u00a0 \u00a0 syncBranch: main\u00a0 \u00a0 secretType: sshEOFkubectl -n config-management-system \\\u00a0 \u00a0 apply -f /tmp/config-management.yaml\n```For more installation options, see the install [Config Sync documentation](/anthos-config-management/docs/how-to/installing-config-sync) .\n- In Cloud Shell, verify that Config Sync is working properly:```\nnomos status --contexts=$(kubectl config current-context)\n```This command returns the status as `SYNCED` . Config Sync might take some time to initialize. If the status isn't updated, wait a few minutes and then rerun the command.\n### Apply the GKE Enterprise security blueprintIn this section, you use kpt to download the `default-deny` package of the restricting traffic GKE Enterprise security blueprint. Then you use Config Sync to apply the package to the `default` namespace only.- Download the `default-deny` package:```\ncd ~kpt pkg get https://github.com/GoogleCloudPlatform/anthos-security-blueprints.git/restricting-traffic/default-deny ./\n```You can explore the content of the package: the `default-deny/Kptfile` file contains the metadata of the package, and the `default-deny/default-deny.yaml` file contains a Kubernetes NetworkPolicy, which is the only configuration from this blueprint.\n- Use kpt to copy the package's content in the Config Sync repository, and then add labels to customize it:```\nkpt fn source default-deny/ | \\\u00a0 \u00a0 kpt fn eval - --image=gcr.io/kpt-fn/set-annotations:v0.1 -- \\\u00a0 \u00a0 anthos-security-blueprint=restricting-traffic | \\\u00a0 \u00a0 kpt fn sink ~/config-management/namespaces/default/\n```As shown in this example, you can use pipes to chain `kpt fn` commands together. Chaining `kpt fn` commands lets you read configurations, modify them as you want, and write the result. You can chain as many `kpt fn` commands as you want.\n- Create the `namespace.yaml` file in the Config Sync repository:```\ncat >> ~/config-management/namespaces/default/namespace.yaml <<EOFapiVersion: v1kind: Namespacemetadata:\u00a0 name: defaultEOF\n```The `default` namespace exists in your GKE cluster, but Config Sync doesn't manage it. When you create the directory and the file in this step, you make Config Sync manage the namespace. To apply the package to multiple namespaces at once, you can create an [abstract namespace](/anthos-config-management/docs/how-to/namespace-scoped-objects#abstract-namespace-config) .\n- Verify that the Kubernetes NetworkPolicies were written to the Config Sync repository, and that they are annotated with `anthos-security-blueprint: restricting-traffic` :```\ncat config-management/namespaces/default/default-deny.yaml\n```The output looks like the following:```\nkind: NetworkPolicyapiVersion: networking.k8s.io/v1metadata: # kpt-merge: /default-deny\u00a0 name: default-deny\u00a0 annotations:\u00a0 \u00a0 internal.kpt.dev/upstream-identifier: 'networking.k8s.io|NetworkPolicy|default|default-deny'\u00a0 \u00a0 anthos-security-blueprint: restricting-trafficspec:\u00a0 policyTypes:\u00a0 - Ingress\u00a0 - Egress\u00a0 podSelector: {}\u00a0 egress:\u00a0 - to:\u00a0 \u00a0 - namespaceSelector:\u00a0 \u00a0 \u00a0 \u00a0 matchLabels:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 k8s-namespace: kube-system\u00a0 \u00a0 \u00a0 podSelector:\u00a0 \u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - key: k8s-app\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operator: In\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"kube-dns\", \"node-local-dns\"]\u00a0 \u00a0 ports:\u00a0 \u00a0 - protocol: TCP\u00a0 \u00a0 \u00a0 port: 53\u00a0 \u00a0 - protocol: UDP\u00a0 \u00a0 \u00a0 port: 53\n```\n- Commit and push the changes:```\ncd ~/config-management/git add namespaces/default/git commit -m \"Default deny\"git push\n``` **Note:** In this tutorial, Config Sync applies the changes when you push them. For a production scenario, we recommend that you read [Safe rollouts with Config Sync](/anthos-config-management/docs/tutorials/safe-rollouts-with-config-sync) to learn about other rollout strategies.\n- Verify that the new policy is applied:```\nkubectl get networkpolicies\n```If the new policy isn't present, wait a few seconds and then run the command again. Config Sync updates the configurations every 15 seconds by default. If you need to do some additional troubleshooting, run the following command to get information about any potential Config Sync errors:```\nnomos status --contexts=$(kubectl config current-context)\n```\n- To test the new policy, get a shell in a pod running inside the `default` namespace:```\nkubectl -n default run -i --tty --rm test \\\u00a0 \u00a0 \u00a0 \u00a0 --image=busybox --restart=Never -- sh\n```\n- Try to ping `8.8.8.8` , and see that it doesn't work, as expected:```\nping -c 3 -W 1 8.8.8.8\n```The output looks like the following:```\nPING 8.8.8.8 (8.8.8.8): 56 data bytes\n--- 8.8.8.8 ping statistics --3 packets transmitted, 0 packets received, 100% packet loss\n```\n- Try to query the Kubernetes API server, and see that it doesn't work, as expected:```\nwget --timeout=3 https://${KUBERNETES_SERVICE_HOST}\n```The output looks like the following:```\nConnecting to 10.3.240.1 (10.3.240.1:443)\nwget: download timed out\n```\n- Exit the pod:```\nexit\n```\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete the resourcesIf you want to keep the Google Cloud project that you used in this tutorial, you can delete the Git repository and the GKE cluster. In Cloud Shell, run the following commands:\n```\ngcloud source repos delete config-management --quietgcloud container clusters delete kpt-tutorial \\\u00a0 \u00a0 --async --quiet --zone=us-central1-a\n```## What's next\n- Learn more about [Config Sync](/anthos-config-management/docs/config-sync-overview) and its components.\n- Learn about [Policy Controller to validate you application's deployment configuration](/anthos-config-management/docs/tutorials/app-policy-validation-ci-pipeline) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Docs"}