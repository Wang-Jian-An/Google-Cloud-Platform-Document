{"title": "Docs - Interservice communication in a microservices setup", "url": "https://cloud.google.com/architecture/microservices-architecture-interservice-communication", "abstract": "# Docs - Interservice communication in a microservices setup\nLast reviewed 2023-09-20 UTC\nThis document is the third in a four-part series about designing, building, and deploying microservices. This series describes the various elements of a microservices architecture. The series includes information about the benefits and drawbacks of the microservices architecture pattern, and how to apply it.- [Introduction to microservices](/architecture/microservices-architecture-introduction) \n- [Refactoring a monolith into microservices](/architecture/microservices-architecture-refactoring-monoliths) \n- Interservice communication in a microservices setup (this document)\n- [Distributed tracing in a microservices application](/architecture/microservices-architecture-distributed-tracing) \nThis series is intended for application developers and architects who design and implement the migration to refactor a monolith application to a microservices application.\nThis document describes the tradeoffs between asynchronous messaging compared to synchronous APIs in microservices. The document walks you through deconstruction of a monolithic application and shows you how to convert a synchronous request in the original application to asynchronous flow in the new microservices-based setup. This conversion includes implementing distributed transactions between services.", "content": "## Example applicationIn this document, you use a pre-built ecommerce application called Online Boutique. The application implements basic ecommerce flows such as browsing items, adding products to a cart, and checkout. The application also features recommendations and ads based on user selection.## Logical separation of serviceIn this document, you isolate the payment service from the rest of the application. All flows in the original Online Boutique application are synchronous. In the refactored application, the payment process is converted to an asynchronous flow. Therefore, when you receive a purchase request, instead of processing it immediately, you provide a \"request received\" confirmation to the user. In the background, an asynchronous request is triggered to the payment service to process the payment.\nBefore you move payment data and logic into a new service, you isolate the payment data and logic from the monolith. When you isolate the payment data and logic in the monolith, it's easier to refactor your code in the same codebase if you get payment service boundaries wrong (business logic or data).\nThe components of the monolith application in this document are already modularized, so they're isolated from each other. If your application has tighter interdependencies, you need to isolate the business logic and create separate classes and modules. You also need to decouple any database dependencies into their own tables and create separate repository classes. When you decouple database dependencies, there can be foreign key relationships between the split tables. However, after you completely decouple the service from the monolith, these dependencies cease to exist, and the service interacts exclusively through predefined API or RPC contracts.## Distributed transactions and partial failuresAfter you isolate the service and split it from the monolith, a local transaction in the original monolithic system is distributed among multiple services. In the monolith implementation, the checkout process followed the sequence shown in the following diagram. **Figure 1.** A checkout process sequence in a monolith implementation.\nIn figure 1, when the application receives a purchase order, the checkout controller calls the payment service and order service to process payment and save the order respectively. If any step fails, the database transaction can be rolled back. Consider an example scenario in which the order request is successfully stored in the order table, but the payment fails. In this scenario, the entire transaction is rolled back and the entry is removed from the order table.\nAfter you decouple payment into its own service, the modified checkout flow is similar to the following diagram: **Figure 2.** A checkout process sequence after payment is decoupled into its own service.\nIn figure 2, the transaction now spans multiple services and their corresponding databases, so it's a . On receiving an order request, the checkout controller saves the order details in its local database and calls other services to complete the order. These services, such as the payment service, can use their own local database to store details about the order.\nIn the monolithic application, the database system ensures that the local transactions are atomic. However, by default, the microservice-based system that has a separate database for each service doesn't have a global transaction coordinator that spans the different databases. Because transactions aren't centrally coordinated, a failure in processing a payment doesn't roll back changes that were committed in the order service. Therefore, the system is in an inconsistent state.\nThe following patterns are commonly used to handle distributed transactions:- [Two-phase commit protocol (2PC)](https://wikipedia.org/wiki/Two-phase_commit_protocol) : Part of a family of [consensus protocols](https://wikipedia.org/wiki/Two-phase_commit_protocol) , 2PC coordinates the commit of a distributed transaction and it maintains [atomicity, consistency, isolation, durability (ACID)](https://wikipedia.org/wiki/ACID) guarantees. The protocol is divided into theandphases. A transaction is committed only if all the participants voted for it. If the participants don't reach a consensus, then the entire transaction is rolled back.\n- [Saga](https://microservices.io/patterns/data/saga.html) : The Saga pattern consists of running local transactions within each microservice that make up the distributed transaction. An event is triggered at the end of every successful or failed operation. All microservices involved in the distributed transaction subscribe to these events. If the following microservices receive a success event, they execute their operation. If there is a failure, the preceding microservices complete compensating actions to undo changes. Saga provides a consistent view of the system by guaranteeing that when all steps are complete, either all operations succeed or [compensating actions](https://wikipedia.org/wiki/Compensating_transaction) undo all the work.\nWe recommend Saga for long-lived transactions. In a microservices-based application, you expect interservice calls and communication with third-party systems. Therefore, it's best to design for eventual consistency: retry for recoverable errors and expose compensating events that eventually amend non-recoverable errors.\nThere are various ways to implement a Saga\u2014for example, you can use task and workflow engines such as [Apache Airflow,](https://airflow.apache.org/) , [Apache Camel](https://camel.apache.org/manual/) , or [Conductor](https://netflix.github.io/conductor/) . You can also write your own event handlers using systems based on Kafka, RabbitMQ, or ActiveMQ.\nThe Online Boutique application uses the checkout service to orchestrate the payment, shipping and email notification services. The checkout service also handles the business and order workflow. As an alternative to building your own workflow engine, you can use third-party component such as [Zeebe](https://docs.zeebe.io/introduction/what-is-zeebe.html) . Zeebe provides a UI-based [modeler](https://github.com/zeebe-io/zeebe-modeler) . We recommend that you carefully evaluate the choices for microservices orchestrator based on your application's requirements. This choice is a critical part of running and scaling your microservices.## Refactored applicationTo enable distributed transactions in the refactored application, the checkout service handles the communication between the payment, shipping, and email service. The generic [Business Process Model and Notation (BPMN) workflow](https://wikipedia.org/wiki/Business_Process_Model_and_Notation) uses the following flow: **Figure 3.** An order workflow that helps ensure distributed transactions in typical microservices.\nThe preceding diagram shows the following workflow:- The frontend service receives an order request and then does the following:- Sends the order items to cart service. The cart service then saves the order details (Redis).\n- Redirects to checkout page. The checkout service pulls orders from the cart service, sets the order status as`Pending`, and asks the customer for payment.\n- Confirms that the user paid. Once confirmed, the checkout service tells the email service to generate a confirmation email and send it to the customer.\n- The payment service subsequently processes the request.- If the payment request succeeds, the payment service updates the order status to`Complete`.\n- If the payment request fails, then payment service initiates a compensating transaction.- The payment request is canceled.\n- The checkout service changes the order status to`Failed`.\n- If the payment service is unavailable, the request times out afterseconds and the checkout service initiates a compensating transaction.\n- The checkout service changes the order status to`Failed`.## Objectives\n- Deploy the monolithic Online Boutique application on Google Kubernetes Engine (GKE).\n- Validate the monolithic checkout flow.\n- Deploy the microservices version of the refactored monolithic application\n- Verify that the new checkout flow works.\n- Verify that the distributed transaction and compensation actions work if there is a failure.\n## CostsIn this document, you use the following billable components of Google Cloud:- [GKE](/kubernetes-engine/pricing) \n- [Cloud SQL](/sql/pricing) \n- [Container Registry](/container-registry/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nWhen you finish this document, you can avoid continued billing by deleting the resources you created. For more information, see [Cleaning up](#clean-up) .## Before you begin\n- In the Google Cloud console, on the project selector page,   select or [create a Google Cloud project](/resource-manager/docs/creating-managing-projects) . **Note** : If you don't plan to keep the  resources that you create in this procedure, create a project instead of  selecting an existing project. After you finish these steps, you can  delete the project, removing all resources associated with the project. [Go to project selector](https://console.cloud.google.com/projectselector2/home/dashboard) \n- [Make sure that billing is enabled for your Google Cloud project](/billing/docs/how-to/verify-billing-enabled#console) .\n- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) At the bottom of the Google Cloud console, a [Cloud Shell](/shell/docs/how-cloud-shell-works) session starts and displays a command-line prompt. Cloud Shell is a shell environment  with the Google Cloud CLI  already installed and with values already set for  your current project. It can take a few seconds for the session to initialize.\n- Enable the APIs for Compute Engine, Google Kubernetes Engine, Cloud SQL, Artifact Analysis, and Container Registry:```\n\u00a0gcloud services enable \\\u00a0 \u00a0 \u00a0compute.googleapis.com \\\u00a0 \u00a0 \u00a0sql-component.googleapis.com \\\u00a0 \u00a0 \u00a0servicenetworking.googleapis.com\\\u00a0 \u00a0 \u00a0container.googleapis.com \\\u00a0 \u00a0 \u00a0containeranalysis.googleapis.com \\\u00a0 \u00a0 \u00a0containerregistry.googleapis.com \\\u00a0 \u00a0 \u00a0sqladmin.googleapis.com\n```\n- Export the following environment variables:```\nexport PROJECT=$(gcloud config get-value project)export CLUSTER=$PROJECT-gkeexport REGION=\"us-central1\"\n```\n## Deploying the ecommerce monolithIn this section, you deploy the monolithic Online Boutique application in a GKE cluster. The application uses Cloud SQL as its relational database. The following diagram illustrates the monolithic application architecture: **Figure 4.** A client connects to the application in a GKE cluster, and the application connects to a Cloud SQL database.\nTo deploy the application, complete the following steps:- Clone the GitHub repository:```\ngit clone https://github.com/GoogleCloudPlatform/monolith-to-microservices-example\n```\n- Replace the `PROJECT_ID` placeholder in the Terraform variables manifest file:```\ncd monolith-to-microservices-example/setup && \\sed -i -e \"s/\\[PROJECT_ID\\]/$PROJECT/g\" terraform.tfvars\n```\n- Run the Terraform scripts to complete the infrastructure setup and deploy the infrastructure. To learn more about Terraform, see [Getting started with Terraform on Google Cloud](https://cloud.google.com/docs/terraform/maturity) :```\nterraform init && terraform apply -auto-approve\n```The Terraform script creates the following:- A VPC network named`` `-vpc`\n- GKE cluster named`` `-gke`\n- A Cloud SQL instance named`` `-mysql`- A database named`ecommerce`that the application uses\n- A user`root`with the password set to`password`You can modify the Terraform script to auto-generate a password. This setup uses a simplified example that you shouldn't use in production.Infrastructure provisioning can take up to 10 minutes. When the script is successful, the output looks like the following:```\n...\nApply complete! Resources: 8 added, 0 changed, 0 destroyed.\nOutputs:\nkubernetes_cluster_name = PROJECT_ID-gke\nsql_database_name = PROJECT_ID-mysql\nvpc_name = PROJECT_ID-vpc\n```\n- Connect to the cluster and create a namespace named `monolith` . You deploy the application in its own namespace in the GKE cluster:```\ngcloud container clusters get-credentials $CLUSTER \\\u00a0 \u00a0--region $REGION \\\u00a0 \u00a0--project $PROJECT && \\\u00a0 \u00a0kubectl create ns monolith\n```\n- The application running on GKE uses [Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/) to access the Cloud SQL database. Create a secret that uses the user credentials for the database:```\nkubectl create secret generic dbsecret \\\u00a0 --from-literal=username=root \\\u00a0 --from-literal=password=password -n monolith\n```\n- Build the monolith image and upload it to Container Registry:```\ncd ~/monolithgcloud builds submit --tag gcr.io/$PROJECT_ID/ecomm\n```\n- Update the reference in the `deploy.yaml` file to the newly created Docker image:```\ncd ~/monolithsed -i -e \"s/\\[PROJECT_ID\\]/$PROJECT/g\" deploy.yaml\n```\n- Replace placeholders in deployment manifest files and then deploy the application:```\ncd .. && \\DB_IP=$(gcloud sql instances describe $PROJECT-mysql | grep \"ipAddress:\" | tail -1 | awk -F \":\" '{print $NF}')sed -i -e \"s/\\[DB_IP\\]/$DB_IP/g\" monolith/deploy.yamlkubectl apply -f monolith/deploy.yaml\n```\n- Check the status of the deployment:```\nkubectl rollout status deployment/ecomm -n monolith\n```The output looks like the following.```\nWaiting for deployment \"ecomm\" rollout to finish: 0 of 1 updated replicas are available...\ndeployment \"ecomm\" successfully rolled out\n```\n- Get the IP address of the deployed application:```\nkubectl get svc ecomm -n monolith \\\u00a0 \u00a0 \u00a0 \u00a0 -o jsonpath=\"{.status.loadBalancer.ingress[*].ip}\" -w\n```Wait for the load balancer IP address to be published. To exit the command, press `Ctrl+C` . Note the load balancer IP address and then access the application at the URL `http://` `` . It might take some time for the load balancer to become healthy and start passing traffic.\n### Validate the monolith checkout flowIn this section, you create a test order to validate the checkout flow.- Go to the URL that you noted in the previous section,`http://` ``.\n- On the application home page that appears, select any product and then click **Add to Cart** .\n- To create a test purchase, click **Place your order** :\n- When checkout is successful, the order confirmation window appears and displays an Order Confirmation ID.\n- To view order details, connect to the database:```\ngcloud sql connect $PROJECT-mysql --user=root\n```You can also use [any other supported methods](/sql/docs/mysql/external-connection-methods) to connect to the database. When prompted, enter the password as `password` .\n- To view saved order details, run the following command:```\nselect cart_id from ecommerce.cart;\n```\n- The output looks like the following:```\n+--------------------------------------+\n| cart_id        |\n+--------------------------------------+\n| 7cb9ab11-d268-477f-bf4d-4913d64c5b27 |\n+--------------------------------------+\n```\n## Deploying the microservices-based ecommerce applicationIn this section, you deploy the refactored application. This document only focuses on decoupling frontend and payment services. The next document in this series, [Distributed tracing in a microservices application](/architecture/microservices-architecture-distributed-tracing) , describes other services, such as recommendation and ads services, that you can decouple from the monolith. The checkout service handles the distributed transactions between the frontend and the payment services and is deployed as a Kubernetes service in the GKE cluster, as shown in the following diagram: **Figure 5.** The checkout service orchestrates transactions between the cart, payment, and email services.\n### Deploy the microservicesIn this section, you use the infrastructure that you provisioned earlier to deploy microservices in their own namespace `microservice` :- Ensure that you have the following requirements:- Google Cloud project\n- Shell environment with`gcloud`,`git`, and`kubectl`\n- In Cloud Shell, clone the microservices repository:```\ngit clone https://github.com/GoogleCloudPlatform/microservices-democd microservices-demo/\n```\n- Set the Google Cloud project and region and ensure the GKE API is enabled:```\nexport PROJECT_ID=PROJECT_IDexport REGION=us-central1gcloud services enable container.googleapis.com \\--project=${PROJECT_ID}\n```Substitute \n- Create a GKE cluster and get the credentials for it:```\ngcloud container clusters create-auto online-boutique \\\u00a0 \u00a0 --project=${PROJECT_ID} --region=${REGION}\n```Creating the cluster may take a few minutes.\n- Deploy microservices to the cluster:```\nkubectl apply -f ./release/kubernetes-manifests.yaml\n```\n- Wait for the pods to be ready:```\nkubectl get pods\n```After a few minutes, you see the Pods in a `Running` state.\n- Access the web frontend in a browser using the frontend's external IP address:```\nkubectl get service frontend-external | awk '{print $4}'\n```Visit `http://` `` in a web browser to access your instance of Online Boutique. **Note:** The load balancer IP address and access the application at the URL `http://` `` . It might take some time for the load balancer to become healthy and start passing traffic.\n### Validate the new checkout flow\n- To verify the checkout process flow, select a product and place an order, as described in the earlier section [Validate the monolith checkout flow](#validate-checkout-flow) .\n- When you complete order checkout, the confirmation window doesn't display a confirmation ID. Instead, the confirmation window directs you to check your email for confirmation details.\n- To verify that the order was received, that the payment service processed the payment, and that the order details were updated, run the following command:```\nkubectl logs -f deploy/checkoutservice --tail=100\n```The output looks like the following:```\n[...]\n{\"message\":\"[PlaceOrder] user_id=\\\"98828e7a-b2b3-47ce-a663-c2b1019774a3\\\" user_currency=\\\"CAD\\\"\",\"severity\":\"info\",\"timestamp\":\"2023-08-10T04:19:20.498893921Z\"}\n{\"message\":\"payment went through (transaction_id: f0b4a592-026f-4b4a-9892-ce86d2711aed)\",\"severity\":\"info\",\"timestamp\":\"2023-08-10T04:19:20.528338189Z\"}\n{\"message\":\"order confirmation email sent to \\\"someone@example.com\\\"\",\"severity\":\"info\",\"timestamp\":\"2023-08-10T04:19:20.540275988Z\"}\n```To exit the logs, press `Ctrl+C` .\n- Verify that the payment was successful:```\nkubectl logs -f deploy/paymentservice -n --tail=100\n```The output looks like the following:```\n[...]\n{\"severity\":\"info\",\"time\":1691641282208,\"pid\":1,\"hostname\":\"paymentservice-65cc7795f6-r5m8r\",\"name\":\"paymentservice-charge\",\"message\":\"Transaction processed: visa ending 0454  Amount: CAD119.30128260\"}\n{\"severity\":\"info\",\"time\":1691641300051,\"pid\":1,\"hostname\":\"paymentservice-65cc7795f6-r5m8r\",\"name\":\"paymentservice-server\",\"message\":\"PaymentService#Charge invoked with request {\\\"amount\\\":{\\\"currency_code\\\":\\\"USD\\\",\\\"units\\\":\\\"137\\\",\\\"nanos\\\":850000000},\\\"credit_card\\\":{\\\"credit_card_number\\\":\\\"4432-8015-6152-0454\\\",\\\"credit_card_cvv\\\":672,\\\"credit_card_expiration_year\\\":2039,\\\"credit_card_expiration_month\\\":1}}\"}\n```To exit the logs, press `Ctrl+C` .\n- Verify that order confirmation email is sent:```\nkubectl logs -f deploy/emailservice -n --tail=100\n```The output looks like the following:```\n[...]\n{\"timestamp\": 1691642217.5026057, \"severity\": \"INFO\", \"name\": \"emailservice-server\", \"message\": \"A request to send order confirmation email to kalani@examplepetstore.com has been received.\"}\n``` **Note:** The example app performs transactions automatically. You can therefore ignore the repeated logs of similar activities.The log messages for each microservices indicate that the distributed transaction across the checkout, payment, and email services have completed successfully.\n### Validate compensation action in a distributed transactionThis section simulates a scenario in which a customer is placing an order and the payment service goes down.- To simulate the service's unavailability, delete the payment deployment and service:```\nkubectl delete deploy paymentservice && \\kubectl delete svc paymentservice\n```\n- Access the application again and complete the checkout flow. In this example, if the payment service doesn't respond, the request times out and a compensation action is triggered.\n- In the UI frontend, click the **Place Order** button. The output resembles the following:```\nHTTP Status: 500 Internal Server Error\nrpc error: code = Internal desc = failed to charge card: could not charge the card: rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing: dial tcp: lookup paymentservice on 34.118.224.10:53: no such host\"\nfailed to complete the order\nmain.(*frontendServer).placeOrderHandler\n /src/handlers.go:360\n```\n- Review the frontend service logs:```\nkubectl logs -f deploy/frontend --tail=100\n```The output resembles the following:```\n[...]\n{\"error\":\"failed to complete the order: rpc error: code = Internal desc = failed to charge card: could not charge the card: rpc error: code = Unavailable desc = connection error: desc = \\\"transport: Error while dialing: dial tcp: lookup paymentservice on 34.118.224.10:53: no such host\\\"\",\"http.req.id\":\"0a4cb058-ee9b-470a-9bb1-3a965636022e\",\"http.req.method\":\"POST\",\"http.req.path\":\"/cart/checkout\",\"message\":\"request error\",\"session\":\"96c94881-a435-4490-9801-c788dc400cc1\",\"severity\":\"error\",\"timestamp\":\"2023-08-11T18:25:47.127294259Z\"}\n```\n- Review the Checkout Service logs:```\nkubectl logs -f deploy/frontend --tail=100\n```The output resembles the following:```\n[...]\n{\"message\":\"[PlaceOrder] user_id=\\\"96c94881-a435-4490-9801-c788dc400cc1\\\" user_currency=\\\"USD\\\"\",\"severity\":\"info\",\"timestamp\":\"2023-08-11T18:25:46.947901041Z\"}\n{\"message\":\"[PlaceOrder] user_id=\\\"96c94881-a435-4490-9801-c788dc400cc1\\\" user_currency=\\\"USD\\\"\",\"severity\":\"info\",\"timestamp\":\"2023-08-11T19:54:21.796343643Z\"}\n```Notice that there's no subsequent call to email service to send notification. There is no transaction log, like `payment went through (transaction_id: 06f0083f-fa47-4d91-8258-6d61edfab1ca)`\n- Review the email service logs:```\nkubectl logs -f deploy/emailservice --tail=100\n```Notice that there are no log entries created for the fail transaction on email service.\nAs an orchestrator, if a service call fails, the checkout service returns an error status and exits the checkout process.## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\nIf you plan to complete the steps in the next document of this series, [Distributed tracing in a microservices application](/architecture/microservices-architecture-distributed-tracing) , you can reuse the project and resources instead of deleting them.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete the resourcesIf you want to keep the Google Cloud project that you used in this document, delete the individual resources.- In Cloud Shell, run the following command:```\ncd setup && terraform destroy -auto-approve\n```\n- To delete the microservices cluster using the Google Cloud CLI, run the following command:```\ngcloud container clusters delete online-boutique \\\u00a0 \u00a0 --location $REGION\n```\n## What's next\n- Learn more about [microservices architecture](https://cloud.google.com/learn/what-is-microservices-architecture) .\n- Read the first document in this series to learn about [microservices, their benefits, challenges, and use cases](/architecture/microservices-architecture-introduction) .\n- Read the second document in this series to learn about [application refactoring strategies to decompose microservices](/architecture/microservices-architecture-refactoring-monoliths) .\n- Read the final document in this series to learn about [distributed tracing of requests between microservices](/architecture/microservices-architecture-distributed-tracing) .", "guide": "Docs"}