{"title": "Docs - Architecture for MLOps using TensorFlow Extended, Vertex AI Pipelines, and Cloud Build", "url": "https://cloud.google.com/architecture/architecture-for-mlops-using-tfx-kubeflow-pipelines-and-cloud-build", "abstract": "# Docs - Architecture for MLOps using TensorFlow Extended, Vertex AI Pipelines, and Cloud Build\nLast reviewed 2023-01-20 UTC\nThis document describes the overall architecture of a machine learning (ML) system using [TensorFlow Extended (TFX)](https://www.tensorflow.org/tfx) libraries. It also discusses how to set up a continuous integration (CI), continuous delivery (CD), and continuous training (CT) for the ML system using [Cloud Build](/build/docs) and [Vertex AI Pipelines](/vertex-ai/docs/pipelines/introduction) .\nIn this document, the terms and refer to ML model pipelines, rather than model or pipelines.\nThis document is for data scientists and ML engineers who want to adapt their CI/CD practices to move ML solutions to production on Google Cloud, and who want to help ensure the quality, maintainability, and adaptability of their ML pipelines.\nThis document covers the following topics:\n- Understanding CI/CD and automation in ML.\n- Designing an integrated ML pipeline with TFX.\n- Orchestrating and automating the ML pipeline using Vertex AI Pipelines.\n- Setting up a CI/CD system for the ML pipeline using Cloud Build.", "content": "## MLOps\nTo integrate an ML system in a production environment, you need to orchestrate the steps in your ML pipeline. In addition, you need to automate the execution of the pipeline for the continuous training of your models. To experiment with new ideas and features, you need to adopt CI/CD practices in the new implementations of the pipelines. The following sections give a high-level overview of CI/CD and CT in ML.\n### ML pipeline automation\nIn some use cases, the manual process of training, validating, and deploying ML models can be sufficient. This manual approach works if your team manages only a few ML models that aren't retrained or aren't changed frequently. In practice, however, models often break down when deployed in the real world because they fail to adapt to changes in the dynamics of environments, or the data that describes such dynamics.\nFor your ML system to adapt to such changes, you need to apply the following MLOps techniques:\n- Automate the execution of the ML pipeline to retrain new models on new data to capture any emerging patterns. CT is discussed later in this document in the [ML with Vertex AI Pipelines](#ml-with-vertex-pipelines) section.\n- Set up a continuous delivery system to frequently deploy new implementations of theML pipeline. CI/CD is discussed later in this document in the [CI/CD setup for ML on Google Cloud](#setting-up-ci-cd-for-ml-on-google-cloud) section.\nYou can automate the ML production pipelines to retrain your models with new data. You can trigger your pipeline on demand, on a schedule, on the availability of new data, on model performance degradation, on significant changes in the statistical properties of the data, or based on other conditions.\n### CI/CD pipeline compared to CT pipeline\nThe availability of new data is one trigger to retrain the ML model. The availability of a new implementation of the ML pipeline (including new model architecture, feature engineering, and hyperparameters) is another important trigger to re-execute the ML pipeline. This new implementation of the ML pipeline serves as a new version of the model prediction service, for example, a microservice with a REST API for online serving. The difference between the two cases is as follows:\n- To train a new ML model with new data, the previously deployed CT pipeline is executed. No new pipelines or components are deployed; only a new prediction service or newly trained model is served at the end of the pipeline.\n- To train a new ML model with a new implementation, a new pipeline is deployed through a CI/CD pipeline.\nTo deploy new ML pipelines quickly, you need to set up a CI/CD pipeline. This pipeline is responsible for automatically deploying new ML pipelines and components when new implementations are available and approved for various environments (such as development, test, staging, pre-production, canary, and production).\nThe following diagram shows the relationship between the CI/CD pipeline and the ML CT pipeline.\n**Figure 1** . CI/CD and ML CT pipelines.\nThe output for these pipelines is as follows:\n- If given new implementation, a successful CI/CD pipeline deploys a new ML CT pipeline.\n- If given new data, a successful CT pipeline trains a new model and deploys it as a prediction service.## Designing a TFX-based ML system\nThe following sections discuss how to design an integrated ML system using TensorFlow Extended (TFX) to set up a CI/CD pipeline for the ML system. Although there are several frameworks for building ML models, TFX is an integrated ML platform for developing and deploying production ML systems. A TFX pipeline is a sequence of components that implement an ML system. This TFX pipeline is designed for scalable, high-performance ML tasks. These tasks include modeling, training, validation, serving inference, and managing deployments. The key libraries of TFX are as follows:\n- [TensorFlow Data Validation (TFDV)](https://www.tensorflow.org/tfx/data_validation/get_started) : Used for detecting anomalies in the data.\n- [TensorFlow Transform (TFT)](https://www.tensorflow.org/tfx/transform/get_started) : Used for data preprocessing and feature engineering.\n- [TensorFlow Estimators and Keras](https://www.tensorflow.org/overview/) : Used for building and training ML models.\n- [TensorFlow Model Analysis (TFMA)](https://www.tensorflow.org/tfx/model_analysis/get_started) : Used for ML model evaluation and analysis.\n- [TensorFlow Serving (TFServing)](https://www.tensorflow.org/tfx/guide/serving) : Used for serving ML models as REST and gRPC APIs.\n### TFX ML system overview\nThe following diagram shows how the various TFX libraries are integrated to compose an ML system.\n**Figure 2** . A typical TFX-based ML system.\nFigure 2 shows a typical TFX-based ML system. The following steps can be completed manually or by an automated pipeline:\n- Data extraction: The first step is to extract the new training data from its data sources. The outputs of this step are data files that are used for training and evaluating the model.\n- Data validation: TFDV validates the data against the expected (raw) data schema. The data schema is created and fixed during the development phase, before system deployment. The data validation steps detect anomalies related to both data distribution and schema skews. The outputs of this step are the anomalies (if any) and a decision on whether to execute downstream steps or not.\n- Data transformation: After the data is validated, the data is split and prepared for the ML task by performing data transformations and feature engineering operations using TFT. The outputs of this step are data files to train and evaluate the model, usually transformed in [TFRecords](https://www.tensorflow.org/tutorials/load_data/tfrecord) format. In addition, the transformation artifacts that are produced help with constructing the model inputs and embed the transformation process in the exported saved model after training.\n- Model training and tuning: To implement and train the ML model, use the [tf.estimator](https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator) or [tf.Keras](https://www.tensorflow.org/guide/keras) APIs with the transformed data produced by the previous step. To select the parameter settings that lead to the best model, you can use [Keras tuner](https://keras.io/keras_tuner) , a hyperparameter tuning library for Keras. Alternatively, you can use other services like [Katib](https://www.kubeflow.org/docs/components/katib/hyperparameter/) , [Vertex AI Vizier](/vertex-ai/docs/vizier/overview) , or the hyperparameter tuner from [Vertex AI](/vertex-ai/docs/training/hyperparameter-tuning-overview) . The output of this step is a saved model that is used for evaluation, and another saved model that is used for online serving of the model for prediction.\n- Model evaluation and validation: When the model is exported after the training step, it's evaluated on a test dataset to assess the model quality by using TFMA. TFMA evaluates the model quality as a whole, and identifies which part of the data model isn't performing. This evaluation helps guarantee that the model is promoted for serving only if it satisfies the quality criteria. The criteria can include fair performance on various data subsets (for example, demographics and locations), and improved performance compared to previous models or a benchmark model. The output of this step is a set of performance metrics and a decision on whether to promote the model to production.\n- Model serving for prediction: After the newly trained model is validated, it's deployed as a microservice to serve online predictions using TensorFlow Serving. The output of this step is a deployed prediction service of the trained ML model. You can replace this step by storing the trained model in a model registry. Subsequently a separate model serving CI/CD process is launched.\nFor an example on how to use the TFX libraries, see the official [TFX Keras Component tutorial](https://www.tensorflow.org/tfx/tutorials/tfx/components_keras) .\n### TFX ML system on Google Cloud\nIn a production environment, the components of the system have to run at scale on a reliable platform. The following diagram shows how each step of the TFX ML pipeline runs using a managed service on Google Cloud, which ensures agility, reliability, and performance at a large scale.\n**Figure 3** . TFX-based ML system on Google Cloud.\nThe following table describes the key Google Cloud services shown in figure 3:\n| Step       | TFX Library    | Google Cloud service  |\n|:--------------------------------|:---------------------------|:-------------------------|\n| Data extraction and validation | TensorFlow Data Validation | Dataflow     |\n| Data transformation    | TensorFlow Transform  | Dataflow     |\n| Model training and tuning  | TensorFlow     | Vertex AI Training  |\n| Model evaluation and validation | TensorFlow Model Analysis | Dataflow     |\n| Model serving for predictions | TensorFlow Serving   | Vertex AI Prediction  |\n| Model Storage     | nan      | Vertex AI Model Registry |\n- [Dataflow](/dataflow/docs) is a fully managed, serverless, and reliable service for running [Apache Beam](https://beam.apache.org/) pipelines at scale on Google Cloud. Dataflow is used to scale the following processes:- Computing the statistics to validate the incoming data.\n- Performing data preparation and transformation.\n- Evaluating the model on a large dataset.\n- Computing metrics on different aspects of the evaluation dataset.\n- [Cloud Storage](/storage) is a highly available and durable storage for binary large objects. Cloud Storage hosts artifacts produced throughout the execution of the ML pipeline, including the following:- Data anomalies (if any)\n- Transformed data and artifacts\n- Exported (trained) model\n- Model evaluation metrics\n- [Vertex AI Training](/vertex-ai/docs/training-overview) is a managed service to train ML models at scale. You can execute model training jobs with [pre-build containers](/vertex-ai/docs/training/create-python-pre-built-container) for TensorFlow, Scikit learn, XGBoost and PyTorch. You can also run any framework using your own [custom containers](/vertex-ai/docs/training/containers-overview) . For your [training infrastructure](/vertex-ai/docs/training/configure-compute) you can use accelerators and multiple nodes for distributed training. In addition, a scalable, Bayesian optimization-based service for a [hyperparameter tuning](/vertex-ai/docs/training/hyperparameter-tuning-overview) is available\n- [Vertex AI Prediction](/vertex-ai/docs/predictions/overview) is a managed service to run [batch predictions](/vertex-ai/docs/predictions/get-predictions#get_batch_predictions) using your trained models and [online predictions](/vertex-ai/docs/predictions/get-predictions#get_online_predictions) by deploying your models as a microservice with a REST API. The service also integrates with [Vertex Explainable AI](/vertex-ai/docs/explainable-ai/overview) and [Vertex AI Model Monitoring](/vertex-ai/docs/model-monitoring/overview) to understand your models and receive alerts when there is a feature or feature attribution skew and drift.\n- [Vertex AI Model Registry](/vertex-ai/docs/model-registry/introduction) allows you to manage the lifecycle of your ML models. You can version your imported models and view their performance metrics. A model can then be used for batch predictions or deploy your model for online serving using Vertex AI Prediction## Orchestrating the ML system using Vertex AI Pipelines\nThis document has covered how to design a TFX-based ML system, and how to run each component of the system at scale on Google Cloud. However, you need an orchestrator in order to connect these different components of the system together. The orchestrator runs the pipeline in a sequence, and automatically moves from one step to another based on the defined conditions. For example, a defined condition might be executing the model serving step after the model evaluation step if the evaluation metrics meet predefined thresholds. Steps can also run in parallel in order to save time, for example validate the deployment infrastructure and evaluate the model. Orchestrating the ML pipeline is useful in both the development and production phases:\n- During the development phase, orchestration helps the data scientists to run the ML experiment, instead of manually executing each step.\n- During the production phase, orchestration helps automate the execution of the ML pipeline based on a schedule or certain triggering conditions.\n### ML with Vertex AI Pipelines\n[Vertex AI Pipelines](/vertex-ai/docs/pipelines/introduction) is a Google Cloud managed service that allows you to orchestrate and automate ML pipelines where each component of the pipeline can run containerised on Google Cloud or other cloud platforms. Pipeline parameters and artifacts generated are automatically stored on [Vertex ML Metadata](/vertex-ai/docs/ml-metadata/introduction) which allows lineage and execution tracking. Vertex AI Pipelines service consists of the following:\n- A user interface for managing and tracking experiments, jobs, and runs.\n- An engine for scheduling multistep ML workflows.\\\n- A [Python SDK](https://www.kubeflow.org/docs/components/pipelines/v1/sdk/) for defining and manipulating pipelines and components.\n- Integration with [Vertex ML Metadata] to save information about executions, models, datasets, and other artifacts.\nThe following constitutes a pipeline executed on Vertex AI Pipelines:\n- A set of containerized ML tasks, or. A pipeline component is self-contained code that is packaged as a [Docker image](https://docs.docker.com/engine/reference/commandline/image/) . A component performs one step in the pipeline. It takes input arguments and produces artifacts.\n- A specification of the sequence of the ML tasks, defined through a Python [domain-specific language (DSL)](https://wikipedia.org/wiki/Domain-specific_language) . The topology of the workflow is implicitly defined by connecting the outputs of an upstream step to the inputs of a downstream step. A step in the pipeline definition invokes a component in the pipeline. In a complex pipeline, components can execute multiple times in loops, or they can be executed conditionally.\n- A set of pipeline input parameters, whose values are passed to the components of the pipeline, including the criteria for filtering data and where to store the artifacts that the pipeline produces.\nThe following diagram shows a sample graph of Vertex AI Pipelines.\n**Figure 4** . A sample graph of Vertex AI Pipelines.\n### Kubeflow Pipelines SDK\nThe [Kubeflow Pipelines SDK](https://www.kubeflow.org/docs/components/pipelines/v1/sdk/sdk-overview/) . allows you to create components, define their orchestration and run them as a pipeline. For a component to be invoked in the pipeline, you need to create a . You can create a component op using the following methods:\n- Implementing a [lightweight Python component](https://www.kubeflow.org/docs/pipelines/sdk/lightweight-python-components/) : This component doesn't require that you build a new container image for every code change, and is intended for fast iteration in a notebook environment. You can create a lightweight component from your Python function using the [kfp.components.create_component_from_func](https://www.kubeflow.org/docs/components/pipelines/v1/sdk/python-function-components/#getting-started-with-python-function-based-components) function or using the [@component decorator](https://www.kubeflow.org/docs/components/pipelines/v1/sdk-v2/python-function-components/#getting-started-with-python-function-based-components) .\n- Creating [reusable component](https://www.kubeflow.org/docs/components/pipelines/v1/sdk/component-development/) : This functionality requires that your component includes a [component specification](https://www.kubeflow.org/docs/components/pipelines/v1/sdk-v2/component-development/#creating-a-component-specification) in the component.yaml file. The component specification describes the component to the Kubeflow Pipelines in terms of arguments, the Docker container image URL to execute, and the outputs. Component ops are automatically created from the component.yaml files using the kfp.components.load_component function during pipeline compilation. Component specification YAML files can be shared within your organization and reused in different pipeline orchestrations.\n- Using [predefined Google Cloud components](/vertex-ai/docs/pipelines/gcpc-list) : Google Cloud Pipeline Components SDK provides predefined components that execute various managed services on Google Cloud by providing the required parameters. These components help you execute tasks using services such as BigQuery, Dataflow, Dataproc, and Vertex AI. For ease of use you can load those components using the [google_cloud_pipeline_components SDK](https://pypi.org/project/google-cloud-pipeline-components/) . Other [predefined components](https://github.com/kubeflow/pipelines/tree/master/components) . are available for executing jobs on other platforms and services.\nYou can also use the [TFX Pipeline DSL](https://www.tensorflow.org/tfx/guide#core_concepts) and use [TFX components](https://www.tensorflow.org/tfx/guide#anatomy_of_a_component) . A TFX component encapsulates metadata functionality. The driver supplies metadata to the executor by querying the metadata store. The publisher accepts the results of the executor and stores them in metadata. You can also implement your [custom component](https://www.tensorflow.org/tfx/guide/custom_component) , which have the same integration with the metadata. You can compile your TFX pipelines to a Vertex AI Pipelines compatible YAML using [tfx.orchestration.experimental.KubeflowV2DagRunner](https://www.tensorflow.org/tfx/tutorials/tfx/gcp/vertex_pipelines_simple#run_the_pipeline_on_vertex_pipelines) . Then you can submit the file to Vertex AI Pipelines for execution.\nThe following diagram shows how in Vertex AI Pipelines, a containerized task can invoke other services such as BigQuery jobs, Vertex AI (distributed) training jobs, and Dataflow jobs.\n**Figure 5** . Vertex AI Pipelines invoking Google Cloud managed services.\nVertex AI Pipelines lets you orchestrate and automate a production ML pipeline by executing the required Google Cloud services. In figure 5, Vertex ML Metadata serves as the ML metadata store for Vertex AI Pipelines.\nPipeline components aren't limited to executing TFX-related services on Google Cloud. These components can execute any data-related and compute-related services, including [Dataproc](/dataproc) for SparkML jobs, [AutoML](/automl) , and other compute workloads.\nContainerizing tasks in Vertex AI Pipelines has the following advantages:\n- Decouples the execution environment from your code runtime.\n- Provides reproducibility of the code between the development and production environment, because the things you test are the same in production.\n- Isolates each component in the pipeline; each can have its own version of the runtime, different languages, and different libraries.\n- Helps with composition of complex pipelines.\n- Integrates with Vertex ML Metadata for traceability and reproducibility of pipeline executions and artifacts.\nFor a comprehensive introduction to Vertex AI Pipelines, see the list of available [notebooks examples](/vertex-ai/docs/pipelines/notebooks) .\n### Triggering and scheduling Vertex AI Pipelines\nWhen you deploy a pipeline to production, you need to automate its executions, depending on the scenarios discussed in the [ML pipeline automation](#ml-pipeline-automation) section.\nThe [Vertex AI SDK](/vertex-ai/docs/start/client-libraries) allows you to operate the pipeline programmatically. The [google.cloud.aiplatform.PipelineJob class](/python/docs/reference/aiplatform/latest/google.cloud.aiplatform.PipelineJob) includes APIs to create experiments, and to deploy and run pipelines. By using the SDK, you can therefore invoke Vertex AI Pipelines from another service to achieve scheduler or event based triggers.\n**Figure 6** . Flow diagram demonstrating multiple triggers for Vertex AI Pipelines using Pub/Sub and Cloud Functions\nIn figure 6 you can see an example on how to trigger the Vertex AI Pipelines service to execute a pipeline. The pipeline is triggered using the Vertex AI SDK from a Cloud Functions. The Cloud Functions itself is a subscriber to the Pub/Sub and is triggered based on new messages. Any service that wants to trigger the execution of the pipeline can simply publish on the corresponding Pub/Sub topic. In the above example we have 3 publishing services:\n- [Cloud Scheduler](/scheduler) is publishing messages on a schedule and therefore triggering the pipeline.\n- [Cloud Composer ](/composer/docs) is publishing messages as part of a larger workflow, for example a data ingestion workflow that triggers the training pipeline after new data are ingested in BigQuery\n- [Cloud Logging](/logging) publishes a message based on logs that meet some filtering criteria. You can set up the filters to detect the arrival of new data or even skew and drift alerts generated by the [Vertex AI Model Monitoring](/vertex-ai/docs/model-monitoring/using-model-monitoring#monitor-job) service.## Setting up CI/CD for ML on Google Cloud\nVertex AI Pipelines enables you to orchestrate ML systems that involve multiple steps, including data preprocessing, model training and evaluation, and model deployment. In the data science exploration phase, Vertex AI Pipelines help with rapid experimentation of the whole system. In the production phase, Vertex AI Pipelines enables you to automate the pipeline execution based on new data to train or retrain the ML model.\n### CI/CD architecture\nThe following diagram shows a high-level overview of CI/CD for ML with Vertex AI Pipelines.\n**Figure 7** : High-level overview of CI/CD with Vertex AI Pipelines.\nAt the heart of this architecture is [Cloud Build](/build) . Cloud Build can import source from [Cloud Source Repositories](/source-repositories) , [GitHub](https://github.com/) , or [Bitbucket](https://bitbucket.org/) , and then execute a build to your specifications, and produce artifacts such as Docker containers or Python tar files.\nCloud Build executes your build as a series of build steps, defined in a [build configuration file](/build/docs/build-config) ( `cloudbuild.yaml` ). Each build step runs in a Docker container. You can either [use the supported build steps](/build/docs/cloud-builders#supported_builder_images_provided_by) provided by Cloud Build, or [write your own build steps](/build/docs/configuring-builds/use-community-and-custom-builders#creating_a_custom_builder) .\nThe Cloud Build process, which performs the required CI/CD for your ML system, can be executed either [manually](/build/docs/running-builds/submit-build-via-cli-api) or through [automated build triggers](/build/docs/automating-builds/create-manage-triggers) . Triggers execute your configured build steps whenever changes are pushed to the build source. You can set a build trigger to execute the build routine on changes to the source repository, or to execute the build routine only when changes match certain criteria.\nIn addition, you can have build routines (Cloud Build configuration files) that are executed in response to different triggers. For example, you can have build routines that are triggered when commits are made to the development branch or to the master branch.\nYou can use configuration variable [substitutions](/build/docs/build-config#substitutions) to define the environment variables at build time. These substitutions are captured from triggered builds. These variables include `$COMMIT_SHA` , `$REPO_NAME` , `$BRANCH_NAME` , `$TAG_NAME` , and `$REVISION_ID` . Other non-trigger-based variables are `$PROJECT_ID` and `$BUILD_ID` . Substitutions are helpful for variables whose value isn't known until build time, or to reuse an existing build request with different variable values.\n### CI/CD workflow use case\nA source code repository typically includes the following items:\n- The Python pipelines workflow source code where the pipeline workflow is defined\n- The Python pipeline components source code and the corresponding component specification files for the different pipeline components such as data validation, data transformation, model training, model evaluation, and model serving.\n- Dockerfiles that are required to create Docker container images, one for each pipeline component.\n- Python unit and integration tests to test the methods implemented in the component and overall pipeline.\n- Other scripts, including the`cloudbuild.yaml`file, test triggers and pipeline deployments.\n- Configuration files (for example, the`settings.yaml`file), including configurations to the pipeline input parameters.\n- Notebooks used for exploratory data analysis, model analysis, and interactive experimentation on models.\nIn the following example, a build routine is triggered when a developer pushes source code to the development branch from their data science environment.\n**Figure 8** . Example build steps performed by Cloud Build.\nAs shown in figure 7, Cloud Build performs the following build steps:\n- The source code repository is copied to the Cloud Build runtime environment, under the`/workspace`directory.\n- Run Unit and Integration tests.\n- (Optional) Static code analysis is run, such as [Pylint](http://pylint.pycqa.org/en/latest/) .\n- If the tests pass, the Docker container images are built, one for each pipeline component. The images are tagged with the`$COMMIT_SHA`parameter.\n- The Docker container images are uploaded to the Artifact Registry.\n- The image URL is updated in each of the`component.yaml`files with the created and tagged Docker container images.\n- The pipeline workflow is compiled to produce the`pipeline.json`file.\n- The`pipeline.json`file is uploaded to Artifact Registry.\n- (Optional) Run the pipeline with the parameter values as part of an integration test or production execution. The executed pipeline generates a new model and could also deploy the model as an API on Vertex AI Prediction.\nFor a production ready end to end MLOps example that includes for CI/CD using Cloud Build, see our [official guide](https://github.com/GoogleCloudPlatform/vertex-pipelines-end-to-end-samples) on GitHub.\n### Additional considerations\nWhen you set up the ML CI/CD architecture on Google Cloud, consider the following:\n- For the data science environment, you can use a local machine, or a [Vertex AI Workbench](/vertex-ai/docs/workbench/introduction) .\n- You can configure the automated Cloud Build pipeline to [skip triggers](/build/docs/running-builds/automate-builds#skipping_a_build_trigger) , for example, if only documentation files are edited, or if the experimentation notebooks are modified.\n- You can execute the pipeline for integration and regression testing as a build test. Before the pipeline is deployed to the target environment, you can use the [wait()](/python/docs/reference/aiplatform/latest/google.cloud.aiplatform.PipelineJob#google_cloud_aiplatform_PipelineJob_wait) method to wait for the submitted pipeline run to complete.\n- As an alternative to using Cloud Build, you can use other build systems such as [Jenkins](https://jenkins.io/) . A ready-to-go deployment of Jenkins is available on [Google Cloud Marketplace.](https://console.cloud.google.com/marketplace/details/google/jenkins) \n- You can configure the pipeline to deploy automatically to different environments, including development, test, and staging, based on different triggers. In addition, you can deploy to particular environments manually, such as pre-production or production, typically after getting a release approval. You can have multiple build routines for different triggers or for different target environments.\n- You can use [Apache Airflow](https://airflow.apache.org/) , a popular orchestration and scheduling framework, for general-purpose workflows, which you can run using the fully managed [Cloud Composer](/composer/docs) service. For more information on how to orchestrate data pipelines with Cloud Composer and Cloud Build, see [Setting up a CI/CD pipeline for your data-processing workflow](/solutions/cicd-pipeline-for-data-processing) .\n- When you deploy a new version of the model to production, deploy it as a canary release to get an idea of how it will perform (CPU, memory, and disk usage). Before you configure the new model to serve all live traffic, you can also perform A/B testing. Configure the new model to serve 10% to 20% of the live traffic. If the new model performs better than current one, you can configure the new model to serve all traffic. Otherwise, the serving system rolls back to the current model.## What's next\n- Learn more about [GitOps-style continuous delivery with Cloud Build](/kubernetes-engine/docs/tutorials/gitops-cloud-build) .\n- Learn more about [Setting up a CI/CD pipeline for your data-processing workflow](/solutions/cicd-pipeline-for-data-processing) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Docs"}