{"title": "Docs - Tutorial: Using Memorystore for Redis as a game leaderboard", "url": "https://cloud.google.com/architecture/using-memorystore-for-redis-as-a-leaderboard", "abstract": "# Docs - Tutorial: Using Memorystore for Redis as a game leaderboard\nThis tutorial shows you how to use [Memorystore for Redis](/memorystore) to build an ASP.NET-based leaderboard application running on [Google Kubernetes Engine](/kubernetes-engine) (GKE), and then post and retrieve scores using a separate JavaScript-based sample game. This document is intended for game developers who want to operate their own leaderboards in the cloud.", "content": "## IntroductionLeaderboards are a common feature in multiplayer games. A leaderboard shows player rankings in real time, which helps encourage players to be more engaged in the game. To capture player actions and rank the score in real time, an in-memory database like Redis is a great choice.\nThe following diagram shows the infrastructure of the leaderboard:In Google Cloud, the leaderboard consists of a GKE cluster inside a VPC network, and a separate Memorystore for Redis instance.\nThe following diagram shows the application architecture for this tutorial. Clients use the leaderboard API to interact with the scores that are maintained in a Memorystore for Redis instance running in Google Cloud.\n### Methods of the leaderboard APIThe API for the leaderboard application includes the following methods:- `PostScore(string playerName, double score)`. This method posts a score to the leaderboard for the specified player.\n- `RetrieveScores(string centerKey, int offset, int numScores)`. This method downloads a set of scores. If you pass a player ID as the value for`centerKey`, the method returns the scores that are above and below those of the specified player. If you don't pass a value for`centerKey`, the method returns the top N absolute scores, where N is the value you pass in`numScores`. For example, to get the top 10 scores, call`RetrieveScores('', 0, 10)`. To get 5 scores above and below a player's score, call`RetrieveScores('player1', -5, 10)`.\nThe code repository for the example includes a mock game and a proof-of-concept leaderboard implementation. During this tutorial, you deploy the game and leaderboard and validate that the leaderboard API works correctly and can be accessed over the internet.## Objectives\n- Create a Memorystore for Redis instance.\n- Create a headless service with an endpoint that directs requests to this instance.\n- Deploy the leaderboard application to GKE.\n- Verify leaderboard functionality using the deployed application that makes API calls.\n## Costs\nIn this document, you use the following billable components of Google Cloud:- [Google Kubernetes Engine](/kubernetes-engine/pricing) \n- [Memorystore for Redis](/memorystore/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . ## Before you begin\n## Preparing your environmentIn this tutorial, you run commands in Cloud Shell. Cloud Shell gives you access to the command line in Google Cloud, and includes the Google Cloud CLI and other tools that you need for Google Cloud development. Cloud Shell can take several minutes to initialize.- Open Cloud Shell: [Open Cloud Shell](https://console.cloud.google.com/?cloudshell=true) \n- Set the default Compute Engine zone to the zone where you're going to create your Google Cloud resources. In this tutorial, you use the `us-central1-a` zone in the `us-central1` region.```\nexport REGION=us-central1\nexport ZONE=us-central1-a\ngcloud config set compute/zone $ZONE\n```\n- Clone the GitHub repository that contains the sample code:```\ngit clone https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard.git\n```\n- Go to the cloned directory:```\ncd memstore-gaming-leaderboard\n```\n- Using a text editor, open the `leaderboardapp/k8s/appdeploy.yaml` file and change the `[YOUR_PROJECT_ID]` placeholder to your Google Cloud project ID.\n## Creating a Memorystore for Redis instanceFor this tutorial, you create a Basic Tier instance of Memorystore for Redis, which is appropriate for testing and the scope of this tutorial. For a production deployment, we recommend that you deploy a Standard Tier instance, which provides a 99.9% SLA with automatic failover to ensure that your instance is highly available. For details on Standard Tier instances, see [high availability for Memorystore for Redis](/memorystore/docs/redis/high-availability) .- In Cloud Shell, create a 1 GB Memorystore for Redis instance:```\ngcloud redis instances create cm-redis --size=1 \\\n --tier=basic \\\n --region=$REGION \\\n --zone=$ZONE\n```This command might take a few minutes to complete.\n## Building the application container imagesFor this tutorial, you deploy a simple leaderboard application using GKE. Because Unity and C# are popular in gaming, the application tier uses C# and the ASP.NET framework.\nTo deploy the leaderboard API to a GKE cluster, you need to first upload it to a registry like Container Registry.- Open the`README.md`file in the GitHub project that you cloned.\n- Follow the instructions for creating a Docker image and uploading it to Container Registry.\nYou'll use this image to deploy the leaderboard application after you create the cluster in the next section.## Creating or reusing a GKE clusterBefore you deploy the leaderboard application, you must create a GKE cluster with [alias IP ranges enabled](https://cloud.google.com/kubernetes-engine/docs/how-to/alias-ips) . If you already have a GKE cluster (using alias IP ranges), you can use that cluster for this tutorial. If you use an existing cluster, you must perform an additional step to configure the `kubectl` command-line tool with credentials for that cluster.- If you want to create a cluster, create one named `leaderboard` that has two nodes:```\ngcloud container clusters create leaderboard --num-nodes=2 --enable-ip-alias\n```This command can take a few minutes to complete.\n- After waiting for the cluster to start, verify that it's running:```\ngcloud container clusters list\n```The cluster is running when you see an entry that has the name `leaderboard` whose status is `RUNNING` .\n### Configure credentials for an existing cluster\n- If you're using an existing GKE cluster for this tutorial, configure the `kubeconfig` file with the credentials for that cluster. For , use the name of your cluster. **Note:** You don't need to perform this step if you created the cluster in the previous steps.```\ngcloud container clusters get-credentials name-of-existing-cluster\n```\n## Mapping the Memorystore for Redis instance to a Kubernetes serviceWhen the Memorystore for Redis instance is ready, you make a service inside the GKE cluster so that the application tier can connect.- Verify that the Memorystore for Redis instance is running:```\ngcloud redis instances list --region=$REGION\n```You see output like the following:```\nINSTANCE_NAME VERSION REGION   TIER  SIZE_GB HOST  PORT NETWORK RESERVED_IP STATUS CREATE_TIME\ncm-redis  REDIS_4_0 us-central1  STANDARD 1   10.0.0.3 6379 default 10.0.0.0/29 READY  2019-05-10T04:37:45\n```The instance is running when the `STATUS` column shows `READY` . If the `HOST` field is empty, the instance has not completed the startup process. Wait a moment and run the `redis instances list` command again.\n- Store the IP address of the instance in an environment variable:```\nexport REDIS_IP=$(gcloud redis instances list --filter=\"name:cm-redis\" --format=\"value(HOST)\" \\\n --region=$REGION)\n```\n- Create the Kubernetes service for Redis:```\nkubectl apply -f k8s/redis_headless_service.yaml\n```This service doesn't have a Pod selector, because you want it to point at an IP address that's outside of the Kubernetes cluster.\n- Create an endpoint that defines the Redis IP address that you retrieved earlier:```\nsed \"s|REDIS_IP|${REDIS_IP}|g\" k8s/redis_endpoint.yaml | kubectl apply -f \n```\n- Verify that the service and endpoint were created correctly:```\nkubectl get services/redis endpoints/redis\n```If everything is working correctly, you see output like the following, with an entry for the Redis service and the Redis endpoint:```\nNAME    TYPE  CLUSTER-IP  EXTERNAL-IP PORT(S) AGE\nservice/redis  ClusterIP 10.59.241.103 none  6379/TCP 5m\nNAME    ENDPOINTS  AGE\nendpoints/redis 10.0.0.3:6379 4m\n```\nFor more information about Kubernetes services and endpoints, see [Kubernetes best practices: mapping external services](/blog/products/gcp/kubernetes-best-practices-mapping-external-services) on the Google Cloud blog.## Deploying the leaderboard app and service to KubernetesThe Redis instance is now reachable from an application that's deployed in the GKE cluster. Therefore, you're ready to deploy the leaderboard app.- Follow the instructions in the`README.md`file included in the root of the GitHub repo that you cloned earlier.\n## Validating the deploymentThe mock game application provided, written in JavaScript, can be used to make calls to the leaderboard API. The following code snippet shows how the mock game posts scores after the player finishes playing:\n [  leaderboardapp/Views/Home/Index.cshtml ](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/Views/Home/Index.cshtml) [View on GitHub](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/Views/Home/Index.cshtml) \n```\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var scoreInfo = {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 playerName: this.username,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 score: this.calculateScore().toFixed(2)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 };\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var pThis = this;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var postUrl = \"/api/score\";\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (async () => {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 await axios.post(postUrl, scoreInfo)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } catch (error) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 console.error(error);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var lbPromise = pThis.fetchLeaderboard();\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var qPromise = pThis.fetchQuestions();\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pThis.questions = await qPromise;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 await lbPromise;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })();\n```\nIn addition, the app makes an API call to retrieve the leaderboard scores\u2014either the top scores or scores centered around the player's name, like this:\n [  leaderboardapp/Views/Home/Index.cshtml ](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/Views/Home/Index.cshtml) [View on GitHub](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/Views/Home/Index.cshtml) \n```\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var pThis = this;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var getUrl = \"/api/score/retrievescores\";\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (async () => {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 try {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var params = {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 centerKey: '',\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 offset: 0,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 numScores: 11\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 };\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (pThis.centered) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 params.centerKey = pThis.username;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 params.offset = -5;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 params.numScores = 11;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const response = await axios.get(getUrl, { params: params });\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 pThis.leaderboard = response.data;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 } catch (error) {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 console.error(error);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return []\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 })();\n```\nTo access the sample application, follow these steps:- Get the IP address of the mock game by running the following command:```\nkubectl get ingress\n```The output is similar to the following:```\nNAME      HOSTS ADDRESS  PORTS AGE\nmemstore-gaming-ingress *  34.102.192.4 80  43s\n```\n- Browse to the following URL, where is the address for the mock game:```\nhttp://ip_address_for_gke.\n```\nThis sample is simple, but it's adequate for demonstrating basic API usage. When you post or retrieve scores directly from a game client app that's running on a user device or machine, the sample calls the leaderboard API at the public IP address assigned to its Kubernetes Load Balancer object. For this sample application, both the leaderboard API and the JavaScript client are hosted at the same IP address that you get using the `kubectl get ingress` command shown earlier.## How the methods are implementedThe leaderboard application, written in C#, uses the [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis) library for communicating with Redis. The code snippets that follow show how `PostScore` and `RetrieveScores` are implemented using Redis and the `StackExchange.Redis` library.\nThe following code snippet shows the `PostScore` method:\n [  leaderboardapp/RedisLeaderboardRepo.cs ](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/RedisLeaderboardRepo.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/RedisLeaderboardRepo.cs) \n```\n\u00a0 \u00a0 \u00a0 \u00a0 public async Task<bool> PostScoreAsync(ScoreModel score)\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IDatabase db = _redis.GetDatabase();\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // SortedSetAddAsync corresponds to ZADD\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return await db.SortedSetAddAsync(LEADERBOARD_KEY, score.PlayerName, score.Score);\u00a0 \u00a0 \u00a0 \u00a0 }\n```\nThe following code snippet shows the `RetrieveScores` method:\n [  leaderboardapp/RedisLeaderboardRepo.cs ](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/RedisLeaderboardRepo.cs) [View on GitHub](https://github.com/GoogleCloudPlatform/memstore-gaming-leaderboard/blob/HEAD/leaderboardapp/RedisLeaderboardRepo.cs) \n```\n\u00a0 \u00a0 \u00a0 \u00a0 public async Task<IList<LeaderboardItemModel>> RetrieveScoresAsync(RetrieveScoresDetails retrievalDetails)\u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 IDatabase db = _redis.GetDatabase();\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 List<LeaderboardItemModel> leaderboard = new List<LeaderboardItemModel>();\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 long offset = retrievalDetails.Offset;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 long numScores = retrievalDetails.NumScores;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // If centered, get rank of specified user first\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!string.IsNullOrWhiteSpace(retrievalDetails.CenterKey))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // SortedSetRankAsync corresponds to ZREVRANK\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var rank = await db.SortedSetRankAsync(LEADERBOARD_KEY, retrievalDetails.CenterKey, Order.Descending);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // If specified user is not present, return empty leaderboard\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if (!rank.HasValue)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return leaderboard;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Use rank to calculate offset\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 offset = Math.Max(0, rank.Value + retrievalDetails.Offset);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // Account for number of scores when we're attempting to center\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // at element in rank [0, abs(offset))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if(offset <= 0)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 numScores = rank.Value + Math.Abs((long)retrievalDetails.Offset) + 1;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 // SortedSetRangeByScoreWithScoresAsync corresponds to ZREVRANGEBYSCORE [WITHSCORES]\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var scores = await db.SortedSetRangeByScoreWithScoresAsync(LEADERBOARD_KEY,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 skip: offset,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 take: numScores,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 order: Order.Descending);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var startingRank = offset;\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for (int i = 0; i < scores.Length; i++)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 var lbItem = new LeaderboardItemModel\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Rank = startingRank++,\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 PlayerName = scores[i].Element.ToString(),\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Score = scores[i].Score\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 };\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 leaderboard.Add(lbItem);\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return leaderboard;\u00a0 \u00a0 \u00a0 \u00a0 }\n```## Additions to the sample gameThe leaderboard API follows REST conventions and is provided only as an example. When you run a production game leaderboard, we recommend integrating an authentication flow so that only scores that are from validated users can be posted.\nCurrently, Memorystore for Redis doesn't provide persistence for player scores. Therefore, if the app experiences an issue, you could lose the leaderboard information. If your game requires a persistent leaderboard, you should back up the leaderboard scores periodically in a persistent database.## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this tutorial, delete the project.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n## What's next\n- Review key [Memorystore for Redis concepts](/memorystore/docs/redis/concepts) .\n- Learn more about leaderboard concepts with the [Google Play Games Services documentation](https://developers.google.com/games/services/common/concepts/leaderboards) .", "guide": "Docs"}