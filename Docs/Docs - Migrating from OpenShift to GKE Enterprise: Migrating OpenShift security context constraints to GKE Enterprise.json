{"title": "Docs - Migrating from OpenShift to GKE Enterprise: Migrating OpenShift security context constraints to GKE Enterprise", "url": "https://cloud.google.com/architecture/migrating-containers-openshift-anthos-scc", "abstract": "# Docs - Migrating from OpenShift to GKE Enterprise: Migrating OpenShift security context constraints to GKE Enterprise\nLast reviewed 2022-01-24 UTC\nThis document helps you to plan migration of security policies from [OpenShift security context constraints (SCCs)](https://docs.openshift.com/container-platform/latest/authentication/managing-security-context-constraints.html) defined on a source OpenShift cluster to a target GKE cluster. The implementation uses [Policy Controller](/anthos-config-management/docs/concepts/policy-controller) constraints to define the migrated policies on the target cluster.\nThe document assumes that you are familiar with [Migrating containers to Google Cloud: Migrating from OpenShift to GKE Enterprise](/architecture/migrating-containers-openshift-anthos) . It assumes that you are familiar with OpenShift and Security Context Constraints and that you have access to a source OpenShift cluster and a target GKE cluster.\nThis document is part of a multi-part series about migrating to Google Cloud. For an overview of the series, see [Migration to Google Cloud: Choosing your migration path](/architecture/migration-to-gcp-choosing-your-path) .\nThis document is part of a series that discusses migrating [containers](https://wikipedia.org/wiki/OS-level_virtualization) to Google Cloud:\n- [Migrating containers to Google Cloud: Migrating Kubernetes to Google Kubernetes Engine (GKE)](/architecture/migrating-containers-kubernetes-gke) \n- [Migrating containers to Google Cloud: Migrating from OpenShift to GKE Enterprise](/architecture/migrating-containers-openshift-anthos) \n- [Migrating containers to Google Cloud: Migrate OpenShift projects to GKE Enterprise](/architecture/migrating-containers-openshift-anthos-projects) \n- Migrating from OpenShift to GKE Enterprise: Migrate OpenShift SCCs to Policy Controller constraints (this document)\nThis document is useful if you're planning to migrate [OpenShift SCCs](https://docs.openshift.com/container-platform/latest/authentication/managing-security-context-constraints.html) to [GKE Enterprise](/anthos) . This document is also useful if you're evaluating the opportunity to migrate and want to explore what it might look like.\nThis document relies on concepts covered in [Migration to Google Cloud: Getting started](/architecture/migration-to-gcp-getting-started) , in [Migrating containers to Google Cloud: Migrating Kubernetes to GKE](/architecture/migrating-containers-kubernetes-gke) , in [Migrating containers to Google Cloud: Migrating from OpenShift to GKE Enterprise](/architecture/migrating-containers-openshift-anthos) , and in [Best practices for GKE networking](/kubernetes-engine/docs/best-practices/networking) . It includes links to those documents where appropriate.\n", "content": "## OpenShift SCCs\nSCCs are OpenShift-specific resources that are used to define policies for Pods that specify the actions that a Pod can perform and what resources it can access on nodes. When you make an API request to create a pod, SCCs evaluate Pod requests in terms of [process privileges](https://github.com/opencontainers/runtime-spec/blob/master/config.md#linux-process) against a set of policies that are defined through the SCC. The SCCs evaluate the requests to allow or disallow the execution of the Pods according to configured policies. For more information about OpenShift SCCs, see [Managing security context constraints](https://docs.openshift.com/container-platform/latest/authentication/managing-security-context-constraints.html) .\n### Default OpenShift SCCs\nOpenShift 4.x clusters contain a set of default SCCs that are described in the [Managing SCCs in OpenShift](https://cloud.redhat.com/blog/managing-sccs-in-openshift) blog post by Red Hat.\n## Config Sync and Policy Controller\nThis section describes Config Sync and Policy Controller. This section provides links to the relevant documentation and guidance to set up Policy Controller to perform migration tasks described later in this document.\n### Config Sync\n[Config Sync](/anthos-config-management/docs/config-sync-overview) lets you use a common Git-compliant repository to centrally define the configuration of any resource that applies to any GKE Enterprise-managed Kubernetes cluster. You apply that configuration to multiple clusters.\n### Policy Controller\n[Policy Controller](/anthos-config-management/docs/concepts/policy-controller) is a Kubernetes [dynamic admission controller](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/) that checks, audits, and enforces the compliance of your clusters against centrally defined policies. Policy Controller is based on the [Open Policy Agent (OPA) Gatekeeper](https://github.com/open-policy-agent/gatekeeper) open source project.\n### Config Sync and Policy Controller setup\nTo prepare to implement security policies that mirror the OpenShift SCCs, you enable [Config Sync](/anthos-config-management/docs/how-to/installing-config-sync) and [Policy Controller](/anthos-config-management/docs/how-to/installing-policy-controller) components for each of your target clusters. This section describes how to set up these components. The [Migrate OpenShift SCCs](#migrate-openshift-scc-to-anthos-config-management-policy-controller-constraints) section later in this document describes how to use Policy Controller constraint templates to implement the security policies.\nWhen you set up Policy Controller, it's a good practice to put system-related namespaces that don't run application Pods into the **Exempt namespaces** field. Exempting system-related namespaces helps you to avoid the risk of blocking any system Pod that requires elevated privileges. System-related namespaces on an GKE cluster can include the following:\n- `kube-system`\n- `kube-public`\n- `gke-connect`\n- `gke-system`\n- `config-management-system`\n- `config-management-monitoring`\n- `gatekeeper-system`\n- `istio-system`\n- `cnrm-system`\n- `knative-serving`\n- `monitoring-system`\nAfter you set up Policy Controller with the preceding exceptions, exclude the namespaces from constraints application by adding the `admission.gatekeeper.sh/ignore=true` label to each namespace. If you don't add the label to each namespace, system Pods (and therefore your entire cluster) can be affected by restrictive policies.\n## Migrate OpenShift SCCs to Policy Controller constraints\nThis section describes how you can export SCCs from your OpenShift cluster and configure target GKE Enterprise Policy Controller constraints to match the required policies. This section also describes some differences between SCCs and Policy Controller constraints so that you can plan your migration accordingly.\n### Assess OpenShift SCCs\nTo export a list and configuration of the SCCs that are installed in your OpenShift cluster, you can use the following commands:\n- Get a list of all SCCs:```\noc get scc\n```\n- Export the configuration of each SCC:```\noc get scc SCC_NAME > SCC_NAME.yaml\n```Replace with the name of the SCC for which you want to export the configuration.\nAfter you export the configuration, you can analyze it and use the table in the following [Map OpenShift SCCs](#map-openshift-scc-to-policy-controller-constraints-templates) section to configure Policy Controller constraints that match your application security requirements.\n### Map OpenShift SCCs to Policy Controller constraints templates\nThe following table provides the Policy Controller constraints and settings that correspond to OpenShift SCC fields and their possible values. Use the table to help configure target Policy Controller constraints that match the application security requirements that were implemented through OpenShift SCCs in the source environment. The [Example end-to-end migration](#example_of_end-to-end_migration) section later in this document provides an example of how to use the information in the table.\n| OpenShift SCC field   | Type / possible values                                                                                               | Policy Controller constraint template | Policy Controller constraint specification                                                                           |\n|:-------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| allowPrivilegedContainer:  | Boolean                                                                                                   | K8sPSPPrivilegedContainer    | Prevents privileged containers if applied.                                                                           |\n| allowHostIPC:     | Boolean                                                                                                   | K8sPSPHostNamespace      | Prevents access to host pid and ipc namespace if applied.                                                                       |\n| allowHostPID:     | Boolean                                                                                                   | K8sPSPHostNamespace      | Prevents access to host pid and ipc namespace if applied.                                                                       |\n| allowHostNetwork:    | Boolean                                                                                                   | K8sPSPHostNetworkingPorts    | Has a boolean parameter to prevent access to host network and can define a range for accessible host ports.                                                          |\n| allowHostPorts:    | Boolean                                                                                                   | K8sPSPHostNetworkingPorts    | Has a boolean parameter to prevent access to host network and can define a range for accessible host ports.                                                          |\n| readOnlyRootFilesystem:  | Boolean                                                                                                   | K8sPSPReadOnlyRootFilesystem   | Lets you mount container root file system only as read-only if applied.                                                                   |\n| allowPrivilegeEscalation: true | Boolean                                                                                                   | K8sPSPAllowPrivilegeEscalationContainer | Prevents Pods with AllowPrivilegeEscalation security context set to true if applied.                                                                |\n| allowHostDirVolumePlugin:  | Boolean                                                                                                   | K8sPSPVolumeTypes      | Has a parameter to define list of allowed volume types (as in the SCC) including host directory.                                                             |\n| volumes:      | Array list with type of volumes allowed                                                                                           | K8sPSPVolumeTypes      | Has a parameter to define list of allowed volume types (as in the SCC) including host directory.                                                             |\n| allowedCapabilities:   | Array list of Linux capabilities that can be requested.                                                                                       | K8sPSPCapabilities      | Has parameters to define Linux capabilities that can be requested (allowedCapabilities) and that are forbidden (requiredDropCapabilites). Cannot be used to directly add or drop the listed capabilities as can be done in defaultAddCapabilities: and requiredDropCapabilities: in OpenShift SCCs.           |\n| defaultAddCapabilities:  | Array list of Linux capabilities that must be added to each container.                                                                                   | K8sPSPCapabilities      | Has parameters to define Linux capabilities that can be requested (allowedCapabilities) and that are forbidden (requiredDropCapabilites). Cannot be used to directly add or drop the listed capabilities as can be done in defaultAddCapabilities: and requiredDropCapabilities: in OpenShift SCCs.           |\n| requiredDropCapabilities:  | Array list of Linux capabilities that are automatically dropped from the Pod or container.                                                                              | K8sPSPCapabilities      | Has parameters to define Linux capabilities that can be requested (allowedCapabilities) and that are forbidden (requiredDropCapabilites). Cannot be used to directly add or drop the listed capabilities as can be done in defaultAddCapabilities: and requiredDropCapabilities: in OpenShift SCCs.           |\n| fsGroup:      | Has a type: key that can be one of the following: MustRunAs: Requires at least one range to be specified if not using pre-allocated values. RunAsAny: Allows any fsGroup ID to be specified.                                                     | K8sPSPAllowedUsers      | Lets you define rules that have a similar function to the type: key in SCC and id ranges for the runAsUser, runAsGroup, supplementalGroups, and fsGroup parameters. Can be used to define allowed ranges for User, Groups, Supplemental Groups, or FS Groups but not to set the user ID directly in the Pod as can be done in OpenShift SCCs. |\n| runAsUser:      | Has a type: key that can be one of the following: MustRunAs: Requires a runAsUser to be configured. MustRunAsRange: Requires minimum and maximum values to be defined if not using pre-allocated values from the namespace. MustRunAsNonRoot: Requires that the Pod be submitted with a non-zero runAsUser or have the USER directive defined in the image. RunAsAny: Allows any runAsUser to be specified. | K8sPSPAllowedUsers      | Lets you define rules that have a similar function to the type: key in SCC and id ranges for the runAsUser, runAsGroup, supplementalGroups, and fsGroup parameters. Can be used to define allowed ranges for User, Groups, Supplemental Groups, or FS Groups but not to set the user ID directly in the Pod as can be done in OpenShift SCCs. |\n| supplementalGroups:   | Has a type: key that can be one of the following: MustRunAs: Requires at least one range to be specified if not using pre-allocated values from the namespace RunAsAny: Allows any supplementalGroups to be specified.                                              | K8sPSPAllowedUsers      | Lets you define rules that have a similar function to the type: key in SCC and id ranges for the runAsUser, runAsGroup, supplementalGroups, and fsGroup parameters. Can be used to define allowed ranges for User, Groups, Supplemental Groups, or FS Groups but not to set the user ID directly in the Pod as can be done in OpenShift SCCs. |\n| seLinuxContext:    | Has a type: key that can be one of the following: MustRunAs: Requires seLinuxOptions to be configured if not using pre-allocated values from the namespace. RunAsAny: Allows any seLinuxOptions to be specified.                                                | K8sPSPSELinuxV2       | Has an allowedSELinuxOptions parameter where you can set the level, role, type and user seLinuxOptions allowed                                                          |\n### Differences between OpenShift SCCs and Policy Controller constraints\nThis section describes some differences between Policy Controller constraints and OpenShift SCCs. Consider these differences before you use the preceding table to deploy constraints on your target environment.\nYou can assign OpenShift SCCs to users and groups using the `users:` or `group:` specification that is present in the SCC object. With OpenShift 4.x and later versions, you can also assign SCCs to users or groups using [role-based access control (RBAC)](https://docs.openshift.com/container-platform/latest/authentication/managing-security-context-constraints.html#role-based-access-to-ssc_configuring-internal-oauth) . SCCs also have a `priority:` field that is used to order the SCCs that are applied to a Pod.\nPolicy Controller constraints are applied to target clusters, namespaces, or pods using specific resource selectors in the constraint, instead of targeting the user or service account. For more information, see the [Policy Controller documentation](/anthos-config-management/docs/how-to/creating-policy-controller-constraints#constraint) . Using the specific resource selectors helps to ensure that the Pod behaves the same whether a low-privilege user runs it using a deployment tool or a cluster-admin launches it from the command line.\nPolicy Controller constraints also support a [dry-run mode](/anthos-config-management/docs/how-to/auditing-constraints) , which lets you test policies and audit violations before actual enforcement. Using this mode helps you to prevent impact on existing workloads, while SCCs are always enforced if applicable to the user.\nIn OpenShift SCCs, you can alter the related security context of each Pod to which the SCC is applied with a specific ID from a pre-allocated range provided by annotations in namespaces. You do this using the `RunAsUser` , `fsGroup` , `supplementalGroups` , and `seLinuxContext` fields with a `MustRunAs` or `MustRunAsRange` strategy type.\nFor example, consider a `restricted` SCC that has a `RunAsUser` field with a strategy type `MustRunAsRange` with no range defined in the SCC. In this scenario, each Pod the SCC applies to gets a `RunAsUser` ID from the range specified in the `openshift.io/sa.scc.uid-range` annotation in the namespace of the Pod.\nPolicy Controller constraints along with [mutation capabilities](/anthos-config-management/docs/how-to/mutation) provide both Pod validation and mutation. However, the constraints don't use annotations in namespaces to provide values for Pod security contexts. The next section, [Example of end-to-end migration](#example_of_end-to-end_migration) , provides an example of how your application delivery teams must explicitly configure Security Contexts on Pods to obey constraints that implement restrictions similar to those listed earlier.\n### Example of end-to-end migration\nThis section provides an example target manifest file that includes all the Policy Controller constraints and mutators that you need to map the following OpenShift default SCCs on your target GKE cluster:\n- `privileged`\n- `anyuid`\n- `nonroot`\n- `restricted`\nDepending on the namespace that a Pod runs in, the Pod gets different policy controller constraints when you map the SCC policies that are defined in a source OpenShift environment:\n- Workloads that need the highest privileged access, such as the ability to run in privileged mode or access any host resource, should run in one of the exempt namespaces that are defined in Policy Controller configuration.No constraints are applied to exempt namespaces. Workloads that have this highest privileged access are typically system components or any workload to which the privileged SCC was applied in the source OpenShift environment.\n- All Pods that are created in any non-exempt namespace get the most restrictive constraints. These constraints deny access to all host features and require the Pods to run with a UID that is part of a specific range. This configuration matches the policies that are applied by OpenShift `restricted` SCC. Exceptions to this configuration include the following:- Pods that are created in a namespace that have the`security=anyuid`label get the preceding restrictive constraints, but are allowed to run with any UID and any GID. This matches the constraints of the`anyuid`SCC on OpenShift.\n- Pods that are created in a namespace that has the`security=nonroot`label get the preceding restrictive constraints. However, the Pods are allowed to run with any non-root UID. This matches the constraints of the`nonroot`SCC on OpenShift.\nThe following is an example of a single manifest that includes a set of Policy Controller constraints and mutators that match the behavior described in the preceding end-to-end migration example. We recommend that you review and adjust the constraints or their scope in this example based on your organization's needs.\n```\napiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPHostNamespacemetadata:\u00a0 name: psp-host-namespacespec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPHostNetworkingPortsmetadata:\u00a0 name: psp-host-network-portsspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 parameters:\u00a0 \u00a0 hostNetwork: false---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPPrivilegedContainermetadata:\u00a0 name: psp-privileged-containerspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]---apiVersion: mutations.gatekeeper.sh/v1alpha1kind: Assignmetadata:\u00a0 name: restricted-capabilitiesspec:\u00a0 applyTo:\u00a0 - groups: [\"\"]\u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 versions: [\"v1\"]\u00a0 match:\u00a0 \u00a0 scope: Namespaced\u00a0 \u00a0 kinds:\u00a0 \u00a0 - apiGroups: [\"*\"]\u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaceSelector:\u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - operator: NotIn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"anyuid\"]\u00a0 location: \"spec.containers[name:*].securityContext.capabilities.drop\"\u00a0 parameters:\u00a0 \u00a0 assign:\u00a0 \u00a0 \u00a0 value: [\"KILL\",\"MKNOD\",\"SYS_CHROOT\"]---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPCapabilitiesmetadata:\u00a0 name: restricted-capabilitiesspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaceSelector:\u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - operator: NotIn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"anyuid\"]\u00a0 parameters:\u00a0 \u00a0 requiredDropCapabilities: [\"KILL\",\"MKNOD\",\"SYS_CHROOT\"]---apiVersion: mutations.gatekeeper.sh/v1alpha1kind: Assignmetadata:\u00a0 name: anyuid-capabilitiesspec:\u00a0 applyTo:\u00a0 - groups: [\"\"]\u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 versions: [\"v1\"]\u00a0 match:\u00a0 \u00a0 scope: Namespaced\u00a0 \u00a0 kinds:\u00a0 \u00a0 - apiGroups: [\"*\"]\u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaceSelector:\u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - operator: In\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"anyuid\"]\u00a0 location: \"spec.containers[name:*].securityContext.capabilities.drop\"\u00a0 parameters:\u00a0 \u00a0 assign:\u00a0 \u00a0 \u00a0 value: [\"MKNOD\"]---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPCapabilitiesmetadata:\u00a0 name: anyuid-capabilitiesspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaceSelector:\u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - operator: In\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"anyuid\"]\u00a0 parameters:\u00a0 \u00a0 requiredDropCapabilities: [\"MKNOD\"]---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPAllowedUsersmetadata:\u00a0 name: restricted-users-and-groupsspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaceSelector:\u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - operator: NotIn\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"anyuid\",\"nonroot\"]\u00a0 parameters:\u00a0 \u00a0 runAsUser:\u00a0 \u00a0 \u00a0 rule: MustRunAs # MustRunAsNonRoot # RunAsAny\u00a0 \u00a0 \u00a0 ranges:\u00a0 \u00a0 \u00a0 \u00a0 - min: 1000\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 max: 2000\u00a0 \u00a0 fsGroup:\u00a0 \u00a0 \u00a0 rule: MustRunAs # MayRunAs # RunAsAny\u00a0 \u00a0 \u00a0 ranges:\u00a0 \u00a0 \u00a0 \u00a0 - min: 1000\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 max: 2000---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPAllowedUsersmetadata:\u00a0 name: nonroot-users-and-groupsspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 \u00a0 namespaceSelector:\u00a0 \u00a0 \u00a0 matchExpressions:\u00a0 \u00a0 \u00a0 \u00a0 - operator: In\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 key: security\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 values: [\"nonroot\"]\u00a0 parameters:\u00a0 \u00a0 runAsUser:\u00a0 \u00a0 \u00a0 rule: MustRunAsNonRoot\u00a0 \u00a0 fsGroup:\u00a0 \u00a0 \u00a0 rule: MustRunAsNonRoot---apiVersion: constraints.gatekeeper.sh/v1beta1kind: K8sPSPVolumeTypesmetadata:\u00a0 name: psp-volume-typesspec:\u00a0 match:\u00a0 \u00a0 kinds:\u00a0 \u00a0 \u00a0 - apiGroups: [\"\"]\u00a0 \u00a0 \u00a0 \u00a0 kinds: [\"Pod\"]\u00a0 parameters:\u00a0 \u00a0 volumes:\u00a0 \u00a0 \u00a0 - configMap\u00a0 \u00a0 \u00a0 - downwardAPI\u00a0 \u00a0 \u00a0 - emptyDir\u00a0 \u00a0 \u00a0 - nfs\u00a0 \u00a0 \u00a0 - persistentVolumeClaim\u00a0 \u00a0 \u00a0 - projected\u00a0 \u00a0 \u00a0 - secret\n```\nThe `restricted-users-and-groups` constraint in the example manifest uses the `K8sPSPAllowedUsers` template to explicitly set an example range of 1000-2000 for `runAsUser:` and `fsGroup:` parameters. Any Pod that isn't set to use an ID in that range for `runAsUser:` and `fsGroup:` is blocked.\nGKE Enterprise and Kubernetes don't use namespace annotations to automatically mutate Pods with a specific user or group ID. Therefore, to limit the UID range as in the preceding example, your application delivery teams need to explicitly set a compliant UID on the created pod, or you need to completely remove the constraint to allow any ID.\nThe following is an example of a Pod manifest that complies with the preceding constraints in any namespace that you create it in (the manifest is compliant with the `restricted` SCC):\n```\napiVersion: v1kind: Podmetadata:\u00a0 name: restricted-pod-examplespec:\u00a0 securityContext:\u00a0 \u00a0 runAsUser: 1000\u00a0 \u00a0 fsGroup: 1100\u00a0 volumes:\u00a0 - name: sec-ctx-vol\u00a0 \u00a0 emptyDir: {}\u00a0 containers:\u00a0 - name: sec-ctx-demo\u00a0 \u00a0 image: busybox\u00a0 \u00a0 command: [ \"sh\", \"-c\", \"sleep 1h\" ]\u00a0 \u00a0 volumeMounts:\u00a0 \u00a0 - name: sec-ctx-vol\u00a0 \u00a0 \u00a0 mountPath: /data/demo\n```\n## What's next\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Docs"}