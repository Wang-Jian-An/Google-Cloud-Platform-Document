{"title": "Docs - Architecture", "url": "https://cloud.google.com/architecture/enterprise-application-blueprint/architecture", "abstract": "# Docs - Architecture\nLast reviewed 2023-12-20 UTC\n**    Preview     ** This product or feature is subject to the \"Pre-GA Offerings Terms\" in the General Service Terms section   of the [Service Specific Terms](/terms/service-terms#1) .     Pre-GA products and features are available \"as is\" and might have limited support.    For more information, see the [launch stage descriptions](/products#product-launch-stages) .\nThe following diagram shows the high-level architecture that is deployed by the blueprint for a single environment. You deploy this architecture across three separate environments: production, non-production, and development.\nThis diagram includes the following:\n- Cloud Load Balancing distributes application traffic across regions to [Kubernetes service](/kubernetes-engine/docs/concepts/service) objects. Behind each service is a logical grouping of related pods.\n- [Anthos Service Mesh](/service-mesh/docs/overview#what_is_a_service_mesh) lets Kubernetes services communicate with each other.\n- Kubernetes services are grouped into tenants, which are represented as Kubernetes [namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/) . Tenants are an abstraction that represent multiple users and workloads that operate in a cluster, with separate RBAC for access control. Each tenant also has its own project for tenant-specific cloud resources such as databases, storage buckets, and Pub/Sub subscriptions.\n- Namespaces with their own identities for accessing peer services and cloud resources. The identity is consistent across the same namespace in different clusters because of [fleet Workload Identity](/anthos/fleet-management/docs/use-workload-identity) . Each environment has a separate workload identity pool to mitigate privilege escalation between environments.\n- Each service has a dedicated pipeline that builds and deploys that service. The same pipeline is used to deploy the service into the development environment, then deploy the service into the non-production environment, and finally deploy the service into the production environment.", "content": "## Key architectural decisions for developer platform\nThe following table describes the architecture decisions that the blueprint implements.\n| Decision area       | Decision                                    | Reason                                           |\n|:----------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Deployment archetype     | Deploy across multiple regions.                              | Permit availability of applications during region outages.                              |\n| Organizational architecture    | Deploy on top of the enterprise foundation blueprint.                         | Use the organizational structure and security controls that are provided by the foundation.                      |\n| Organizational architecture    | Use the three environment folders that are set up in the foundation: development, nonproduction, and production.          | Provide isolation for environments that have different access controls.                           |\n| Developer platform cluster architecture | Package and deploy applications as containers.                           | Support separation of responsibilities, efficient operations, and application portability.                      |\n| Developer platform cluster architecture | Run applications on GKE clusters.                              | Use a managed container service that is built by the company that pioneered containers.                       |\n| Developer platform cluster architecture | Replicate and run application containers in an active-active configuration.                   | Achieve higher availability and rapid progressive rollouts, improving development velocity.                      |\n| Developer platform cluster architecture | Provision the production environment with two GKE clusters in two different regions.                 | Achieve higher availability than a single cloud region.                               |\n| Developer platform cluster architecture | Provision the non-production environment with two GKE clusters in two different regions.                | Stage changes to cross-regional settings, such as load balancers, before deployment to production.                    |\n| Developer platform cluster architecture | Provision the development environment with a single GKE cluster instance.                    | Helps reduce cost.                                        |\n| Developer platform cluster architecture | Configure highly-available control planes for each GKE cluster.                      | Ensure that the cluster control plane is available during upgrade and resizing.                         |\n| Developer platform cluster architecture | Use the concept of sameness across namespaces, services, and identity in each GKE cluster.                | Ensure that Kubernetes objects with the same name in different clusters are treated as the same thing. This normalization is done to make administering fleet resources easier. |\n| Developer platform cluster architecture | Enable private IP address spaces for GKE clusters through Private Service Connect access to the control plane and private node pools.     | Help protect the Kubernetes cluster API from scanning attacks.                             |\n| Developer platform cluster architecture | Enable administrative access to the GKE clusters through the Connect gateway.                   | Use one command to fetch credentials for access to multiple clusters. Use groups and third-party identity providers to manage cluster access.         |\n| Developer platform cluster architecture | Use Cloud NAT to provide GKE pods with access to resources with public IP addresses.                 | Improve the overall security posture of the cluster, because pods are not directly exposed to the internet, but are still able to access internet-facing resources.    |\n| Developer platform cluster architecture | Configure nodes to use Container-Optimized OS and Shielded GKE Nodes.                     | Limit the attack surface of the nodes.                                   |\n| Developer platform cluster architecture | Associate each environment with a GKE fleet and a separate fleet host project.                   | Permit management of sets of GKE clusters as a unit.                               |\n| Developer platform cluster architecture | Use the foundation infrastructure pipeline to deploy the application factory, fleet-scope pipeline, and multi-tenant infrastructure pipeline.   | Provide a controllable, auditable, and repeatable mechanism to deploy application infrastructure.                    |\n| Developer platform cluster architecture | Configure GKE clusters using GKE Enterprise configuration and policy management features.                | Provide a service that allows configuration-as-code for GKE clusters.                           |\n| Developer platform cluster architecture | Use an application factory to deploy the application CI/CD pipelines used in the blueprint.               | Provide a repeatable pattern to deploy application pipelines more easily.                          |\n| Developer platform cluster architecture | Use an application CI/CD pipeline to build and deploy the blueprint application components.               | Provide a controllable, auditable, and repeatable mechanism to deploy applications.                        |\n| Developer platform cluster architecture | Configure the application CI/CD pipeline to use Cloud Build, Cloud Deploy, and Artifact Registry.              | Use managed build and deployment services to optimize for security, scale, and simplicity.                      |\n| Developer platform cluster architecture | Use immutable containers across environments, and sign the containers with Binary Authorization.              | Provide clear code provenance and ensure that code has been tested across environments.                       |\n| Developer platform cluster architecture | Use Google Cloud Observability, which includes Cloud Logging and Cloud Monitoring.                  | Simplify operations by using an integrated managed service of Google Cloud.                          |\n| Developer platform cluster architecture | Enable Container Threat Detection (a service in Security Command Center) to monitor the integrity of containers.          | Use a managed service that enhances security by continually monitoring containers.                        |\n| Developer platform cluster architecture | Control access to the GKE clusters by Kubernetes role-based access control (RBAC), which is based on Google Groups for GKE.       | Enhance security by linking access control to Google Cloud identities.                           |\n| Service architecture     | Use a unique Kubernetes service account for each Kubernetes service. This account acts as an IAM service account through the use of Workload Identity. | Enhance security by minimizing the permissions each service needs to be provided.                        |\n| Service architecture     | Expose services through the GKE Gateway API.                           | Simplify configuration management by providing a declarative-based and resource-based approach to managing ingress rules and load-balancing configurations.      |\n| Service architecture     | Run services as distributed services through the use of Anthos Service Mesh with Certificate Authority Service.          | Provide enhanced security through enforcing authentication between services and also provides automatic fault tolerance by redirecting traffic away from unhealthy services. |\n| Service architecture     | Use cross-region replication for AlloyDB for PostgreSQL.                        | Provide for high-availability in the database layer.                               |\n| Network architecture     | Shared VPC instances are configured in each environment and GKE clusters are created in service projects.            | Shared VPC provides centralized network configuration management while maintaining separation of environments.                 |\n| Network architecture     | Use Cloud Load Balancing in a multi-cluster, multi-region configuration.                    | Provide a single anycast IP address to access regionalized GKE clusters for high availability and low-latency services.               |\n| Network architecture     | Use HTTPS connections for client access to services. Redirect any client HTTP requests to HTTPS.              | Help protect sensitive data in transit and help prevent person-in-the-middle-attacks.                       |\n| Network architecture     | Use Certificate Manager to manage public certificates.                         | Manage certificates in a unified way.                                   |\n| Network architecture     | Protect the web interface with Google Cloud Armor.                          | Enhance security by protecting against common web application vulnerabilities and volumetric attacks.                   |\nYour decisions might vary from the blueprint. For information about alternatives, see [Alternatives to default recommendations](/architecture/enterprise-application-blueprint/deploy-blueprint#alternatives-default) .\n## What's next\n- Read about [developer platform controls](/architecture/enterprise-application-blueprint/developer-platform-controls) (next document in this series).", "guide": "Docs"}