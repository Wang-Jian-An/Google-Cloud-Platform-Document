{"title": "Docs - Image processing using microservices and asynchronous messaging", "url": "https://cloud.google.com/architecture/image-processing-using-microservices-and-asynchronous-messaging", "abstract": "# Docs - Image processing using microservices and asynchronous messaging\nLast reviewed 2023-07-17 UTC\nWhen you design a web application that's based on a [microservices architecture](https://wikipedia.org/wiki/Microservices) , you decide how to split your application's features into microservices, and how those microservices are called as part of the application. For long-running services, you might want to use asynchronous service calls. This reference architecture discusses how to deploy a containerized application that invokes long-running processes asynchronously.\nThis reference architecture document is intended for developers and architects who want to implement microservices in an asynchronous manner using modern technologies, including [Google Kubernetes Engine (GKE)](/kubernetes-engine) and [Pub/Sub](/pubsub) . The document assumes that you're familiar with microservices in general, and with Pub/Sub and GKE on Google Cloud.\n**Note:** The [State of DevOps](https://dora.dev/) reports identified capabilities that drive software delivery performance. This reference architecture helps you with the [loosely-coupled architecture](https://dora.dev/devops-capabilities/technical/loosely-coupled-architecture/) capability.\n", "content": "## Architecture\nThe following diagram illustrates an example scenario where an application generates thumbnail images. Generating thumbnail images can be a resource-intensive task and can therefore take some time.\n**Figure 1.** Original architecture for image processing that's based on using VMs.\nIn the preceding diagram, the application receives image files from clients and then generates thumbnails. In this architecture, the application is implemented by using virtual machine (VM) instances on [Compute Engine](/compute) and by using backend file storage on Cloud Storage. The application stores metadata using Cloud Storage. [Cloud Load Balancing](/load-balancing) distributes requests to multiple VMs.\nTo reduce the operational overhead to maintain VMs, you migrate this system to a new architecture that doesn't use VMs.\nThe following diagram shows how this flow can be implemented by using managed services that use notifications and microservices to implement asynchronous calls between components of the system.\n**Figure 2.** New architecture for image processing that's based on using containers and asynchronous messaging.\nIn the new architecture, the client submits an image to the application and the application uploads it to Cloud Storage. Then Pub/Sub notifications put a message in the Pub/Sub message queue. The message calls a microservice that runs on GKE. The microservice retrieves the image from Cloud Storage, generates a thumbnail, and uploads the thumbnail to Cloud Storage.\n## Design considerations\nThe following guidelines can help you to develop an architecture that meets your organization's requirements for operational efficiency and performance.\n### Operational efficiency\nThe new architecture has the following advantages:\n- **Independent scalability** : In the original architecture, the application that's running on Compute Engine addresses two core tasks. One task is to receive files, and the other task is to generate a thumbnail from the original image. Receiving uploaded files consumes network bandwidth, and thumbnail generation is a CPU-intensive task. The Compute Engine instances might run out of CPU resources to generate images but still have enough network resources to receive files. In the new architecture, these tasks are shared by Cloud Storage and GKE, making the tasks independently scalable.\n- **Easy to add new functionality** : In the original architecture, if you want to add functionality, you have to deploy it on the same Compute Engine instances. In the new architecture, you can develop an application and add it independently\u2014for example, you can add a mail sender application to notify you when a new thumbnail is generated. Pub/Sub can connect to the thumbnail-generation application and to the mail-sender application in an asynchronous manner without modifying the original code that runs on GKE.\n- **Reduced coupling** : In the original architecture, a common problem is [temporal coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Procedural_programming) . If a mail relay server is unavailable, when the application tries to send a notification, the notification fails. Those processes are tightly coupled, and a client might not get a successful response from the application. In the new architecture, the client gets a successful response because generating a thumbnail and sending a notification are loosely coupled.\nThis new architecture has the following disadvantages:\n- **Extra effort to modernize the application** : Containerizing an application takes time and effort. The new architecture uses more services and requires a different approach to observability, which includes changes to monitoring the application, the deployment process, and resource management.\n- **Requirement to handle duplication on the application side** : Pub/Sub guarantees at-least-once message delivery, which means that duplicate messages might be sent. Your application must handle this possibility.\n### Performance\nThe new architecture can give you efficient resource usage: In the original architecture, scaling out Compute Engine instances consumes more resources in order to run operating systems. With GKE, you can efficiently use server resources that run multiple containers on just a few servers (bin packing). You can scale containers out and in quickly, so the new architecture can handle short bursts of high load and scale in quickly when the tasks are finished.\n## Deployment\nTo deploy an example application that implements this architecture, see [Deploy microservices that use Pub/Sub and GKE](/architecture/image-processing-using-microservices-and-asynchronous-messaging/deployment) .\n## What's next\n- Read about [DevOps](https://dora.dev/) , and learn more about the [Architecture](https://dora.dev/devops-capabilities/technical/loosely-coupled-architecture/) capability that's related to this reference architecture.\n- Take the [DevOps quick check](https://dora.dev/quickcheck/) to understand where you stand in comparison with the rest of the industry.\n- For more reference architectures, diagrams, and best practices, explore the [Cloud Architecture Center](/architecture) .", "guide": "Docs"}