{"title": "Docs - Best practices for running an IoT backend on Google Cloud", "url": "https://cloud.google.com/architecture/connected-devices/bps-running-iot-backend-securely", "abstract": "# Docs - Best practices for running an IoT backend on Google Cloud\nLast reviewed 2023-02-08 UTC\nThis document provides security best practices for managing and running an Internet of Things (IoT) backend on Google Cloud. In an IoT solution, an IoT backend connects edge devices to other resources. This document focuses on the following IoT backends: Message Queuing Telemetry Transport (MQTT) broker and the IoT platform.\nThis document is part of a series of documents that provide information about IoT architectures on Google Cloud and about migrating from IoT Core. The other documents in this series include the following:\n- [Connected device architectures on Google Cloud overview](/architecture/connected-devices) \n- [Standalone MQTT broker architecture on Google Cloud](/architecture/connected-devices/mqtt-broker-architecture) \n- [IoT platform product architecture on Google Cloud](/architecture/connected-devices/iot-platform-product-architecture) \n- Best practices for running an IoT backend on Google Cloud (this document)\n- [Device on Pub/Sub architecture to Google Cloud](/architecture/connected-devices/device-pubsub-architecture) \n- [Best practices for automatically provisioning and configuring edge and bare metal systems and servers](/architecture/connected-devices/best-practices-provisioning-configuring-bare-metal) \n- [Migrate environments from IoT Core](/architecture/connected-devices/iot-core-migration) \nThis document provides best practices for provisioning and managing device credentials, authenticating and accessing control edge devices, and letting IoT edge devices access Google Cloud resources.\n", "content": "## IoT architecture\nAn IoT architecture includes services that let you provision and manage device credentials, authenticate and access control edge devices, and let edge devices access Google Cloud resources. This document discusses two IoT backend architectures: one using MQTT broker and the other using an IoT platform. The main security differences between these two backends are device identity and device management. IoT platforms provide these capabilities as part of their system, whereas MQTT brokers require you to provide these capabilities.\nThe following diagram describes the IoT architecture.\nThe architecture shows the services that are required for the following three processes:\n- Certificate provisioning, which is the process that you must complete to prepare an edge device for configuration.\n- Authentication and authorization, which include the authentication scheme that the edge device and the MQTT broker or IoT platform use to authenticate with each other.\n- Connections between edge devices and Google Cloud services, which are tasks that the edge device completes to connect to cloud resources and upload or download data.\nThis document focuses primarily on security best practices for provisioning and authentication.\nThe architecture uses a combination of the following services and features:\n- An edge device (such as a medical device) that you deploy at the [edges of your environment](https://www.lfedge.org/2020/08/18/breaking-down-the-edge-continuum/) and that is geographically close to the data that you want to process. The edge devices connect bi-directionally with your IoT backend, which means that they can send messages to and receive messages from the IoT backend.\n- An IoT backend that can be an MQTT broker or an IoT platform.- An MQTT broker provides a secure interface for edge devices to connect using the [MQTT protocol](https://mqtt.org/mqtt-specification/) . MQTT brokers lack capabilities for device identity and device management and rely on external systems to provide them.\n- An IoT platform is a cloud application that edge devices connect and communicate with. IoT platforms provide a secure interface for edge devices to connect using the MQTT protocol. Each IoT platform has its own security implementation that determines how it authenticates and authorizes edge devices and how it manages device identities.\n- A central certificate store that hosts the certificates for all edge devices.\n- Cloud resources that edge devices must access.## Provisioning an edge device\nBefore an edge device can connect with your backend workloads, you must provision a certificate for the edge device. There are two main scenarios that decide how you provision the certificate:\n- If your solution is based on commercial, generic devices, you have full control over the provisioning process after purchasing the device.\n- If you use custom-built devices, the initial provisioning process happens during the manufacturing of the devices and you must integrate the provisioning process with your vendors and manufacturers.\nIn either scenario, you must create device certificates with a chain of trust that links to a root certificate authority (CA). These certificates authenticate the device identity and help ensure that updates and modifications done on the device are by trusted actors. Use a CA such as [Certificate Authority Service](/certificate-authority-service) to complete the following tasks:\n- [Generate and store the root CA certificate](/certificate-authority-service/docs/creating-certificate-authorities#create-root-ca) in a secure manner.\n- [Generate and store subordinate CA certificates](/certificate-authority-service/docs/creating-certificate-authorities#subordinate-internal) for signing of your device certificates, if necessary.\n- [Request device certificates.](/certificate-authority-service/docs/requesting-certificates) \n- Configure and distribute [permissions to subordinate CAs](/certificate-authority-service/docs/reference/permissions-and-roles) to your vendors and manufacturers.\n- [Revoke device certificates](/certificate-authority-service/docs/revoking-certificates) when they aren't required any longer or you suspect the device has been compromised.\nTo provision a device certificate, you must complete the following tasks:\n- Generate the public-private key pair using a hardware-based security solution that is supported by your device, such as a [secure element (SE)](https://encyclopedia.kaspersky.com/glossary/secure-element/) or a [hardware secure module (HSM)](https://wikipedia.org/wiki/Hardware_security_module) . By design, the SE or HSM stores the private keys locally and the private keys are never exposed externally. If you are not using a hardware-based security solution to generate a public-private key pair, use the CA to generate keys instead. For more information, see [Using an auto-generated key](/certificate-authority-service/docs/requesting-certificates#auto-generated-key) .\n- Sign and generate a device certificate. After you generate the public-private key pair, download the public key, create a [certificate signing request (CSR)](https://wikipedia.org/wiki/Certificate_signing_request) , and send the CSR to the CA for signing. The CA generates a device certificate that is linked to the root CA. For more information, see [Using a CSR](/certificate-authority-service/docs/requesting-certificates#use-csr) . When using auto-generated keys, you can request a device certificate from the CA directly.\n- Install the signed device certificate on the edge device and send the certificate to a central certificate repository such as [Secret Manager](/secret-manager) .\nFor more information, see [How to deploy a secure and reliable public key infrastructure with Google Cloud CA Service (PDF)](https://services.google.com/fh/files/misc/deploying_public_key_infrastructure_with_cas.pdf) .\nFor information about other provisioning best practices, see [Best practices for automatically provisioning and configuring edge and bare metal systems and servers](/architecture/best-practices-provisioning-configuring-bare-metal#provisioning_and_configuration_processes_best_practicesactices) .\nThree types of certificates are used to help secure an IoT solution:\n- The root CA certificate provides the root for the chain of trust of all the other certificates in your system. The backend workloads use the root certificate to validate the client certificates and the edge devices use the root certificate to validate the server certificate. You must distribute the root certificate to both the IoT backend and to the edge devices.\n- The server certificates are used to secure the endpoints that are exposed by the IoT backend. You have server certificates for the different encryption algorithms that your endpoints need to support. Server certificates are linked to the root CA. A secret manager manages and stores both the private and public portions of the server certificates. You must configure your IoT backend with the server certificates and their corresponding private keys.\n- The client certificates are used to identify edge devices. Each edge device has at least one client certificate, which means that the number of certificates that you have increases with the number of edge devices in your environment. Client certificates are linked to the root CA. You must distribute client certificates to your edge devices and to the IoT backend.The following diagram shows how a device certificate is provisioned when using an HSM or SE.\nIn this diagram, the following steps occur:\n- The edge device generates the public key pair in the hardware.\n- You download the public key and create the certificate signing request (CSR) for it.\n- You send the CSR to the CA to request a certificate.\n- The CA completes the following actions:- Signs the certificate.\n- Returns the device certificate to the provisioner.\n- The provisioner completes the following actions:- Sends the certificate to the edge device.\n- Stores the certificate in the central certificate store.\n- The edge device stores the certificate in a secure location.The following diagram shows how a device certificate is provisioned when using a CA.\nIn this diagram, the following steps occur:\n- You generate a CSR and send it to the CA to request a certificate.\n- The CA completes the following actions:- Generates and public key pair and signs the public key.\n- Returns the device certificate and the private key to the provisioner.\n- You complete the following actions:- Send the certificate and private key to the edge device.\n- Store the certificate and private key in the central certificate store.\n- The edge device stores the certificate in a secure location.## Best practices for device identity\nThis section describes the best practices for device identities.\n### Use an identity provider with MQTT brokers\nMQTT brokers authenticate edge devices by using device credentials provided by [plugins](https://www.hivemq.com/docs/hivemq/3.4/plugins/authentication-and-permissions.html#client-authentication) , [databases](https://docs.vernemq.com/configuring-vernemq/db-auth) , and [files](https://mosquitto.org/documentation/authentication-methods/) . To manage your device identities in a systematic and scalable manner, use an [identity provider (IdP)](https://wikipedia.org/wiki/Identity_provider) . The IdP manages the identities and credentials for all devices and acts as the primary source of truth for device identities.\nTo keep the device identity updated in the MQTT broker, implement a system-specific integration layer. For more information about managing device credentials, see [Provisioning an edge device](#provisioning) .\n### Use the digital identities of the IoT platform as the source of truth\nThe IoT platform has security features that manage the device identities and device credentials, and authenticate and authorize devices trying to access the platform. These security features help ensure that only authorized devices are allowed to access the IoT platform and help ensure data integrity.\nVerify that the device identities managed by the IoT platform represent the primary source of truth of all the devices the IoT platform manages. Other components in an IoT solution that need device identity information should rely on the security system of the IoT platform. The IoT platform grants access rights to devices and propagates any security changes throughout the IoT solution.\n## Best practices for network connectivity\nSecuring network connectivity is important for the following reasons:\n- Secure networks help ensure that a device connects to the right backend. For example, a secure network can prevent [DNS spoofing](https://wikipedia.org/wiki/DNS_spoofing) , which is an attack that tries to divert devices to connect to a rogue backend that is controlled by attackers.\n- Secure networks help ensure third parties can't read your data traffic. For example, a secure network can prevent an [attacker-in-the-middle attack](https://wikipedia.org/wiki/Man-in-the-middle_attack) , where attackers read the traffic between your device and the backend.\nUse [Transport Layer Security (TLS)](https://wikipedia.org/wiki/Transport_Layer_Security) to protect network communication between your edge devices and backend workloads.\nExtend TLS with [mTLS](https://wikipedia.org/wiki/Mutual_authentication#mTLS) to implement a mutual authentication scheme that enables both connecting parties to establish the identity of each other.\nFor instructions on using TLS, see [Standalone MQTT broker architecture on Google Cloud](/architecture/connected-devices/mqtt-broker-architecture) and [IoT platform product architecture on Google Cloud](/architecture/connected-devices/iot-platform-product-architecture) .\n## Best practices for certificate management for MQTT brokers\nThis section describes best practices for managing certificates when using MQTT brokers.\n### Store certificates centrally\nStore and manage server certificates and device certificates in a central location. Specifically, ensure that you have the following controls in place:\n- An inventory of all your devices and their certificates and the server endpoints and their certificates.\n- Additional information about the certificates such as their validity.\n- The ability to add and remove certificates for devices so that devices can connect using new certificates.\n- Access rights to your central certificate store, to limit what the different roles in your backend can do with the certificates.\nUse a secret storage and management solution such as Secret Manager or HashiCorp Vault. Secret Manager lets you version, update, and invalidate device credentials, and to [manage access policies](/secret-manager/docs/access-control) to your credentials.\nFor an IoT platform, implement access to the credentials using [Secret Manager API access](/secret-manager/docs/accessing-the-api) .\n### Protect certificates on edge devices\nTo store certificates and keys on the edge devices, use a local [trusted execution environment](https://wikipedia.org/wiki/Trusted_execution_environment) or certificate store to protect the credential and block unauthorized accesses. If you need to store secret material on your devices, encrypt that material using techniques such as [flash encryption](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/security/flash-encryption.html) , and store it on tamper-proof elements to help prevent unauthorized data extraction.\n### Synchronize the central certificate store with the MQTT broker certificate store\nMQTT brokers must access client certificates for certificate-based authentication, so you must synchronize the certificate stores of MQTT brokers with the central certificate store. Verify that changes on the central certificate store, such as add, update, and delete certificates, are synchronized with the MQTT broker certificate store. MQTT brokers use certificate stores such as MySQL, PostgresDB, and Java Key Store. Depending on which certificate store your MQTT broker uses, ensure that the following processes exist:\n- A process that monitors for changes in the central certificate store and notifies the synchronization process.\n- A process that takes changes in the central certificate store and synchronizes the changes in the central certificate store with the certificate store used by the MQTT broker.\nWhen you use Secret Manager as your certificate store, you can use [event notifications](/secret-manager/docs/event-notifications) as the monitoring process. You can implement the synchronization process as a listener of the event notifications.\n### Distribute certificates to edge devices securely\nWhen using MQTT brokers, distribute the root certificate and client certificates to your edge devices. When you distribute certificates, you must secure your communication channels so that the traffic doesn't get intercepted.\nThe main communication channels for certificate distribution are the following:\n- A direct path from the IoT backend to the edge devices over existing communication channels.\n- An indirect path in which edge devices request and download the certificates.\nDuring certificate distribution, you require the following components:\n- Awhere certificates are centrally managed.\n- Awhich sends the certificates and tracks the distribution process for each edge device.\n- Anon the edge device that receives or downloads the certificates and stores them on the device.\nDistribute certificates during the provisioning processes for edge devices, and when you need to rotate certificates.\nDuring the provisioning process, ensure that the provisioner has direct access to edge devices over encrypted channels such as [SSH](https://wikipedia.org/wiki/Secure_Shell) and uses tools such as [SCP](https://wikipedia.org/wiki/Secure_copy_protocol) . Because the devices are not in operation, you can push certificates directly to the edge devices.\nWhen rotating certificates, use the MQTT broker as the communication channel between the distribution coordinator and the edge devices. Use other channels to download certificates onto the device. To minimize disruption of the edge devices in operation, use an indirect certificate distribution path. The process would consist of the following logical steps:\n- The distribution coordinator acquires access credentials from the certificate store.\n- The distribution coordinator pushes the certificate access credentials to the edge devices together with additional information, such as the download URL.\n- The on-device update handler receives the access credentials and temporarily stores the information and acknowledges receipt back.\n- The update handler coordinates the certificate download when the device is not active. The update handler uses the access credentials to download certificates from the credential store.\n- After the certificates are downloaded, the update handler continues with the certificate rotation process which is described in the [certificate rotation](#certificate-rotation) section.\nWhen you use Secret Manager as the central certificate store, you can generate [short-lived access tokens](/secret-manager/docs/accessing-the-api#authenticating) to grant and restrict access to certificates. For more information, see [Distribute access tokens to devices securely](#access-tokens) .\nTo help prevent the certificates from being exposed during transit, encrypt the connection between your edge devices and the MQTT broker. For more information, see [Best practices for network connectivity](#network-connectivity) .\n### Rotate certificates automatically\nTo limit the damage an exposed certificate can cause, generate certificates with a finite valid period and rotate the certificates before they expire. For large-scale IoT deployments, implement an automatic certificate rotation procedure to consistently update your devices with new certificates before the old ones expire. Deployed devices without valid certificates means that the devices can stop functioning, which can be costly to fix and negatively affect the overall functionality of your IoT solution.\nYour edge devices must connect bi-directionally with your MQTT broker to ensure that they can send messages to the MQTT broker and that they can receive messages from the MQTT broker.\nDuring certificate rotation, you require the following components:\n- A monitoring process that recurrently scans through your certificate inventory and looks for certificates that are about to expire. The monitoring process triggers certificate rotation for expiring certificates.\n- A rotation process that initializes and oversees certificate rotation.\n- A device certificate rotation handler on the edge device that communicates with the MQTT broker and executes certificate rotation steps on the device.\nTo rotate certificates, the IoT solution completes the following steps:\n- The rotation process sends an initialization message to the edge device to start certificate rotation.\n- The device certificate rotation handler acknowledges the initialization message by sending a response back to the rotation job.\n- The rotation process requests a new certificate from the CA. This request is similar to the [certificate provisioning](#protect-certificates) request, except that the keys and CSR are sent as MQTT broker messages.\n- After receiving the new certificate from the CA, the rotation job distributes the certificate to the central certificate store and to the edge device. It also synchronizes the certificate to the certificate store of the MQTT broker.\n- The device certificate rotation handler stores the new certificate and initializes a new connection with the MQTT broker using the new certificate.\n- After the new connection is established, the device certificate rotation handler sends a completed message to the MQTT broker.\n- After receiving the completed message, the rotation process invalidates the old certificate in the central certificate store.\nTo help protect the certificates that are being sent during the rotation process, use dedicated MQTT topics for certificate rotation. Limit access to these topics to only the rotation job and the edge device.\nTo help protect the certificate rotation process from runtime failures, enable persistence for the changes and progress.\nFor more information about rotating secrets using Secret Manager, see [Rotation of secrets](/secret-manager/docs/rotation-recommendations) .\n## Best practices for certificate management for IoT platforms\nIf you're using an IoT platform, use the certificate update and distribution mechanisms provided by the platform. For backup purposes, you can regularly export the credentials from your IoT platform to a secondary secret storage, such as Secret Manager.\n## Best practices for authentication with an MQTT broker\nDuring the mutual authentication process, backend workloads verify the identity of edge devices, and edge devices verify the identity of backend workloads. After the backend workloads confirm the identity of the edge device, the backend workloads authorize the device access to resources.\nThe following sections provide best practices for authentication methods when using MQTT brokers.\n**Note:** Most commercial IoT platform applications support their own set of authentication schemes.\n### Choose the authentication method for MQTT brokers\nDifferent IoT backends support different authentication methods. The commonly used methods are the following:\n- **Username and password authentication** , where the edge device presents its username and password to verify its identity.\n- **Token-based authentication** , where encrypted security tokens are used to verify the edge device's identity.\n- **Customized authentication schemes** , where you implement a custom mechanism to verify the identity of the edge device.\nAs part of the [MQTT standard](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718116) , MQTT brokers support username and password authentication as the default for [MQTT CONNECT](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901033) packets.\nThe `MQTT CONNECT` packet also contains a [Client Identifier](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901058) field that you can use to uniquely identify the client to the MQTT broker. Edge devices send the `MQTT CONNECT` packet to the MQTT broker when they establish a connection.\nBesides the username, password, and client identifier fields in the `MQTT CONNECT` packet, MQTT 5.0 supports [enhanced authentication](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901256) that enables you to build [challenge-response](https://wikipedia.org/wiki/Challenge%E2%80%93response_authentication) authentication flows. MQTT 5.0 allows for multiple [AUTH](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901217) packet exchanges between the edge device and the MQTT broker.\n### Use password stores with username and password authentication\nFor username and password authentication, configure the MQTT broker to use a password store. The password store provides a centralized location for managing passwords for all the edge devices that connect to the MQTT broker. By default, the username, password, and client identifier fields are optional in the MQTT specification. Therefore, design your authentication mechanism to verify that the username, password, and client identifier fields are present in the `MQTT CONNECT` packet.\nEnsure that the passwords are encrypted at rest and in transit, as follows:\n- At rest, store a cryptographically strong hash of the password that cannot be reversed. For more information about hashing passwords, see [Account authentication and password management best practices](/blog/products/identity-security/account-authentication-and-password-management-best-practices) .\n- In transit, encrypt the connection between your edge devices and the MQTT broker. For more information, see [Best practices for network connectivity](#network-connectivity) .\n### Consider token-based authentication\nWith token-based authentication, edge devices send a token to the MQTT broker to authenticate. Devices can generate the token themselves or get the token from other authentication services. Compared to passwords, tokens are short-lived: tokens are only valid for a period with an explicit expiration date. Always check for expiration when validating tokens.\n[JSON Web Tokens (JWT)](https://wikipedia.org/wiki/JSON_Web_Token) are a way to implement token-based authentication. Edge devices can generate the JWT and authenticate with the MQTT broker. The JWT is embedded into the MQTT CONNECT packet as the password field.\nThe advantages of JWT are the following:\n- JWT gives you choices on the encryption algorithm used for signing of the token. JWT works well with constrained edge devices, where you can use a less resource-intensive encryption algorithm such as ECC for signing of the token.\n- Using public key cryptography, the private key is used only on the edge device and never shared with other parties. A private key helps make this method more secure than username and password authentication, where the credentials are sent over the connection and requires encryption of the data.\n### Consider custom authentication schemes\nSome MQTT brokers support different authentication mechanisms and protocols. For example, if your MQTT broker supports customized authentication schemes, you can configure it to support the following:\n- **Industry-standard authentication protocols** such as [OpenID Connect](https://openid.net/connect/) , [Security Assertion Markup Language (SAML)](https://wikipedia.org/wiki/Security_Assertion_Markup_Language) , [LDAP](https://wikipedia.org/wiki/Lightweight_Directory_Access_Protocol) , [Kerberos](https://wikipedia.org/wiki/Kerberos_(protocol)) , and [Simple Authentication and Security Layer (SASL)](https://wikipedia.org/wiki/Simple_Authentication_and_Security_Layer) . These protocols delegate device authentication to your existing identity providers. Some MQTT brokers support enhanced authentication and extensible authentication mechanisms that you can use to extend the MQTT broker to support new protocols and identity providers.\n- **Certificate-based mutual authentication** . Some MQTT brokers support a mutual authentication scheme, such as mTLS-based authentication.## Best practices for device access control and authorization\nBecause of the publisher and subscriber communication pattern of the MQTT protocol, device access control is defined using MQTT topics. MQTT topics control how a device can communicate with your IoT backend. Each IoT backend has different implementations for access control and authorization, so refer to your IoT backend documentation for options on how to set up MQTT topics.\n### Use single-purpose service accounts to access Google Cloud resources\n[Access to Google Cloud resources](/iam/docs/manage-access-other-resources) are managed by IAM allow policies that bind the resource access allowance with a set of principals. Typical principals are user accounts, service accounts, and groups. [Service accounts](/iam/docs/service-accounts#what_are_service_accounts) are typically used by an application or compute workload to make authorized API calls for cloud resources. Service accounts let IoT edge devices access cloud resources.\nBecause the device identity is managed by the IoT backend, you must map an identity between the IoT backend and IAM so that the edge device can access Google Cloud resources.\nIf you're managing a large set of devices, the [limit](/iam/quotas#quotas) on the number of service accounts for each Google Cloud project makes it infeasible to have direct one-to-one mapping between device and service account.\nInstead, create service accounts that are linked to the cloud resources that your IoT solution needs to access, as described in [creating single-purpose service accounts](/iam/docs/best-practices-service-accounts#single-purpose) . For example, create a unique service account for each of the following use cases:\n- Downloading software update packages\n- Uploading large media files\n- Ingesting data from a latency stream\nTo implement [least privilege](/iam/docs/using-iam-securely#least_privilege) , ensure that each service account only has sufficient access rights to support its use case. For example, for a service account that is used to download software packages, only grant read access to the Cloud Storage bucket.\n### Distribute access tokens to devices securely\nUsually, your edge devices communicate with your IoT platform using MQTT. However, for specific use cases, your devices might require direct access to Google Cloud resources. For example, consider the following:\n- To download content, an edge device requires read-only access to a Cloud Storage bucket during the download process only.\n- To upload data to a Cloud Storage bucket, an edge device requires write access to the bucket.\nFor these use cases, use [workload identity federation](/iam/docs/workload-identity-federation) , where access to Google Cloud resources is granted through [access tokens](/docs/authentication/token-types#access) . Workload identity federation eliminates the need of provisioning any cloud-specific credentials on the edge devices and access distribution is done dynamically based on demand.\nTo distribute access tokens for cloud resources to your devices, configure workload identity federation between your device identity provider and Google Cloud. To support workload identity federation, ensure that your IoT backend meets the [workload identity federation requirements](/iam/docs/use-workload-identity-federation-to-let-customers-access-their-cloud-resources#requirements) and follows the [security best practices](/iam/docs/use-workload-identity-federation-to-let-customers-access-their-cloud-resources#best_practices) that match your use cases.\nTo access Google Cloud resources using workload identity federation, your edge devices must implement the [OAuth 2.0 Token Exchange](https://tools.ietf.org/html/rfc8693) workflow, which involves the following steps:\n- The device calls the [Security Token Service](/iam/docs/reference/sts/rest) and provides its own device credentials.\n- The Security Token Service verifies the identity of the edge device by validating the credentials that the edge device provided with the device identity provider.\n- If the identity verification is successful, the Security Token Service returns a federated token back to the edge device.\n- The edge device uses the federated token to impersonate the single-purpose service account and obtains a [short-lived OAuth 2.0 access token](/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth) .\n- The device uses the short-lived OAuth 2.0 access token to authenticate with Google Cloud APIs and get access to the required cloud resources.\nTo restrict the access of the short-lived access token to specific buckets and objects in Cloud Storage, use [Credential Access Boundaries](/iam/docs/downscoping-short-lived-credentials#how-it-works) . Credential Access Boundaries lets you limit the access of the short-lived credential and minimize the number of resources that are exposed in your Cloud Storage buckets when an access token gets compromised.\nWorkload identity federation is a scalable way of securely distributing cloud access to edge devices. For more information about authentication, see [Authentication at Google](/docs/authentication) .\n### Monitor and audit access to cloud resources\nEnable Cloud Audit Logs to create log entries when your edge devices access cloud resources through authenticated API requests. Cloud Audit Logs enables you to monitor critical actions that are done by your edge devices on Google Cloud. In addition, Cloud Audit Logs creates the audit traces and logs that you need to investigate any issues. For more information, see [Impersonating a service account to access Google Cloud](/iam/docs/audit-logging/examples-service-accounts#auth-as-service-account) .\n## What's next\n- Learn more about a [Technical overview of Internet of Things](/architecture/iot-overview) .\n- Read the remaining documents in the series:- [Standalone MQTT broker architecture on Google Cloud](/architecture/connected-devices/mqtt-broker-architecture) \n- [IoT platform product architecture on Google Cloud](/architecture/connected-devices/iot-platform-product-architecture) \n- [Migrate environments from IoT Core](/architecture/iot-core-migration) \n- Learn more [best practices for working with service accounts](https://cloud.google.com/iam/docs/best-practices-service-accounts)", "guide": "Docs"}