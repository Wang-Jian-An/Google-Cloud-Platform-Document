{"title": "Docs - Develop and deploy containerized apps using a CI/CD pipeline", "url": "https://cloud.google.com/architecture/app-development-and-delivery-with-cloud-code-gcb-cd-and-gke/deployment", "abstract": "# Docs - Develop and deploy containerized apps using a CI/CD pipeline\nLast reviewed 2022-11-18 UTC\nThis deployment guide describes how to set up and use a development, continuous integration (CI), and continuous delivery (CD) system using an integrated set of Google Cloud tools. You can use this system to develop and deploy applications to [Google Kubernetes Engine](/kubernetes-engine) (GKE).\nThis guide shows you how to create the architecture that's described in [Deployment pipeline for developing and delivering containerized apps](/architecture/app-development-and-delivery-with-cloud-code-gcb-cd-and-gke) .\nThis deployment guide is intended for both software developers and operators, and you play the following roles as you complete it:\n- First you act as the operator to set up the CI/CD pipeline. The main components of this pipeline are [Cloud Build](/build) , [Artifact Registry](/artifact-registry) , and [Cloud Deploy](/deploy) .\n- Then you act as a developer to change an application using [Cloud Code](/code) . When you act as a developer, you see the integrated experience that this pipeline provides.\n- Finally, you act as an operator and go through the steps to deploy an application into production.\nThis deployment guide assumes you're familiar with running `gcloud` commands on Google Cloud and with deploying application containers to GKE.\n", "content": "## Architecture\nThe following diagram shows the resources used in this deployment guide:\nFor details about the components that are used in this architecture, see [Deployment pipeline for developing and delivering containerized apps](/architecture/app-development-and-delivery-with-cloud-code-gcb-cd-and-gke#architecture) .\n## Objectives\nActing as an operator, you do the following:\n- Set up the CI pipeline and CD pipeline. This setup includes the following:- Set up the required permissions.\n- Create the GKE clusters for the staging and production environments.\n- Create a repository in Cloud Source Repositories for the source code.\n- Create a repository in Artifact Registry for the application container.\n- Create a Cloud Build trigger on the main GitHub repository.\n- Create a Cloud Deploy delivery pipeline and targets. The targets are the staging and production environment.\n- Start the CI/CD process to deploy to staging and then promote to production.\nActing as a developer, you make a change to the application. To do so, you do the following:\n- Clone the repository to work with a pre-configured development environment.\n- Make a change to the application within your developer workspace.\n- Build and test the change. The tests include a validation test for governance.\n- View and validate the change in a dev cluster. This cluster runs on minikube.\n- Commit the change into the main repository.## Costs\nIn this document, you use the following billable components of Google Cloud:\n- [Cloud Build](/build/pricing) \n- [Cloud Deploy](/deploy/pricing) \n- [Artifact Registry](/artifact-registry/pricing) \n- [Google Kubernetes Engine](/kubernetes-engine/pricing) \n- [Cloud Source Repositories](/source-repositories/pricing) \n- [Cloud Storage](/storage/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) .\nWhen you finish the tasks that are described in this document, you can avoid continued billing by deleting the resources that you created. For more information, see [Clean up](#clean-up) .\n## Before you begin\n- In the Google Cloud console, on the project selector page,   select or [create a Google Cloud project](/resource-manager/docs/creating-managing-projects) . **Note** : If you don't plan to keep the  resources that you create in this procedure, create a project instead of  selecting an existing project. After you finish these steps, you can  delete the project, removing all resources associated with the project. [Go to project selector](https://console.cloud.google.com/projectselector2/home/dashboard) \n- [Make sure that billing is enabled for your Google Cloud project](/billing/docs/how-to/verify-billing-enabled#console) .\n- Enable the Artifact Registry, Cloud Build, Cloud Deploy, Cloud Source Repositories, Google Kubernetes Engine, Resource Manager, and Service Networking APIs. [Enable the APIs](https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com,cloudbuild.googleapis.com,clouddeploy.googleapis.com,sourcerepo.googleapis.com,container.googleapis.com, cloudresourcemanager.googleapis.com,servicenetworking.googleapis.com&redirect=https://console.cloud.google.com) \n- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) At the bottom of the Google Cloud console, a [Cloud Shell](/shell/docs/how-cloud-shell-works) session starts and displays a command-line prompt. Cloud Shell is a shell environment  with the Google Cloud CLI  already installed and with values already set for  your current project. It can take a few seconds for the session to initialize.## Prepare your environment\nIn this section, you act as the application operator and do the following:\n- Set up the required permissions.\n- Create the GKE clusters for the staging and production environments.\n- Clone the source repository.\n- Create a repository in Cloud Source Repositories for the source code.\n- Create a repository in Artifact Registry for the container application.\n### Set up permissions\nIn this section, you grant the permissions that are needed to set up the CI/CD pipeline.\n- If you're working in a new instance of Cloud Shell Editor, specify the project to use for this deployment guide:```\ngcloud config set project PROJECT_ID\n```Replace with the ID of the project you selected or created for this deployment guide.If a dialog is displayed, click **Authorize** .\n- Make sure the default Compute Engine service account has sufficient permissions to run jobs in Cloud Deploy and pull containers from Artifact Registry. Cloud Build and Cloud Deploy use this default service account.This service account might already have the necessary permissions. This step ensures the necessary permissions are granted for projects that disable automatic role grants for default service accounts.```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:$(gcloud projects describe PROJECT_ID \\\u00a0 \u00a0 --format=\"value(projectNumber)\")-compute@developer.gserviceaccount.com \\\u00a0 \u00a0 --role=\"roles/clouddeploy.jobRunner\"gcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:$(gcloud projects describe PROJECT_ID \\\u00a0 \u00a0 --format=\"value(projectNumber)\")-compute@developer.gserviceaccount.com \\\u00a0 \u00a0 --role=\"roles/artifactregistry.reader\"\n```\n- Grant the Cloud Build service account privilege to invoke deployments with Cloud Deploy and to update the delivery pipeline and the target definitions:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:$(gcloud projects describe PROJECT_ID \\\u00a0 \u00a0 --format=\"value(projectNumber)\")@cloudbuild.gserviceaccount.com \\\u00a0 \u00a0 --role=\"roles/clouddeploy.operator\"\n```For more information about this IAM role, see the [clouddeploy.operator](/deploy/docs/iam-roles-permissions#predefined_roles) role.\n- Grant the Cloud Build and Cloud Deploy service account privilege to deploy to GKE:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:$(gcloud projects describe PROJECT_ID \\\u00a0 \u00a0 --format=\"value(projectNumber)\")-compute@developer.gserviceaccount.com \\\u00a0 \u00a0 --role=\"roles/container.admin\"\n```for more details about this IAM role, see the [container.admin role](/iam/docs/understanding-roles#kubernetes-engine-roles) role.\n- Grant the Cloud Build service account the permissions needed to invoke Cloud Deploy operations:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\u00a0 \u00a0 --member=serviceAccount:$(gcloud projects describe PROJECT_ID \\\u00a0 \u00a0 --format=\"value(projectNumber)\")@cloudbuild.gserviceaccount.com \\\u00a0 \u00a0 --role=\"roles/iam.serviceAccountUser\"\n```When Cloud Build invokes Cloud Deploy it uses a Compute Engine service account to create a release, which is why this permission is needed.For more details about this IAM role, see the [iam.serviceAccountUser role](/compute/docs/access/iam#the_serviceaccountuser_role) role.\nYou have now granted the permissions that are needed for the CI/CD pipeline.\n### Create the GKE clusters\nIn this section, you create the staging and production environments, which are both GKE clusters. (You don't need to set up the development cluster here, because it uses minikube.)\n- Create the staging and production GKE clusters:```\ngcloud container clusters create-auto staging \\\u00a0 \u00a0 --region us-central1 \\\u00a0 \u00a0 --project=$(gcloud config get-value project) \\\u00a0 \u00a0 --asyncgcloud container clusters create-auto prod \\\u00a0 \u00a0 --region us-central1 \\\u00a0 \u00a0 --project=$(gcloud config get-value project) \\\u00a0 \u00a0 --async\n```The staging cluster is where you test changes to your code. After you verify that the deployment in staging did not negatively affect the application, you deploy to production.\n- Run the following command and ensure the output has `STATUS: RUNNING` for both the staging and production clusters:```\ngcloud container clusters list\n```\n- Retrieve the credentials to your `kubeconfig` files for the staging and production clusters.```\ngcloud container clusters get-credentials staging --region us-central1gcloud container clusters get-credentials prod --region us-central1\n```You use these credentials to interact with the GKE clusters\u2014for example, to check that an application is running properly.\nYou have now created the GKE clusters for the staging and production environment.\n### Open the IDE and clone the repository\nTo clone the repository and view the application in your development environment, do the following:\n- Clone the GitHub repository to Cloud Shell. [](https://ssh.cloud.google.com/cloudshell/editor?cloudshell_git_repo=https%3A%2F%2Fgithub.com%2Fgoogle%2Fgolden-path-for-app-delivery&cloudshell_git_branch=main&cloudshell_open_in_editor=README.md&cloudshell_workspace=) \n- Click **Confirm** .Cloud Shell Editor opens and clones the sample repository.You can now view the application's code in your Cloud Shell Editor.\n- Specify the project to use for this deployment guide:```\ngcloud config set project PROJECT_ID\n```If a dialog is displayed, click **Authorize** .\nYou now have the source code for the application in your development environment.\nThis source repository includes the Cloud Build and Cloud Deploy files needed for the CI/CD pipeline.\n### Create repositories for the source code and for the containers\nIn this section you set up a repository in Cloud Source Repositories for the source code, and a repository in Artifact Registry to store the containers built by the CI/CD pipeline.\n- Create a repository in Cloud Source Repositories to store the source code and link it with the CI/CD process:```\ngcloud source repos create cicd-sample\n```\n- Ensure the Cloud Deploy configurations target the correct project:```\nsed -i s/project-id-placeholder/$(gcloud config get-value project)/g deploy/*git config --global credential.https://source.developers.google.com.helper gcloud.shgit remote add google https://source.developers.google.com/p/$(gcloud config get-value project)/r/cicd-sample\n```\n- Push your source code to the repository:```\ngit push --all google\n```\n- Create an image repository in Artifact Registry:```\ngcloud artifacts repositories create cicd-sample-repo \\\u00a0 \u00a0 --repository-format=Docker \\\u00a0 \u00a0 --location us-central1\n```\nYou now have a repository for source code in Cloud Source Repositories and one for the application container in Artifact Registry. The Cloud Source Repositories repository allows you to clone the source code and connect it to the CI/CD pipeline.\n## Configure the CI/CD pipeline\nIn this section, you act as the application operator and configure the CI/CD pipeline. The pipeline uses Cloud Build for CI and Cloud Deploy for CD. The steps of the pipeline are defined in the Cloud Build trigger.\n- Create a Cloud Storage bucket for Cloud Build to store the `artifacts.json` file (which tracks the artifacts generated by Skaffold for each build):```\ngsutil mb gs://$(gcloud config get-value project)-gceme-artifacts/\n```Storing each build's `artifacts.json` file in a central place is a good practice because it provides traceability, which makes troubleshooting easier.\n- Review the `cloudbuild.yaml` file, which defines the Cloud Build trigger and is already configured in the source repository that you cloned.This file defines the trigger invoked whenever there is a new push to the main branch of the source-code repository.The following steps for the CI/CD pipeline are defined in the `cloudbuild.yaml` file:- Cloud Build uses Skaffold to build the application container.\n- Cloud Build places the build's `artifacts.json` file in the Cloud Storage bucket.\n- Cloud Build places the application container in Artifact Registry.\n- Cloud Build runs tests on the application container.\n- The `gcloud deploy apply` command registers the following files with the Cloud Deploy service:- `deploy/pipeline.yaml`, which is the delivery pipeline\n- `deploy/staging.yaml`and`deploy/prod.yaml`, which are the target files\nWhen the files are registered, Cloud Deploy creates the pipeline and targets if they do not yet exist, or re-creates them if the configuration changed. The targets are the staging and production environments.\n- Cloud Deploy creates a new release for the delivery pipeline.This release references the application container that was built and tested in the CI process.\n- Cloud Deploy deploys the release to the staging environment.\nThe delivery pipeline and targets are managed by Cloud Deploy and are decoupled from the source code. This decoupling means that you don't need to update the delivery pipeline and target files when a change is made to the application's source code.\n- Create the Cloud Build trigger:```\ngcloud beta builds triggers create cloud-source-repositories \\\u00a0 \u00a0 --name=\"cicd-sample-main\" \\\u00a0 \u00a0 --repo=\"cicd-sample\" \\\u00a0 \u00a0 --branch-pattern=\"main\" \\\u00a0 \u00a0 --build-config=\"cloudbuild.yaml\"\n```This trigger tells Cloud Build to watch the source repository and to use the `cloudbuild.yaml` file to react to any changes to the repository. This trigger is invoked whenever there is a new push to the main branch.\n- Go to the Cloud Build page in the Google Cloud console. [Go to Cloud Build](https://console.cloud.google.com/cloud-build/dashboard) Notice that there are no builds for your application.\nYou have now set up the CI and CD pipelines, and created a trigger on the main branch of the repository.\n## Make a change to your application within your developer workspace\nIn this section, you act as the application developer.\nAs you develop your application, you make and verify iterative changes to the application using Cloud Code as your development workspace:\n- Make a change to the application.\n- Build and test the new code.\n- Deploy the application to the minikube cluster and verify the user-facing changes.\n- Submit the change to the main repository.\nWhen this change is committed into the main repository, the Cloud Build trigger starts the CI/CD pipeline.\n### Build, test, and run the application\nIn this section, you build, test, deploy, and access your application.\nUse the same instance of Cloud Shell Editor that you used in the preceding section. If you closed the editor, then in your browser open Cloud Shell Editor by going to [ide.cloud.google.com](https://ide.cloud.google.com) .\n- In the terminal, start minikube:```\nminikube start\n```minikube sets up a local Kubernetes cluster in your Cloud Shell. This setup takes a few minutes to run. After it's completed, the minikube process runs in the background on the Cloud Shell instance.\n- In the pane at the bottom of Cloud Shell Editor, select **Cloud Code** .\n- In the thin panel that appears between the terminal and the editor, select **Run on Kubernetes** .If you see a prompt that says `Use current context (minikube) to run the app?` , click **Yes** .This command builds the source code and runs tests. This can take a few minutes. The tests include unit tests and a pre-configured validation step that checks the rules set for the deployment environment. This ensures that you are warned about deployment issues even while you're still working in your development environment.The **Output** tab shows the Skaffold progress as it builds and deploys your application. .When the build and tests finish, the **Output** tab says `Update succeeded` , and shows two URLs.As you build and test your app, Cloud Code streams back the logs and URLs in the **Output** tab. As you make changes and run tests in your development environment, you can see your development environment's version of the app and verify that it's working correctly.The output also says `Watching for changes...` , which means that watch mode is enabled. While Cloud Code is in watch mode, the service detects any saved changes in your repository and automatically rebuilds and redeploys the app with the latest changes.\n- In the Cloud Code terminal, hold the pointer over the first URL in the output ( `http://localhost:8080` ).\n- In the tool tip that appears, select **Open Web Preview** .In the background, Cloud Code is automatically port-forwarding traffic to the `cicd-sample` service running on minikube.\n- In your browser, refresh the page.The number next to **Counter** increases, showing that the app is responding to your refresh.In your browser, keep this page open so that you can view the application as you make any changes in your local environment.\nYou have now built and tested your application in the development environment. You have deployed the application into the development cluster running on minikube, and viewed the user-facing behavior of the application.\n### Make a change\nIn this section, you make a change to the application and view the change as the app runs in the development cluster.\n- In Cloud Shell Editor, open the `index.html` file.\n- Search for the string `Sample App Info` , and change it to `sample app info` , so that the title now uses lowercase letters.The file is automatically saved, triggering a rebuild of the application container.Cloud Code detects the change and redeploys it automatically. The **Output** tab shows `Update initiated` . This redeployment takes a few minutes to run.This automatic redeploy feature is available for any application running on a Kubernetes cluster.\n- When the build is done, go to your browser where you have the app open and refresh the page.When you refresh, see that the text now uses lowercase letters.\nThis setup gives you automatic reloading for any architecture, with any components. When you use Cloud Code and minikube, anything that is running in Kubernetes has this hot code reloading functionality.\nYou can debug applications that are deployed to a Kubernetes cluster in Cloud Code. These steps aren't covered in this deployment guide, but for details, see [Debugging a Kubernetes application](/code/docs/shell/debug) .\n### Commit the code\nNow that you've made a change to the application, you can commit the code.\n- Configure your git identity:```\ngit config --global user.email \"YOU@EXAMPLE.COM\"git config --global user.name \"NAME\"\n```Replace the following:- : the email address that's connected to your GitHub account.\n- : the name that's connected to your GitHub account.\n- From the terminal, commit the code:```\ngit add .git commit -m \"use lowercase for: sample app info\"\n```You don't need to run the `git push` command here. That comes later.\nWorking in the development environment, you have now made a change to the application, built and tested the change, and verified the user-facing behavior of these changes. The tests in the development environment include governance checks, which let you fix issues that cause problems in the production environment.\nIn this deployment guide, when you commit the code into the main repository, you don't go through a code review. However, a code review or change approval is a recommended process for software development.\nFor more information about change approval best practices, see [Streamlining change approval](https://dora.dev/devops-capabilities/process/streamlining-change-approval/) .\n## Deploy a change into production\nIn this section, you act as the application operator and do the following:\n- Trigger the CI/CD pipeline, which deploys the release to the staging environment.\n- Promote and approve the release to production.\n### Start the CI/CD pipeline and deploy into staging\nIn this section, you start the CI/CD pipeline by invoking the Cloud Build trigger. This trigger is invoked whenever a change is committed to the main repository. You can also initiate the CI system with a manual trigger.\n- In the Cloud Shell Editor, run the following command to trigger a build:```\ngit push google\n```This build includes the change you made to `cicd-sample` .\n- Return to the [Cloud Build dashboard](https://console.cloud.google.com/cloud-build/dashboard) and see that a build is created.\n- Click **Running: cicd-sample - cicd-sample-main** in the build log on the right, and look for the blue text denoting the start and end of each step. **Step 0** shows the output of the `skaffold build` and `skaffold test` instructions from the `cloudbuild.yaml` file. The build and test tasks in **Step 0** (the CI part of the pipeline) passed, so the deployment tasks of **Step 1** (the CD part of the pipeline) now run.This step finishes with the following message:`Created Cloud Deploy rollout` `` `in target staging`\n- Open the [Cloud Deploy delivery pipelines page](https://console.cloud.google.com/deploy/delivery-pipelines) and click the `cicd-sample delivery` pipeline.The application is deployed in staging, but not in production.\n- Verify that the application is working successfully in staging:```\nkubectl proxy --port 8001 --context gke_$(gcloud config get-value project)_us-central1_staging\n```This command sets up a kubectl proxy to access the application.\n- Access the application from Cloud Shell:- In Cloud Shell Editor, open a new terminal tab.\n- Send a request to `localhost` to increment a counter:```\ncurl -s http://localhost:8001/api/v1/namespaces/default/services/cicd-sample:8080/proxy/ | grep -A 1 Counter\n```You can run this command multiple times and watch the counter value increment each time.As you view the app, notice that the text that you changed is in the version of the application you deployed on staging.\n- Close this second tab.\n- In the first tab, press `Control+C` to stop the proxy.You have now invoked the Cloud Build trigger to start the CI process, which includes building the application, deploying it to the staging environment, and running tests to verify the application is working in staging.\nThe CI process is successful when the code builds and tests pass in the staging environment. The success of the CI process then initiates the CD system in Cloud Deploy.\n### Promote the release to production\nIn this section, you promote the release from staging to production. The production target comes pre-configured to require approval, so you manually approve it.\nFor your own CI/CD pipeline, you might want to use a deployment strategy that launches the deployment gradually before you do a full deployment into production. Launching the deployment gradually can make it easier to detect issues and, if needed, to restore a previous release.\nTo promote the release to production, do the following:\n- Open the [Cloud Deploydelivery pipelines overview](https://console.cloud.google.com/deploy/delivery-pipelines)) and select the **cicd-sample** pipeline.\n- Promote the deployment from staging to production. To do so, do the following:- In the pipeline diagram at the top of the page, click the blue **Promote** button in the staging box.\n- In the window that opens, click the **Promote** button at the bottom.\nThe deployment is not yet running in production. It's waiting for the required manual approval.\n- Manually approve the deployment:- In the pipeline visualization, click the **Review** button between the staging and production boxes.\n- In the window that opens, click the **Review** button.\n- In the next window, click **Approve** .\n- Return to the [Cloud Deploy delivery pipelines overview](https://console.cloud.google.com/deploy/delivery-pipelines) and select the **cicd-sample** pipeline.\n- After the pipeline visualization shows the prod box as green (meaning a successful rollout), verify that the application is working in production by setting up a kubectl proxy that you use to access the application:```\nkubectl proxy --port 8002 --context gke_$(gcloud config get-value project)_us-central1_prod\n```\n- Access the application from Cloud Shell:- In Cloud Shell Editor, open a new terminal tab.\n- Increment the counter:```\ncurl -s http://localhost:8002/api/v1/namespaces/default/services/cicd-sample:8080/proxy/ | grep -A 1 Counter\n```You can run this command multiple times and watch the counter value increment each time.\n- Close this second terminal tab.\n- In the first tab, press `Control+C` to stop the proxy.You've now promoted and approved the production deployment. The application with your recent change is now running in production.\n## Clean up\nTo avoid incurring charges to your Google Cloud account for the resources used in this deployment guide, either delete the project that contains the resources, or keep the project and delete the individual resources.\n### Option 1: delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Option 2: delete the individual resources\n- Delete the Cloud Deploy pipeline:```\ngcloud deploy delivery-pipelines delete cicd-sample --region=us-central1 --force\n```\n- Delete the Cloud Build trigger:```\ngcloud beta builds triggers delete cicd-sample-main\n```\n- Delete the staging and production clusters:```\ngcloud container clusters delete staginggcloud container clusters delete prod\n```\n- Delete the repository in Cloud Source Repositories:```\ngcloud source repos delete cicd-sample\n```\n- Delete the Cloud Storage buckets:```\n`gsutil rm -r gs://$(gcloud config get-value project)-gceme-artifacts/\u00a0gsutil rm -r gs://$(gcloud config get-value project)_clouddeploy/\u00a0```\n```\n- Delete the repository in Artifact Registry:```\ngcloud artifacts repositories delete cicd-sample-repo \\\u00a0 \u00a0 --location us-central1\n```## What's next\n- To learn how to deploy into a private GKE instance, see [Deploying to a private cluster on a Virtual Private Cloud network](/deploy/docs/execution-environment#deploying_to_a_private_cluster_on_a_network) .\n- For best practices about automating your deployments, see:- [Deployment automation](https://dora.dev/devops-capabilities/technical/deployment-automation/) for how to implement, improve, and measure deployment automation.\n- [Automate your deployments](/architecture/framework/operational-excellence/automate-your-deployments) , from the Architecture Framework.\n- For more information about deployment strategies, see:- [Launch deployments gradually](/architecture/framework/operational-excellence/automate-your-deployments#launch_deployments_gradually) , from the Architecture Framework.\n- [Application deployment and testing strategies](/architecture/application-deployment-and-testing-strategies) \n- For more reference architectures, diagrams, and best practices, explore the [Cloud Architecture Center](/architecture) .", "guide": "Docs"}