{"title": "Docs - Standalone MQTT broker architecture on Google Cloud", "url": "https://cloud.google.com/architecture/connected-devices/mqtt-broker-architecture", "abstract": "# Docs - Standalone MQTT broker architecture on Google Cloud\n[MQTT](https://mqtt.org/) is an OASIS standard protocol for connected device applications that provides bidirectional messaging using a publish-and-subscribe broker architecture. The MQTT protocol is lightweight to reduce the network overhead, and MQTT clients are very small to minimize the use of resources on constrained devices. One solution for organizations who want to support connected device applications on Google Cloud is to run a standalone MQTT broker on Compute Engine or GKE. To deploy an MQTT broker in your organization, you need to make several key decisions which affect the overall architecture; in particular, load-balancing and the deployment environment. This document describes an architecture for deploying an MQTT broker, the core application in an MQTT deployment, on Google Cloud. It also describes the decisions that you need to make when you deploy this broker, and how they impact the architecture.\nThis document is part of a series of documents that provide information about IoT architectures on Google Cloud and about migrating from IoT Core. The other documents in this series include the following:\n- [Connected device architectures on Google Cloud overview](/architecture/connected-devices) \n- Standalone MQTT broker architecture on Google Cloud (this document)\n- [IoT platform product architecture on Google Cloud](/architecture/connected-devices/iot-platform-product-architecture) \n- [Best practices for running an IoT backend on Google Cloud](/architecture/connected-devices/bps-running-iot-backend-securely) \n- [Device on Pub/Sub architecture to Google Cloud](/architecture/connected-devices/device-pubsub-architecture) \n- [Best practices for automatically provisioning and configuring edge and bare metal systems and servers](/architecture/connected-devices/best-practices-provisioning-configuring-bare-metal) \n- [Migrate environments from IoT Core](/architecture/connected-devices/iot-core-migration) \nThe following diagram shows an MQTT broker architecture running on Google Cloud.\nThe architecture in the preceding image is composed as follows:\n- The MQTT broker is deployed as a cluster of three instances that are connected to the Cloud Load Balancing service. For the cloud load balancer, you can choose from one of [several load-balancing products](#load_balancing) , which are described later in this document.\n- The broker cluster includes a device credential store and a device authentication and authorization service. The cluster connects with the backend workloads through Dataflow or Pub/Sub.\n- On the client side, edge gateways provide bidirectional communication between edge devices and the MQTT broker cluster through MQTT over TLS.\nGenerally, we recommend that you deploy the MQTT broker application for this architecture in a cluster for scalability. Factors such as the clustering functionality, the scale-up and scale-down cluster management, data synchronization, and network partition handling are addressed by the specific broker implementations (such as HiveMQ, EMQX, VerneMQ, mosquito, and others).\n", "content": "## Architectural considerations and choices\nThe following sections describe the different architectural choices and considerations that you must make for a standalone MQTT broker architecture, and the impact that these choices have on the architecture.\n### Connected devices\nInternet-connected edge devices publish their telemetry events and other information to the MQTT broker. To implement the standalone MQTT broker architecture that's described in this document, the device needs to have an MQTT client, the server certificate public key for TLS authentication, and the credentials needed to authenticate with the MQTT broker.\nIn addition, edge devices generally have connectors to local sensors, to on-premises data systems, and to other devices that do not have internet access or IP connectivity. For example, the edge device can serve as a gateway for other local constrained devices connected to the gateway using BLE, to a wired connection, or to another near-field protocol. A detailed specification of the connected device architecture is outside the scope of this guide.\n## Load balancing\nIn the architecture, an external load-balancing service is configured between the public network and the MQTT broker cluster. This service provides several important networking functions, including distribution of incoming connections across backend nodes, session encryption, and authentication.\nGoogle Cloud supports several load balancer types. To choose the best load balancer for your architecture, consider the following:\n- **mTLS** . mTLS handles both encryption and device authentication methods, while standard TLS handles only encryption and requires a separate device authentication method:- If your application uses mTLS for device authentication and needs to terminate the TLS tunnel, we recommend that you use an [external passthrough Network Load Balancer](/load-balancing/docs/network) or an [external proxy Network Load Balancer with a target TCP proxy](/load-balancing/docs/tcp) . External proxy Network Load Balancers terminate the TLS session and proxy the connection to the broker node, along with any authentication credentials that are contained in the message. If you need the client connection information as part of the authentication scheme, you can preserve it in the backend connection by [enabling the PROXY protocol](/load-balancing/docs/tcp/setting-up-tcp#proxy-protocol) .\n- If your application doesn't use mTLS, we recommend that you use an [external proxy Network Load Balancer with a target SSL proxy](/load-balancing/docs/tcp) to offload the external TLS and SSL processing to the load balancer. External proxy Network Load Balancers terminate the TLS session and proxy the connection to the broker node, along with any authentication credentials that are contained in the message. If you need the client connection information as part of the authentication scheme, you can preserve it in the backend connection by [enabling the PROXY protocol](/load-balancing/docs/ssl/setting-up-ssl#proxy-protocol) .\n- **HTTP(S) endpoints** . If you need to expose HTTP(S) endpoints, we recommend that you configure a separate [external Application Load Balancer](/load-balancing/docs/https) for these endpoints.\nFor more information about the load balancer types that Cloud Load Balancing supports, see [Summary of Google Cloud load balancers](/load-balancing/docs/load-balancing-overview#summary-of-google-cloud-load-balancers) .\n### Load balancing strategy\nAny load-balancing service distributes connections from edge devices across the nodes in the cluster according to one of several algorithms or [balancing modes](/load-balancing/docs/backend-service#balancing-mode) . For MQTT, a [session affinity](/load-balancing/docs/network/networklb-backend-service#session-affinity) load-balancing strategy is better than random load balancing. Because MQTT client-server connections are persistent bidirectional sessions, state is maintained on the broker node that stops the connection. In a clustered configuration, if a client disconnects and then reconnects to a different node, the session state is moved to the new node, which adds load on the cluster. This issue can be largely avoided by using session affinity load balancing. If clients frequently change their IP addresses, the connection can break, but in most cases session affinity is better for MQTT. Session affinity is available in all Cloud Load Balancing products.\n## Device authentication and credential management\nMQTT broker applications handle device authentication and access control separately from Google Cloud. A broker application also provides its own credential store and management interface. The MQTT protocol supports basic username and password authentication in the initial Connect packet, and these fields are also frequently used by broker implementations to support other forms of authentication such as X.509 Certificate or JWT authentication. MQTT 5.0 also adds support for enhanced authentication methods that use challenge and response-style authentication. The authentication method that's used depends on the choice of MQTT broker application and your connected device use case.\nRegardless of the authentication method that the broker uses, the broker maintains a device credential store. This store can be in a local SQL database or a flat file. Some brokers, including HiveMQ and VerneMQ, also support the use of a managed database service such as Cloud SQL. You need a separate service to manage the device credential store and handle any integrations with other authentication services such as IAM. The development of this service is outside the scope of this guide.\nFor more information about authentication and credential management, see [Best practices for running an IoT backend on Google Cloud](/architecture/connected-devices/bps-running-iot-backend-securely) .\n## Backend workloads\nAny connected device use case includes one or more backend applications that use the data ingested from the connected devices. Sometimes, these applications also need to send commands and configuration updates to the devices. In the standalone MQTT broker architecture in this document, incoming data and outgoing commands are both routed through the MQTT broker. There are different topics within the broker's topic hierarchy to differentiate between the data and the commands.\nData and commands can be sent between the broker and the backend applications in one of several ways. If the application itself supports MQTT, or if it can be modified to support MQTT, the application can subscribe directly to the broker as a client. This approach enables you to use the MQTT Pub/Sub bidirectional messaging capability directly by using your application to receive data from and send commands to the connected devices.\nIf your application does not support MQTT, there are several other options. In the architecture described in this document, Apache Beam provides an MQTT driver, which allows bidirectional integration with Dataflow and other Beam deployments. Many brokers also have plugin capabilities that support integration with services like Google Pub/Sub. These are typically one-way integrations for data integration, although some brokers support bidirectional integration.\n## Use cases\nAn MQTT broker architecture is particularly well suited for the device use cases that are described in the following sections.\n### Standards-based data ingestion from heterogeneous devices\nWhen you want to collect and analyze data from a large fleet of heterogeneous devices, an MQTT broker is often a good solution. Because MQTT is a widely adopted and implemented standard, many edge devices have built-in support for it, and lightweight MQTT clients are available to add MQTT support to devices that don't. The publish-and-subscribe paradigm is also a part of the MQTT standard, so MQTT-enabled devices can take advantage of this architecture without additional implementation work. By contrast, devices that connect to Pub/Sub must implement the Pub/Sub API or use the Pub/Sub SDK. Running a standards-compliant MQTT broker on Google Cloud thus provides a simple solution for collecting data from a wide range of devices.\nWhen your connected devices are not controlled by your application but by a third party, you might not have access to the device system software, and the management of the device itself would be the other party's responsibility. In that circumstance, we recommend that you run an MQTT broker and provide authentication credentials to the third party to set up the device-to-cloud communication channel.\n### Bidirectional communication for multi-party application integration\nThe bidirectional messaging capability of MQTT makes it very suitable for a multiparty-mobile-application use case such as on-demand food delivery or a large-scale web chat application. MQTT has low protocol overhead, and MQTT clients have low resource demands. MQTT also features publish-and-subscribe routing, multiple quality of service (QoS) levels, built-in message retention, and broad protocol support. An MQTT broker can be the core component of a scalable messaging platform for on-demand services applications and similar use cases.\n### Edge-to-cloud integrated messaging\nBecause of the standardization and low overhead that MQTT offers, it can also be a good solution for integrating on-premises and cloud-based messaging applications. For instance, a factory operator can deploy multiple MQTT brokers in the on-premises environment to connect to sensors, machines, gateways, and other devices that are behind the firewall. The local MQTT broker can handle all bidirectional command and control and telemetry messaging for the on-premises infrastructure. The local broker can also be connected by two-way subscription to a parallel MQTT broker cluster in the cloud, allowing communication between the cloud and the edge environment without exposing the on-premises devices and systems to the public internet.\n## What's next\n- Learn how to connect devices and build IoT applications on Google Cloud using [Intelligent Products Essentials](/architecture/intelligent-products-essentials-architecture) .\n- Learn about practices for [automatically provisioning and configuring edge andbare metal systems and servers](/architecture/best-practices-provisioning-configuring-bare-metal) .\n- For more reference architectures, diagrams, and best practices, explore the [Cloud Architecture Center](/architecture) .", "guide": "Docs"}