{"title": "Docs - Building a serverless DevOps pipeline for Salesforce with Cloud Build", "url": "https://cloud.google.com/architecture/building-a-serverless-devops-pipeline-for-salesforce", "abstract": "# Docs - Building a serverless DevOps pipeline for Salesforce with Cloud Build\nLast reviewed 2021-02-22 UTC\nThis tutorial shows you how to build a serverless continuous integration/continuous deployment (CI/CD) pipeline for Salesforce using [Salesforce Developer Experience](https://developer.salesforce.com/platform/dx) (SFDX) and [Cloud Build](/solutions/continuous-delivery) . Cloud Build pipelines use containerization. The pipelines run builds as a series of build steps, where each build step is run in a Docker container. The pipeline can scale up and down in response to load with no need to pre-provision servers, and it offers fast, consistent, automated builds.\nThis tutorial is intended for anyone who is responsible for designing, developing, and maintaining DevOps workflows in an organization. These roles can include architects, DevOps teams, and engineers. Different sections of the document illustrate parts of the pipeline for different roles. For example, one part is for administrators and DevOps leads, and another part is for Salesforce developers.\nThe document assumes that you're familiar with Salesforce DX, the Salesforce CLI, Git, GitHub, Docker, Google Cloud products such as Cloud Build, and containerization concepts. It also assumes that you have a GitHub account.\nSoftware development lifecycles can vary widely; this tutorial assumes that you follow an [agile](https://agilemanifesto.org/) release methodology.", "content": "## Objectives\n- Set up Salesforce Developer Experience.\n- Set up a Git branching strategy.\n- Configure Cloud Build.\n- Run the CI/CD pipeline for Salesforce using Google Cloud build tools and GitHub.\n## CostsThis tutorial uses the following billable components of Google Cloud:- [Cloud Build](/cloud-build/pricing) \n- [Cloud Storage](/storage/pricing) \nUse the [Pricing Calculator](/products/calculator) to generate a cost estimate based on your projected usage.\nYou might also incur Salesforce costs. In the tutorial, you use a Salesforce Developer Edition org, which might be free. For more information, see the Salesforce page about [Developer Edition](https://developer.salesforce.com/signup) .## Before you begin- In the Google Cloud console, on the project selector page,   select or [create a Google Cloud project](/resource-manager/docs/creating-managing-projects) . **Note** : If you don't plan to keep the  resources that you create in this procedure, create a project instead of  selecting an existing project. After you finish these steps, you can  delete the project, removing all resources associated with the project. [Go to project selector](https://console.cloud.google.com/projectselector2/home/dashboard) \n- [Make sure that billing is enabled for your Google Cloud project](/billing/docs/how-to/verify-billing-enabled#console) .\n- Enable the Cloud Build API. [Enable the API](https://console.cloud.google.com/flows/enableapi?apiid=cloudbuild.googleapis.com) \n- In the Google Cloud console, activate Cloud Shell. [Activate Cloud Shell](https://console.cloud.google.com/?cloudshell=true) \n- Make sure that you have a Salesforce account that can assume the role  of the Dev Hub org. If you don't have an org, then you can create a  Developer Edition account on the [Salesforce developer site](https://developer.salesforce.com/signup) .\nWhen you finish this tutorial, you can avoid continued billing by deleting the resources you created. For more information, see [Cleaning up](https://docs.google.com/document/d/1tFoK8q0JLw0gd7JPKTStlvDKudM4-yLJxjdkiUO8c1Y/edit#heading=h.mlrdlgcohh7k) ## ArchitectureThe following diagram illustrates the architecture of the CI/CD workflow that you create in this tutorial. In this architecture, projects are organized as releases. Developers who want to work on a feature create a new feature branch from a release branch.The diagram illustrates the following flow:- Developers create feature branches in GitHub for the features that they are developing.\n- Developers complete development work and run unit tests in [Salesforce scratch orgs](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs.htm) .\n- Developers commit and push their development work to their source code repository (GitHub in this tutorial).\n- Developers create a [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) to merge their work into the release branch.\n- The creation of a pull request automatically triggers a Cloud Build job to run tests.\n- Responsible personnel (usually team leads) review and approve pull requests to merge development work into the release branch.\n- A merge into the release branch automatically triggers a Cloud Build job to deploy the codebase to QA or to other Salesforce environments.\n- Optionally, manual tests and reviews are performed in a QA environment.\n- Responsible personnel create a pull request to merge code into the`main`branch.\n- The pull request to the`main`branch triggers a Cloud Build job to deploy code to production.\nDevelopers who want to work on projects start by cloning the project repository from the enterprise source control tool (GitHub in this tutorial). The following diagram represents this strategy as a graph.As illustrated in the diagram, the branching strategy consists of the following:- A main branch. The code in the main branch reflects the current version of the code that's running in production.\n- A release branch. A release branch is a relatively longer-lived branch (compared to a feature branch) that coordinates all changes and code that's pertinent to a release. An organization creates a new release branch for each new release.\n- One or more feature branches. Feature branches help to isolate work that's in progress from the most up-to-date version of code in the main branch. Typically, several feature branches make up a release branch. It's a good practice for developers to create feature branches for bug fixes.\nAfter developers clone a project repository, they develop on their local machine or in a [Salesforce scratch org](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_scratch_orgs.htm) . They can use a scratch org to run unit tests on the changes they make. If the unit tests pass, they commit their code and push the code into the source code repository. They then generate a pull request for their code to be merged into the parent release branch.\nThe pull request automatically triggers a Cloud Build job that does the following:- Creates a new scratch org to run unit tests.\n- Updates the pull request with the result of the tests.\nAt this point, team leads and product owners can review the pull request. If the request is approved, the changes are merged into the release branch.\nDepending on your software development lifecycle, you can have additional automated steps that are triggered based on a merge to the release branch. Examples of automated steps are deploying the validated code to a higher [sandbox](https://help.salesforce.com/articleView?id=sf.create_test_instance.htm&type=5) , such as quality assurance or system integration testing sandboxes.\nYou can also configure Cloud Build to send build notifications and perform additional actions using Cloud Functions, Cloud Run, or other Google Cloud tools. (These additional actions are not covered in this tutorial.) This approach provides the flexibility to tailor the pipeline to suit your enterprise DevOps framework.\nFor simplicity, in this tutorial you deploy the sample codebase to a single Salesforce org ( [Dev Hub](https://help.salesforce.com/articleView?id=sfdx_setup_enable_devhub.htm&type=5) ). When you build a CI/CD pipeline for production, you use the architecture illustrated earlier and automate deployments to sandboxes that are part of your software development lifecycle.## Personas who are typically involved in software developmentEvery organization is different and each has its own array of roles and teams. The following table lists key personas (roles) that typically interact with Salesforce DevOps pipelines like the one described in this tutorial.\nPeople in different roles have different responsibilities for setting up Salesforce pipelines. Therefore, the tutorial has two paths. One path is for administrators and DevOps leads, and the other path is for developers.\n| Persona      | Responsibilities                                                                                                   |\n|:-----------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Administrator or DevOps lead | Sets up the Dev Hub org. Generates certificates that enable users to connect to the Dev Hub org from the Salesforce CLI. Creates connected apps in all the Salesforce environments to which code is deployed by using the DevOps pipeline. Sets up developer accounts in the Dev Hub org. Sets up the DevOps pipeline and any required triggers. Initializes the source code repository. Sets up Cloud Build triggers. |\n| Salesforce developer   | Clones the source code repository. Sets up the Salesforce CLI for development. Develops and unit-tests features in a release. When the features are finished, generates a pull request to merge features into the release branch.                                              |\n| QA lead      | Reviews and approves pull requests to merge a developer's work on a feature into the release branch.                                                                              |\n| Release lead     | Manages and approves the pull requests for merging into the main branch, which promotes code to production.                                                                            |## Setting up pipelines for Salesforce administrators and DevOps leadsThis section describes the tasks that administrators and DevOps teams follow to set up the CI/CD workflow.\n### Enable the Dev Hub org\n- Sign in to your Salesforce production org.\n- In the **Setup** tab, in the **Quick Find** box, enter `Dev Hub` , and then select **Dev Hub** . \n- Enable Dev Hub.This step lets you set up a scratch org. You use the scratch org to deploy the sample code in the tutorial to a Salesforce [Developer Edition](https://developer.salesforce.com/signup) org.\n### Create a certificate and key pairAfter you enable the Dev Hub org, you need to generate a certificate and key pair that can be used to authenticate to the Salesforce Dev Hub org. You use this certificate and key pair when you configure Cloud Build in later steps.\nFor production CI/CD pipelines, you need to generate additional certificates to authenticate to Salesforce sandboxes. (You don't create these additional certificates as part of this tutorial.) When you generate certificates and key pairs for each environment, make sure that you give them identifiable names, as in the following examples:- Production (Dev Hub org):`salesforce.key`and`salesforce.crt`. You use these names in the procedure that follows.\n- Quality Assurance sandbox (QA):`salesforce_qa.key`and`salesforce_qa.crt`.\n- Integrated Development sandbox (IDEV):`salesforce_dev.key`and`salesforce_dev.crt`.\nTo generate a certificate and key pair, follow these steps:- In Cloud Shell, generate a certificate and key pair so Cloud Build can authenticate to your Salesforce Dev Hub org from the Salesforce CLI:```\nopenssl req -x509 -sha256 -nodes -days 36500 -newkey \\rsa:2048 -keyout salesforce.key -out \\salesforce.crt\n```You're prompted to enter details to identify the certificate. For this tutorial, these values aren't important, so press **Enter** to accept the defaults.Notice that in the command, you're using the names `salesforce.key` and `salesforce.crt` , because you're creating the certificate and key pair for the Dev Hub org.\n- Click **More** and select **Download File** .\n- In the **Fully qualified file path** box, enter the following filename and then click **Download** :```\nsalesforce.crt\n```This step downloads the certificate that you generated to your local machine. You upload the certificate to your Salesforce org in the next section.\n### Create connected apps in SalesforceIn this section, you create a connected application that Cloud Build can use to deploy your Salesforce code. For this tutorial, you deploy code only to the Dev Hub org. In a production environment, you deploy code for each sandbox and for the production org where you want Cloud Build to deploy your Salesforce code for the DevOps pipeline.\nAs part of this process, you use the certificate and key pair that you generated in the previous section. The certificate is the public key for authenticating the Salesforce client in a Cloud Shell session to the Salesforce Dev Hub org (Salesforce sandbox). The certificate is also used to authenticate Cloud Build for automated deployments.\nThe details of some of the steps in the following procedure depend on what edition of Salesforce you're using. Make sure that you use the correct certificate and key pairs for the selected environment.- If you're using Salesforce Lightning Experience, use the App Manager to create connected apps. From **Setup** in your Salesforce org, do the following:- In the **Quick Find** box, enter`App`.\n- Select **App Manager** .\n- Click **New Connected App** .\nIf you're using Salesforce Classic, from **Setup** in your Salesforce org, do the following:- In the **Quick Find** box, enter`Apps`.\n- Under **Build\u00a0>\u00a0Create** , select **Apps** .\n- Under **Connected Apps** , click **New** .\n- For the name of your application, enter `Google Cloud DevOps` .This fills `Google_Cloud_DevOps` into the **API Name** box.\n- Enter the contact email information and any other information that's appropriate for your application.\n- Select **Enable OAuth Settings** .\n- For the **Callback URL** value, enter the following URL:```\nhttp://localhost:1717/OauthRedirect\n```\n- To enable the option to use digital signatures, click **Choose File** , and then select the `salesforce.crt` file that you downloaded earlier.\n- Add the following OAuth scopes to **Selected OAuth Scopes** :- **Access and manage your data (api)** \n- **Perform requests on your behalf at any time (refresh_token,\noffline_access)** \n- **Provide access to your data via the web (web)** \n \n- Click **Save** and then click **Continue** .\n- Make a note of the **Consumer Key** value that's displayed in the API section; you need it later when you set up the Cloud Build manifest.If you're working in a production environment, you have a key for each deployment environment.\n- Click **Manage** , and then to change OAuth policies, click **EditPolicies** .\n- Set **Permitted users** to **Admin Approved Users are Pre-Authorized** and confirm the choice.\n- Set IP relaxation to **Relax IP Restrictions** .\n- Click **Save** .\n- Click **Manage Profiles** and select the **System Administrator** option.After this step, users who assume this profile can sign in to the Salesforce CLI.\n- Click **Save** .\n### Initialize the Google Cloud environment\n- In Cloud Shell, set the project that you created or selected as the default project:```\ngcloud config set project PROJECT_ID\n```Replace with the ID of your Google Cloud project.\n- Assign settings for [region and zone](/compute/docs/regions-zones) :```\ngcloud config set compute/region us-central1gcloud config set compute/zone us-central1-a\n```In this tutorial, you use `us-central1` as the region and `us-central1-a` as the zone.\n- Export the current Google project ID to an environment variable named `GCP_PROJECT_NUMBER` :```\nexport GCP_PROJECT_NUMBER=$(gcloud projects describe $DEVSHELL_PROJECT_ID --format='value(projectNumber)')\n```\n### Upload Salesforce keys to Cloud Storage\n- In Cloud Shell, create a Cloud Storage bucket in your build project to store the Salesforce private key files:```\ngsutil mb -p ${DEVSHELL_PROJECT_ID} -l us-central1 \\\u00a0 \u00a0 gs://salesforce-ref-${DEVSHELL_PROJECT_ID}\n```The bucket must have a globally unique name. This command creates a bucket name that includes your Google Cloud project ID.\n- Copy the Salesforce private keys that you generated in the [Enablingthe Dev Hub org](#enabling-the-dev-hub) section to the new Cloud Storage bucket:```\ngsutil cp salesforce.key gs://salesforce-ref-${DEVSHELL_PROJECT_ID}\n```\n### Create your GitHub repository\n- In Cloud Shell, clone the repository that's associated with this tutorial:```\ngit clone https://github.com/GoogleCloudPlatform/salesforce-serverless-cicd-cloudbuild\n```\n- Create a [new GitHub repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-new-repository) named `` .Replace with the name you want to assign to the repository locally.This is the repository that developers pull code from or push code to. For the purposes of this tutorial, you create this repository in your own GitHub account.\n- Go to the cloned repository:```\ncd salesforce-serverless-cicd-cloudbuild\n```\n- Add your developer GitHub repository as a remote repository:```\ngit remote add github DEV_REPO_NAME\n```\n### Configure Cloud BuildIn this section, you complete the setup steps that are required in order to trigger Cloud Build jobs when developers generate pull requests to merge their work into a release branch.\nYou set up two triggers for the CI/CD pipeline that you create in this tutorial:- A trigger that runs a Cloud Build job when a developer creates a pull request to merge code into the release branch. A typical use for this trigger is to run unit tests.\n- A trigger that runs a Cloud Build job when a pull request is merged into the release branch. A typical use for this trigger is to deploy changes to a destination sandbox (Dev Hub in this tutorial).\nCloud Build runs your build as a set of steps, where each step runs in a Docker container. You build a base Docker container image that includes the Salesforce CLI, and Cloud Build uses Salesforce CLI commands to run the job.- In Cloud Shell, create a Dockerfile for the image you need to build:```\ncat <<EOF > DockerfileFROM debian:busterRUN apt-get update && \\apt-get install -y wget xz-utilsRUN wget https://developer.salesforce.com/media/salesforce-cli/sfdx-linux-amd64.tar.xz && \\mkdir sfdx && \\tar xJf sfdx-linux-amd64.tar.xz -C sfdx --strip-components 1 && \\./sfdx/installENTRYPOINT [ \"sfdx\" ]EOF\n```\n- Export the name of the Docker image to an environment variable named `SFDX_BASE_IMAGE` :```\nexport SFDX_BASE_IMAGE=\"gcr.io/${DEVSHELL_PROJECT_ID}/salesforcedx-base-image:1\"\n```\n- Build your container with Cloud Build and publish the image to Container Registry:```\ngcloud builds submit --tag ${SFDX_BASE_IMAGE}\n```\nYou define a Cloud Build job by editing a `cloudbuild.yaml` file.- In Cloud Shell, create a `cloudbuild.yaml` file to define the job steps to run when Cloud Build deploys code to your Salesforce Dev Hub org:```\ncat <<EOF > cloudbuild.yamlsteps:- name: gcr.io/cloud-builders/gsutil\u00a0 args: ['cp', 'gs://\\${_BUCKET_NAME}/salesforce.key', 'salesforce.key']- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args:\u00a0 - force:auth:jwt:grant\u00a0 - --setdefaultusername\u00a0 - -u\u00a0 - \\${_SF_USERNAME}\u00a0 - -f\u00a0 - ./salesforce.key\u00a0 - -i\u00a0 - \\${_CONSUMER_KEY}- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args: ['force:source:deploy', '-p', './force-app/']substitutions:\u00a0 _BUCKET_NAME: __BUCKET_NAME__\u00a0 _SF_USERNAME: __USERNAME__\u00a0 _CONSUMER_KEY: __CONSUMER_KEY__EOF\n```The file configures Cloud Build to do the following:- Download the`salesforce.key`file that Cloud Build uses to authenticate to the Dev Hub org.\n- Start a Docker container that has the Salesforce CLI installed and then connect to the Dev Hub org by using a JWT grant. Cloud Build uses configuration parameters such as the consumer key and the Salesforce username that's in the Cloud Build trigger definition.\n- Deploy the code pushed by the developer to the Dev Hub org or to another destination sandbox in production CI/CD pipelines.\n **Note:** To keep this tutorial brief, this step shows you how you can deploy directly to your Dev Hub org. In production CI/CD pipelines, you typically use a trigger to deploy to test environments such as quality assurance\u00a0(QA) or user acceptance testing\u00a0(UAT) sandboxes.\n- Create another file called `cloudbuild_pr.yaml` to define the job steps to run when Cloud Build deploys code from a pull request to a temporary Salesforce scratch org or sandbox for testing:```\ncat <<EOF > cloudbuild_pr.yamlsteps:- name: gcr.io/cloud-builders/gsutil\u00a0 args: ['cp', 'gs://\\${_BUCKET_NAME}/salesforce.key', 'salesforce.key']- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args:\u00a0 - force:auth:jwt:grant\u00a0 - -u\u00a0 - \\${_SF_USERNAME}\u00a0 - -f\u00a0 - ./salesforce.key\u00a0 - -i\u00a0 - \\${_CONSUMER_KEY}- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args:\u00a0 - force:org:create\u00a0 - --setdefaultusername\u00a0 - --definitionfile\u00a0 - config/project-scratch-def.json\u00a0 - --targetdevhubusername\u00a0 - \\${_SF_USERNAME}\u00a0 - --setalias\u00a0 - testing org- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args: ['force:source:push']- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args: ['force:apex:test:run', '--resultformat', 'tap', '--codecoverage']- name: \"${SFDX_BASE_IMAGE}\"\u00a0 args: ['force:org:delete', '--noprompt']substitutions:\u00a0 _BUCKET_NAME: __BUCKET_NAME__\u00a0 _SF_USERNAME: __USERNAME__\u00a0 _CONSUMER_KEY: __CONSUMER_KEY__EOF\n```The file configures Cloud Build to do the following:- Download the`salesforce.key`file that Cloud Build uses to authenticate to the Dev Hub org.\n- Start a Docker container that has the Salesforce DX CLI installed and connect to the Dev Hub org by using a JWT grant. Cloud Build uses configuration parameters such as the consumer key and the Salesforce username in the Cloud Build trigger definition.\n- Create a new scratch org to deploy the developer's code for automated testing.\n- Run Apex texts in the scratch org.\n- Output the Apex text outcome, which becomes available in the GitHub pull request summary.\n- Delete the temporary scratch org.\n### Push your repository to GitHub\n- In Cloud Shell, add the new `cloudbuild yaml` file and the Dockerfile to the repository and push the files into the main branch of the repository. When you're prompted, log in to GitHub.```\ngit add .git commit -m \"Added cloud build configuration\"git push github main\n```\n- Create a release branch that developers can pull code from or push code to. For this tutorial, name the branch `release-sample` .```\ngit checkout -b release-sample\n```\n- Push the branch to GitHub:```\ngit push github release-sample\n```\n### Connect your GitHub repository to Cloud Build\n- Go to the [Cloud Build Application page](https://github.com/marketplace/google-cloud-build) on the GitHub marketplace.\n- Scroll down and click **Setup with Google Cloud Build** . If you're prompted, sign in to GitHub.\n- Connect your repository to Cloud Build:- Select **Only select repositories** .\n- In the **Select repositories** list, select **repository** .\n- Click **Install** .\n- Sign in to Google Cloud.The **Authorization** page is displayed, where you're prompted to authorize the **Google Cloud Build** application to connect to Google Cloud.\n- Click **Authorize Google Cloud Build by GoogleCloudBuild** .You're redirected to the Google Cloud console.\n- Select your Google Cloud project.\n- If you agree, accept the terms and then click **Next** .\n- In the **Select repository** page, select the GitHub repository.\n- Click **Connect repository** .\n- Click **Create Push Trigger** .\n### Update the Cloud Build trigger definitionYou define the details for the new trigger that was created when you clicked **Create Push Trigger** in the previous section.- In the Google Cloud console, open the **Cloud Build Triggers** page. [Go to the Cloud Build Triggers page](https://console.cloud.google.com/cloud-build/triggers) \n- Click more_vert **Menu** for the new trigger and then click **Edit** .\n- Set **Name** to `pull-request-to-release-branch` .\n- Change the description to `Run unit tests when a pull request is created from a feature branch` .\n- Change **Event** to **Pull Request (GitHub App only)** .\n- For **Source** , in the **Base branch** text box, enter the following expression:```\n^release.*\n```\n- For **Configuration** , select **Cloud Build configuration file (yaml or json)** and enter `cloudbuild_pr.yaml` in the text box.\n- Under **Substitution variables** , create three variables. For each variable, do the following:- Click **Add Item** .\n- Set the **Variable** and **Value** fields as listed in the following table:| Variable  | Value                                            |\n|:--------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| _BUCKET_NAME | The name of the Cloud Storage bucket for the Salesforce key file, in the following format: salesforce-ref-PROJECT_ID Replace PROJECT_ID with the ID of your Google Cloud project. |\n| _CONSUMER_KEY | The consumer key in the connected application that you created in the Salesforce Dev Hub org.                      |\n| _SF_USERNAME | The Salesforce username for the Dev Hub org.                                  |\n- Click **Save** .Don't close this page. You do further work in this page in the next procedure.\n### Create a second Cloud Build triggerThe next step is to create another trigger to start Cloud Build jobs when commits are made to the release branch. This trigger invokes a Cloud Build job to push the changes to your Dev Hub org. In your DevOps pipeline, you must make sure that only authorized personnel and processes are able to commit changes to the release branch.\n **Note:** In production DevOps pipelines, commits made to the release branch typically trigger deployments into higher sandboxes such as system integration testing (SIT) and UAT sandboxes. However, for this tutorial, you use the DevOps pipeline only to work with a deployment to the Dev Hub org.- In the [Cloud Build Triggers page](https://console.cloud.google.com/cloud-build/triggers?_ga=2.55998445.-755479868.1547216833) , click **Create Trigger** to create a new trigger.\n- Set **Name** to`commits-to-release-branch`.\n- For **Trigger Type** , select **Push to a Branch** .\n- In the **Repository** list, select your GitHub Salesforce repository.\n- In the **Branch (regex)** text box, enter the following expression:```\n^release.*\n```\n- For **Build Configuration** , select **Cloud Build configurationfile** and enter `cloudbuild.yaml` .\n- Under **Substitution variables** , create three variables. For each variable, do the following:- Click **Add Item** .\n- Set the **Variable** and **Value** fields as listed in the following table.| Variable  | Value                                          |\n|:--------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| _BUCKET_NAME | Enter the name of the bucket for the Salesforce key file, in the following format: salesforce-ref-PROJECT_ID Replace PROJECT_ID with the ID of your Google Cloud project. |\n| _CONSUMER_KEY | The consumer key in the connected application that you created in the Salesforce Dev Hub org.                    |\n| _SF_USERNAME | The Salesforce username for the Dev Hub org.                                |\n- Click **Save** .\n### Add permissions to allow Cloud Build to read Salesforce keys\n- In Cloud Shell, add permissions to your Cloud Build service account to allow the account to read Salesforce keys from the Cloud Storage bucket that you created:```\ngsutil iam ch serviceAccount:$GCP_PROJECT_NUMBER@cloudbuild.gserviceaccount.com:objectViewer \\\u00a0 \u00a0 gs://salesforce-ref-${DEVSHELL_PROJECT_ID}\n```\n## Setting up pipelines for Salesforce developersThe tasks described in this section are for Salesforce developers.\nIf you performed the steps in the earlier part of this tutorial that are in the section for administrators and leads, make sure that you use a different set of credentials to run the steps in this section.\n **Note:** For the tasks that follow, you need to perform the steps from a local environment where you have access to a browser.\nThe Salesforce DX CLI installation steps might vary based on the OS you're using. The steps in this section describe the steps for Debian Linux. For instructions for macOS and Windows, see [Install the Salesforce CLI](https://developer.salesforce.com/docs/atlas.en-us.sfdx_setup.meta/sfdx_setup/sfdx_setup_install_cli.htm) in the Salesforce documentation.\n### Setting up Salesforce DX CLIIn this section, you install the Salesforce CLI and set up authorization for it.- On your local machine (not in Cloud Shell), go to the home directory:```\ncd $HOME\n```\n- Install the `xz-utils` and `wget` tools:```\nsudo apt-get install --assume-yes xz-utils wget\n```\n- Install the Salesforce CLI:```\nwget https://developer.salesforce.com/media/salesforce-cli/sfdx-linux-amd64.tar.xz\n```\n- Create an `sfdx` directory:```\nmkdir sfdx\n```\n- Extract the downloaded tar file:```\ntar xJf sfdx-linux-amd64.tar.xz -C sfdx --strip-components 1\n```\n- Install the CLI:```\n./sfdx/install\n```The Salesforce CLI is installed in `/usr/local/bin/sfdx` .\n- Verify that the CLI has been set up correctly:```\nsfdx\n```The output is similar to the following:```\nVERSION\nsfdx-cli/7.8.1-8f830784cc linux-x64 node-v10.15.3\nUSAGE\n$ sfdx [COMMAND]\nCOMMANDS\ncommands list all the commands\nforce  tools for the Salesforce developer\nhelp  display help for sfdx\nplugins add/remove/create CLI plug-ins\nupdate update the sfdx CLI\nwhich  show which plugin a command is in\nTOPICS\nRun help for each topic below to view subcommands\ncommands list all the commands\nforce  tools for the Salesforce developer\nplugins add/remove/create CLI plug-ins\n```\n### Connect your local development environment to your Salesforce Dev Hub org\n- From your local machine, log into your Salesforce org using credentials for a developer role:```\nsfdx force:auth:web:login --setalias YOUR_HUB_ORG\n```Replace with an appropriate alias for your Dev Hub org.This command opens a web browser on your local machine, so you can't run it on a VM that you're connected to.\n### Clone the GitHub repository\n- Clone the GitHub repository that was created by your Salesforce administrator:```\ngit clone DEV_REPO_NAME -o github\n```\n- Go to the directory of the cloned repository:```\ncd DEV_REPO_NAME\n```\n### Push the Salesforce codebase and metadata to a scratch orgIn this section, you push the codebase and metadata to a scratch org so it can be unit-tested.- On your local machine, export your Dev Hub username to an environment variable named `SALESFORCE_USERNAME` :```\nexport SALESFORCE_USERNAME=YOUR_DEVHUB_USERNAME\n```Replace with the username that you set up earlier.\n- Create a scratch org to test the repository that you cloned for this tutorial:```\nsfdx force:org:create \\\u00a0 \u00a0 --setdefaultusername \\\u00a0 \u00a0 --definitionfile config/project-scratch-def.json \\\u00a0 \u00a0 --targetdevhubusername ${SALESFORCE_USERNAME} \\\u00a0 \u00a0 --setalias feature-test-scratch-org\n```\n- Push the metadata and code to the scratch org:```\nsfdx force:source:push\n```\n- Generate a URL for the scratch org and navigate to it in a browser window:```\nsfdx force:org:open\n```\nTypically the next step in a project's lifecycle is for you to run unit tests and validate features that you've developed. You won't do that in this tutorial because you're working with pre-validated sample code.\n### Push your code to a source code repository\n- On your local machine, create a new branch named `feature-1` :```\ngit checkout -b feature-1\n```\n- Push the changes to a source code repository:```\ngit add .git commit -m \"Feature 1 changes\"git push github feature-1\n```For this tutorial, you use GitHub as the source code tool.\n## Test the deploymentThis section describes tests that you can run to verify that the triggers you created are functional. The repository that your Salesforce administrator created contains a sample test class.- On your local machine (not in the Cloud Shell), create a new Git branch:```\ngit checkout -b feature-1\n```\n- Using a text editor, open the following file:```\n./force-app/main/default/classes/SampleTest.cls\n```\n- To make the test fail, in the `System.assertEquals` statement, change the value `101` to `102` . After you make the change, save the file, but keep it open because you change it again later in this procedure.```\n@isTestpublic class SampleTest {static testmethod void testAddOne() {\u00a0 \u00a0 Test.startTest();\u00a0 \u00a0 System.assertEquals(Sample.addOne(100), 102); // Change to 102 from 101\u00a0 \u00a0 Test.stopTest();\u00a0 }}\n```\n- Add and commit the change to the feature branch:```\ngit add .git commit -m \"Changed test case\"git push github feature-1\n```\n- Create a pull request to merge your code into the release-sample branch.A new Cloud Build job is triggered. However, the job fails because the unit test fails.\n- To view the status of the build, open the **Cloud Build** page. [Go to the Cloud Build page](https://console.cloud.google.com/cloud-build/dashboard) \n- Go to the **History** section of the **Cloud Build** page.You see the following build log for the job, which shows that the test assertion failed.```\nStep #4: not ok 1 SampleTest.testAddOne\nStep #4: # System.AssertException: Assertion Failed: Expected: 101, Actual: 102\nStep #4: # Class.SampleTest.testAddOne: line 24, column 1\nStep #4: # Run \"sfdx force:apex:test:report -i 7076300001gEzne --resultformat <format>\" to retrieve test results in a different format.\n[. . .]\nFinished Step #4\nERROR\nERROR: build step 4 \"gcr.io/serverless-devops-sf/salesforcedx-base-image:1\" failed: step exited with non-zero status: 100\n```\n- To make the test pass, in the `./force-app/main/default/classes/SampleTest.cls` file, change the value `102` back to `101` :```\n@isTestpublic class SampleTest {static testmethod void testAddOne() {\u00a0 \u00a0 Test.startTest();\u00a0 \u00a0 System.assertEquals(Sample.addOne(100), 101); //Change back to 101 from 102\u00a0 \u00a0 Test.stopTest();\u00a0 }}\n```\n- Add and commit the change to the feature branch:```\ngit add .git commit -m \"Changed test case to make it pass\"git push github feature-1\n```The commit operation triggers a Cloud Build job.\n- When the job completes, review the pull request in GitHub and merge it into the `release-sample` branch.In production workflows, the authority to merge pull requests is typically limited to DevOps leads and administrators. For more information about how you can set this up, see [Defining the mergeability of pull requests](https://docs.github.com/en/github/administering-a-repository/defining-the-mergeability-of-pull-requests) on the GitHub site.\n- In the Google Cloud console, [review](https://console.cloud.google.com/cloud-build/builds?_ga=2.45865644.987950293.1611309183-1914691750.1611309183) the Cloud Build job that is automatically triggered when you merge the pull request into the release-sample branch.\n- When the job completes, log into your Dev Hub org. You can log on either as a developer or as an administrator.The developer's code modifications are available in this Salesforce org. To see them, go to the **Setup** page and look under **Custom Code/Apex classes** .\n## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this   tutorial, either delete the project that contains the resources, or keep the project and   delete the individual resources.\n### Delete the project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\nIf you plan to explore multiple architectures, tutorials, or quickstarts, reusing projects  can help you avoid exceeding project quota limits.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete Salesforce resourcesYou can also delete the Salesforce Developer Edition org and the associated scratch org that you created for this tutorial.\n- Go to the Salesforce Dev Hub org.\n- From Setup, in the **Quick Find** box, enter`Company`, and then select **Company Information** .\n- Click **Company Information** .\n- Click the **Deactivate Org** button. \n- In Cloud Shell, run the following command to delete your Salesforce scratch org:```\nsfdx force:org:delete -u feature-test-scratch-org\n```\n### Delete the GitHub repositoryGo to GitHub and delete the repository that you created in your personal account for this tutorial.## What's nextFor more reference architectures, diagrams, and best practices, explore the [Cloud Architecture Center](/architecture) .", "guide": "Docs"}