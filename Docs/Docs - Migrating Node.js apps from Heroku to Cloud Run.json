{"title": "Docs - Migrating Node.js apps from Heroku to Cloud Run", "url": "https://cloud.google.com/architecture/migrating-nodejs-apps-from-heroku-to-cloud-run", "abstract": "# Docs - Migrating Node.js apps from Heroku to Cloud Run\nLast reviewed 2023-10-01 UTC\nThis tutorial describes how to migrate Node.js web apps that are running on Heroku to Cloud Run on Google Cloud. This tutorial is intended for architects and product owners who want to migrate their apps from Heroku to managed services on Google Cloud.\nCloud Run is a managed compute platform that lets you run stateless containers that are invocable through HTTP requests. It is built on open source [Knative](/knative) , which enables portability across platforms and supports container workflows and standards for continuous delivery. The Cloud Run platform is well integrated with the Google Cloud product suite and makes it easier for you to design and develop apps that are portable, scalable, and resilient.\nIn this tutorial, you learn how to migrate an app to Google Cloud that's written in Node.js and uses [Heroku Postgres](https://devcenter.heroku.com/categories/heroku-postgres) as a backing service on Heroku. The web app is containerized and hosted in Cloud Run and uses Cloud SQL for PostgreSQL as its persistence layer.\nIn the tutorial, you use a simple app called Tasks that lets you view and create tasks. These tasks are stored in Heroku Postgres in the current deployment of the app on Heroku.\nThis tutorial assumes that you are familiar with the basic functionality of [Heroku](https://www.heroku.com/) and that you have a Heroku account (or access to one). It also assumes you are familiar with [Cloud Run](/run) , [Cloud SQL](/sql/docs/postgres) , [Docker](https://www.docker.com/) , and [Node.js](https://nodejs.org/en/) .", "content": "## Objectives\n- Build a Docker image to deploy the app to Cloud Run.\n- Create a Cloud SQL for PostgreSQL instance to serve as the backend after migration to Google Cloud.\n- Review the Node.js code to understand how Cloud Run connects to Cloud SQL and to see the code changes (if any) that are required in order to migrate to Cloud Run from Heroku.\n- Migrate data from Heroku Postgres to Cloud SQL for PostgreSQL.\n- Deploy the app to Cloud Run.\n- Test the deployed app.\n## Costs\nIn this document, you use the following billable components of Google Cloud:- [Cloud Run](/run/pricing) \n- [Cloud Storage](/storage/pricing) \n- [Cloud SQL for PostgreSQL](/sql/pricing) \n- [Container Registry](/container-registry/pricing) \nTo generate a cost estimate based on your projected usage,  use the [pricing calculator](/products/calculator) . \nYou might also be charged for the resources you use on Heroku.## Before you begin\n## Setting up your environment\n- Open Cloud Shell. [OPEN Cloud Shell](https://console.cloud.google.com/?cloudshell=true) \n- In Cloud Shell, set environment variables and default values for the Google Cloud CLI used in this tutorial.```\ngcloud config set project PROJECT_ID\ngcloud config set run/region us-central1\n```Replace `` with your project ID.\n## ArchitectureThe following figures outline the web app's architecture on Heroku (as is) and its architectural layout on Google Cloud (that you will build).The Tasks app that's currently deployed in Heroku consists of one or more web dynos. Web dynos are able to receive and respond to HTTP traffic, unlike worker dynos, which are better suited for background jobs and timed tasks. The app serves an index page that displays tasks stored in a Postgres database, using the Mustache templating library for Node.js.\nYou can access the app at an HTTPS URL. A `/tasks` route at that URL lets you create new tasks.On Google Cloud, Cloud Run is used as the serverless platform to deploy the Tasks app. Cloud Run is designed to run stateless, request-driven containers. It is well suited for when you need your managed service to support containerized apps that autoscale and also scale to zero when they're not serving traffic.## Mapping components used in Heroku to Google CloudThe following table maps components in the Heroku platform to Google Cloud. This mapping helps you translate the architecture outlined in this tutorial from Heroku to Google Cloud.\n| Component | Heroku platform                                                                      | Google Cloud                                                 |\n|:------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Containers | Dynos: Heroku uses the container model to build and scale Heroku apps. These Linux containers are called dynos and can scale to a number that you specify to support resource demands for your Heroku app. You can select from a range of dyno types based on your app's memory and CPU requirements. | Cloud Run containers: Google Cloud supports running containerized workloads in stateless containers that can be run in a fully managed environment or in Google Kubernetes Engine (GKE) clusters.    |\n| Web app  | Heroku app: Dynos are the building blocks of Heroku apps. Apps usually consist of one or more dyno types, usually a combination of web and worker dynos.                                    | Cloud Run service: A web app can be modeled as a Cloud Run service. Each service gets its own HTTPS endpoint and can automatically scale up or down from 0 to N based on the traffic to your service endpoint. |\n| Database | Heroku Postgres is Heroku's database as a service (DaaS) based on PostgreSQL.                                                       | Cloud SQL is a managed database service for relational databases on Google Cloud.                                |## Deploying the sample Tasks web app to HerokuThe next sections show how to set up the command-line interface (CLI) for Heroku, clone the GitHub source repository, and deploy the app to Heroku.\n### Set up the command-line interface for HerokuThis tutorial runs the Heroku CLI in Cloud Shell and must [authenticate using a Heroku API key](https://devcenter.heroku.com/articles/authentication) . When running in Cloud Shell, the Heroku CLI cannot authenticate using a password or web-based authentication.\nAlternatively, if you do run the sample on a local terminal, you can use any Heroku CLI authentication method. When running the tutorial on a local terminal, you must also install [Google Cloud CLI](/sdk/docs/downloads-interactive) , [git](https://git-scm.com/downloads) , and [Docker](https://docs.docker.com/get-docker/) .- Log in to the [web console for Heroku](https://dashboard.heroku.com/account) , and then from your account settings page, copy the value of your API key.\n- In Cloud Shell, [install the Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli#other-installation-methods) \n- In Cloud Shell, authenticate the Heroku CLI. When prompted for your password, enter the value of your API key that you copied from the Heroku console, not the password you use to sign in to the console.```\nheroku login --interactive\n```\n### Clone the source repository\n- In Cloud Shell, clone the sample Tasks app GitHub repository:```\ngit clone https://github.com/GoogleCloudPlatform/migrate-webapp-heroku-to-cloudrun-node.git\n```\n- Change directories to the directory created by cloning the repository:```\ncd migrate-webapp-heroku-to-cloudrun-node\n```The directory contains the following files:- A Node.js script called`index.js`with the code for the routes served by the web app.\n- `package.json`and`package-lock.json`files that outline the web app's dependencies. You must install these dependencies in order for the app to run.\n- A`Procfile`file that specifies the command that the app executes on startup. You create a`Procfile`file to deploy your app to Heroku.\n- A`views`directory, with the HTML content served by the web app on the \"/\" route.\n- A`.gitignore`file.\n### Deploy an app to Heroku\n- In Cloud Shell, create a Heroku app:```\nheroku create\n```Make note of the name created for the app. You need this value in the next step.\n- Create an environment variable for the Heroku app name:```\nexport APP_NAME=APP_NAME\n```Replace `` with the app name returned by the `heroku create` command.\n- Add the Heroku Postgres add-on to provision a PostgreSQL database:```\nheroku addons:create heroku-postgresql:mini\n```\n- Make sure the add-on was successfully added:```\nheroku addons\n```If the Postgres add-on was successfully added, you see a message similar to the following:```\nAdd-on    Plan  Price  State\n----------------- ----- -------- ----heroku-postgresql mini  5$/month created\n```\n- Deploy the app to Heroku:```\ngit push heroku master\n```\n- Run the following command to confirm the value of DATABASE_URL.```\nheroku config\n```Make note of the retrieved value for DATABASE_URL. You need this value in the next step.\n- Run a Docker container.```\ndocker run -it --rm postgres psql \"DATABASE_URL\"\n```Replace `` with the Heroku Postgres URL that you noted in the previous step.\n- In the Docker container, create the `TASKS` table by using the following command:```\nCREATE TABLE TASKS\n(DESCRIPTION TEXT NOT NULL);\n```\n- Exit the container:```\nexit\n```\n- In Cloud Shell, get the Web URL for your Heroku app by running the following command:```\nheroku info\n```\n- Open the web URL in a browser window. The app looks the following screenshot (although your version won't have the tasks listed): \n- Create sample tasks in your app from the browser. Make sure the tasks are retrieved from the database and visible in the UI.\n## Preparing the web app code for migration to Cloud RunThis section details the steps that you need to complete to prep your web app for deployment to Cloud Run.\n### Build and publish your Docker container to Container RegistryYou need a Docker image to build the app container so it can run in Cloud Run. You can build the container manually or by using Buildpacks.\n- In Cloud Shell, create a Dockerfile in the directory created by cloning the repository for this tutorial:```\ncat <<\"EOF\" > Dockerfile\n# Use the official Node image.\n# https://hub.docker.com/_/node\nFROM node:10-alpine\n# Create and change to the app directory.\nWORKDIR /app\n# Copying this separately prevents re-running npm install on every code change.\nCOPY package*.json ./\nRUN npm install\n# Copy local code to the container image.\nCOPY . /app\n# Configure and document the service HTTP port.\nENV PORT 8080\nEXPOSE $PORT\n# Run the web service on container startup.\nCMD [\"npm\", \"start\"]\nEOF\n```\n- Build your container with [Cloud Build](/build) and publish the image to [Container Registry](/container-registry) :```\ngcloud builds submit --tag gcr.io/PROJECT_ID/APP_NAME:1 \\\n --gcs-log-dir=gs://PROJECT_ID_cloudbuild\n```\n- Create an environment variable to hold the name of the Docker image that you created:```\nexport IMAGE_NAME=\"gcr.io/PROJECT_ID/APP_NAME:1\"\n```\n- In Cloud Shell, [install thepack CLI](https://buildpacks.io/docs/install-pack/) .\n- Set the pack CLI to use the Heroku builder by default:```\npack config default-builder heroku/buildpacks:22\n```\n- Create an environment variable to hold the Docker image name:```\nexport IMAGE_NAME=gcr.io/PROJECT_ID/APP_NAME:1\n```\n- Build the image using the `pack` command and push or publish the image to Container Registry:```\npack build --publish $IMAGE_NAME\n```### Create a Cloud SQL for PostgreSQL instanceYou create a Cloud SQL for PostgreSQL instance to serve as the backend for the web app. In this tutorial, PostgreSQL is best suited as the sample app deployed on Heroku, which uses a Postgres database as its backend. For purposes of this app, migrating to Cloud SQL for PostgreSQL from a managed Postgres service requires no schema changes.\n **Note:** Database migration from on-premises or hosted environments to Google Cloud is a multi-step process that requires careful planning, schema and data migration, and testing. For more information, see the [Cloud Run documentation](/run/docs) and [importing data into Cloud SQL](/sql/docs/postgres/import-export/importing) .- Prepare your network for Cloud SQL with a private IP address.```\ngcloud compute addresses create google-managed-services-default \\\n --global \\\n --purpose=VPC_PEERING \\\n --prefix-length=16 \\\n --description=\"peering range for CloudSQL Private Service Access\" \\\n --network=default\ngcloud services vpc-peerings connect \\\n --service=servicenetworking.googleapis.com \\\n --ranges=google-managed-services-default \\\n --network=default \\\n --project=PROJECT_ID\n```\n- Create an environment variable called `CLOUDSQL_DB_NAME` to hold the name of the database instance that you create in the next step:```\nexport CLOUDSQL_DB_NAME=tasks-db\n```\n- Create the database:```\ngcloud sql instances create $CLOUDSQL_DB_NAME \\\n--cpu=1 \\\n--memory=4352Mib \\\n--database-version=POSTGRES_15 \\\n--region=us-central1 \\\n--network default \\\n--no-assign-ip\n```The instance might take a few minutes to initialize.\n- Set a password for the Postgres user:```\ngcloud sql users set-password postgres \\\n --instance=$CLOUDSQL_DB_NAME \\\n --password=POSTGRES_PASSWORD\n```Replace `` with the password that you want to use for the Postgres database.\n### Import data into Cloud SQL from Heroku PostgresThere are multiple migration patterns that you can use to migrate data into Cloud SQL. Generally, the best approach that requires little or no downtime is to configure Cloud SQL as a replica to the database being migrated, and making Cloud SQL the primary instance after migration. Heroku Postgres doesn't support external replicas (followers), so in this tutorial, you use open source tools to migrate the app's schema.\nFor the Tasks app in this tutorial, you use the [pg_dump](https://www.postgresql.org/docs/9.4/app-pgdump.html) utility to export data from Heroku Postgres to a Cloud Storage bucket and then import it into Cloud SQL. This utility can transfer data across homogeneous versions or when the destination database's version is newer than the source database.- In Cloud Shell, get the database credentials for your Heroku Postgres database that's attached to the sample app. You need these credentials in the next step.```\nheroku pg:credentials:url\n```This command returns the connection information string and connection URL for your application. The connection information string has the following format:```\n\"dbname=DATABASE_NAME host=FQDN port=5432 user=USER_NAME password=PASSWORD_STRING sslmode=require\"\n```You need the values shown in the connection string in the next step.For an example of an ( [fully qualified domain name](https://wikipedia.org/wiki/Fully_qualified_domain_name) ) value in a connection information string, see the [Heroku documentation](https://devcenter.heroku.com/articles/heroku-postgresql-credentials) .\n- Set environment variables to hold Heroku values that you use in subsequent steps:```\nexport HEROKU_PG_DBNAME=DATABASE_NAME\nexport HEROKU_PG_HOST=FQDN\nexport HEROKU_PG_USER=USER_NAME\nexport HEROKU_PG_PASSWORD=PASSWORD_STRING\n```Replace the following:- ``: the database name shown in the information string.\n- ``: the FQDN shown in the information string.\n- ``: the user name shown in the information string.\n- ``: the password string shown in the information string.\n- Create a SQL format backup of your Heroku Postgres database:```\ndocker run \\\n -it --rm \\\n -e PGPASSWORD=$HEROKU_PG_PASSWORD \\\n -v $(pwd):/tmp \\\n --entrypoint \"pg_dump\" \\\n postgres \\\n -Fp \\\n --no-acl \\\n --no-owner \\\n -h $HEROKU_PG_HOST \\\n -U $HEROKU_PG_USER \\\n $HEROKU_PG_DBNAME > herokudump.sql\n```\n- Create an environment variable to hold the name of your Cloud Storage bucket:```\nexport PG_BACKUP_BUCKET=gs://PROJECT_ID-pg-backup-bucket\n```\n- Create a Cloud Storage bucket:```\ngcloud storage buckets create $PG_BACKUP_BUCKET \\\n --location=us-central1 \\\n --public-access-prevention \\\n --uniform-bucket-level-access\n```\n- Upload the SQL file to this bucket:```\ngcloud storage cp herokudump.sql $PG_BACKUP_BUCKET/herokudump.sql\n```\n- Authorize your Cloud SQL instance with the [necessary roles to import the SQL file](/sql/docs/mysql/import-export/import-export-sql) from the Cloud Storage bucket:```\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n --member=serviceAccount:$(gcloud sql instances describe $CLOUDSQL_DB_NAME --format='get(\"serviceAccountEmailAddress\")') \\\n --role=roles/storage.objectAdmin\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n --member=serviceAccount:$(gcloud sql instances describe $CLOUDSQL_DB_NAME --format='get(\"serviceAccountEmailAddress\")') \\\n --role=roles/cloudsql.editor\n```\n- Import the SQL file to the Cloud SQL instance:```\ngcloud sql import sql $CLOUDSQL_DB_NAME $PG_BACKUP_BUCKET/herokudump.sql \\\n --database=postgres \\\n --user=postgres\n```When prompted `do you want to continue (y/n)` , enter \"y\".\n### How Cloud Run accesses the Cloud SQL databaseJust as the web app deployed to Heroku needs to connect to the managed instance of Heroku Postgres, Cloud Run requires access to Cloud SQL in order to be able to read and write data.\nCloud Run communicates with Cloud SQL using the Cloud SQL proxy that's automatically activated and configured when you deploy the container to Cloud Run. The database doesn't need to have external IP addresses approved because all the communication that it receives is from the proxy using secure TCP.\nYour code needs to invoke database operations (such as fetching data from the database or writing to it) by invoking the proxy over a UNIX socket.\nBecause this web app is written in Node.js, you use the `pg-connection-string` library to parse a database URL and create a `config` object. The advantage of this approach is that it makes connecting to the backend database seamless across Heroku and Cloud Run.\nIn the next step, you pass the database URL as an environment variable when you deploy the web app.\n### Deploy the sample app to Cloud Run\n- In Cloud Shell, configure [serverless vpc access](/vpc/docs/serverless-vpc-access) to allow private traffic from Cloud Run to Cloud SQL:```\ngcloud compute networks subnets create serverless-connector-subnet \\\n--network=default \\\n--range=10.0.0.0/28 \\\n--region=us-central1\ngcloud compute networks vpc-access connectors create serverless-connector \\\n--region=us-central1 \\\n--subnet=serverless-connector-subnet\n```\n- In Cloud Shell, create an environment variable that holds the connection name of the Cloud SQL instance that you created:```\nexport DB_CONN_NAME=$(gcloud sql instances describe $CLOUDSQL_DB_NAME --format='value(connectionName)')\n```\n- Create an environment variable called `DATABASE_URL` to hold the connection string to connect to the Cloud SQL Proxy over a UNIX port.```\nexport DATABASE_URL=\"socket:/cloudsql/${DB_CONN_NAME}?db=postgres&user=postgres&password=POSTGRES_PASSWORD\"\n```\n- Create a service account for Cloud Run with an IAM role to connect to the database:```\ngcloud iam service-accounts create sa-run-db-client\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n --member=serviceAccount:sa-run-db-client@PROJECT_ID.iam.gserviceaccount.com \\\n --role=roles/cloudsql.client\n```\n- Deploy the web app to Cloud Run:```\ngcloud run deploy tasksapp-PROJECT_ID \\\n --image=$IMAGE_NAME \\\n --service-account=sa-run-db-client@PROJECT_ID.iam.gserviceaccount.com \\\n --set-env-vars=DATABASE_URL=$DATABASE_URL \\\n --add-cloudsql-instances $DB_CONN_NAME \\\n --vpc-connector serverless-connector \\\n --allow-unauthenticated\n```The preceding command also links your Cloud Run container to the Cloud SQL database instance that you created. The command sets an environment variable for Cloud Run to point to the `DATABASE_URL` string that you created in the previous step. **Note:** Because this sample tasks app is a public facing web app and uses the `--allow-unauthenticated` flag, deployment will fail if your organization has the [Organization Policy iam.allowedPolicyMemberDomains](https://cloud.google.com/resource-manager/docs/organization-policy/restricting-domains) enforced. To deploy a Cloud Run sample app that is public-facing and unauthenticated, disable the policy on your tutorial project. For a real app that requires authentication for end users, review [authenticating end users](https://cloud.google.com/run/docs/authenticating/end-users) .\n## Testing the application\n- In Cloud Shell, get the URL at which Cloud Run serves traffic:```\ngcloud run services list\n```You can also review the Cloud Run Service in the Google Cloud console.\n- Make sure that your web app is accepting HTTP requests by navigating to your Cloud Run Service URL.\nCloud Run creates, or , a new container when an HTTP request is sent to the serving endpoint and if a container is not already running. This means that the request that causes a new container to spin up might take a bit longer to be served. Given that extra time, take into account the number of concurrent requests that your app can support and any specific memory requirements it might have.\nFor this app, you use the default concurrency settings, which allow for a Cloud Run service to serve 80 requests concurrently from a single container.## Clean upTo avoid incurring charges to your Google Cloud account for the resources used in this tutorial. You might also want to delete the resources created in Heroku for this tutorial.\n### Delete the Google Cloud project\n- **Caution** : Deleting a project has the following effects:- **Everything in the project is deleted.** If you used an existing project for  the tasks in this document, when you delete it, you also delete any other work you've  done in the project.\n- **Custom project IDs are lost.** When you created this project, you might have created a custom project ID that you want to use in  the future. To preserve the URLs that use the project ID, such as an`appspot.com`URL, delete selected resources inside the project instead of deleting the whole project.\n- In the Google Cloud console, go to the **Manage resources** page. [Go to Manage resources](https://console.cloud.google.com/iam-admin/projects) \n- In the project list, select the project that you  want to delete, and then click **Delete** .\n- In the dialog, type the project ID, and then click **Shut down** to delete the project.\n### Delete the Heroku AppTo delete the sample app you deployed to Heroku and the associated PostgreSQL add-on, run the following command:\n```\nheroku apps:destroy -a APP_NAME\n```## What's next\n- Learn about [importing data into Cloud SQL](/sql/docs/postgres/import-export/importing) .\n- Explore the [Cloud Run documentation](/run/docs) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Docs"}