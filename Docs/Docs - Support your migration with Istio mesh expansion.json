{"title": "Docs - Support your migration with Istio mesh expansion", "url": "https://cloud.google.com/architecture/migrate-with-istio-mesh-expansion", "abstract": "# Docs - Support your migration with Istio mesh expansion\nLast reviewed 2023-11-02 UTC\nThis document shows an architecture that uses an [Istio service mesh](https://istio.io/docs/concepts/what-is-istio/#what-is-a-service-mesh) to migrate from a legacy environment, like an on-premises data center running applications in virtual machines, to [Google Kubernetes Engine (GKE)](/kubernetes-engine) . Using a service mesh can reduce the complexity of migration and refactoring because it decouples network functions from service functions.\nThis document explains the rationale of the migration and outlines its high-level phases. You can use this architecture to perform a migration in one operation (sometimes called a ), or to perform a gradual, feature-by-feature migration. The accompanying deployment document guides you through an example migration.\nThis architecture and its deployment guide are intended for IT professionals who manage a complex infrastructure that they want to gradually migrate and modernize, while minimizing the following:\n- Downtime\n- Refactoring effort\n- Operational complexity of your network\nThe concepts that are explained apply to any cloud, so the document assumes that you're familiar with cloud technologies, containers, and microservices.\nAs described in [Migrate to Google Cloud: Get started](/architecture/migration-to-gcp-getting-started) , there are several patterns for migrating to the cloud. The architecture in this document uses a refactor pattern (sometimes called ), where the pattern is applied to each feature of the application, rather than to the application as a whole.\nDuring the migration, the application has a hybrid architecture where some features are on Google Cloud and some are still in the legacy environment. After the migration is finished, the complete application is hosted on Google Cloud.\n", "content": "## Architecture\nThe following diagram shows how you can use a service mesh to route traffic either to microservices running in the source environment or to Google Cloud:\nThe architecture includes the following components:\n- A source environment, in this case a Compute Engine instance that hosts the example workload to migrate. The source environment can also be on-premises or hosted in other cloud platforms.\n- A service mesh, in this case Istio Gateway, which links different services together. The service mesh provides high-value networking features such as service discovery, secure communications, load balancing, traffic management, and observability.A typical implementation of a service mesh pairs each service with a proxy that provides those features. The service proxy is most often referred to as a . The role of the sidecar is to augment and improve the application it's attached to, often without the awareness of the application. In the accompanying deployment guide, you use [Envoy](https://www.envoyproxy.io/) as a sidecar proxy.\n- A workload that contains an application that's made up of microservices. A microservice is a standalone component that's built to accommodate an application feature. In this architecture, the application is composed of different microservices that are indistinguishable to users. For example, a component that handles book reviews is a microservice.In the microservices pattern, the application is the aggregate of multiple microservices, each with a specific goal. For example, you might have one microservice that handles the book ratings and another that handles book reviews. Those microservices should be loosely coupled, and they should interface with each other through well-defined APIs. They can be written in different languages and frameworks (as in [polyglot applications](https://en.wikipedia.org/wiki/Polyglot_(computing)) ), and they can have different lifecycles.\n- A container that serves to further define the boundaries of each microservice. Because the target environment in this architecture is orchestrated with Kubernetes, we recommend that you containerize your microservices by using the following tools:- [Docker](https://www.docker.com/) is a tool to isolate user-space level programs at the [operating system level](https://en.wikipedia.org/wiki/OS-level_virtualisation) . It runs packages called.\n- [Kubernetes](https://kubernetes.io/) is the leading orchestration solution for containerized workloads. It provides features like service discovery, load balancing, self-healing pods and nodes, and secret and configuration management.\n- [GKE](/kubernetes-engine) is a managed, production-ready Kubernetes environment, part of Google Cloud.\nFor advice on how to containerize these microservices, see [Best practices for building containers](/architecture/best-practices-for-building-containers) and [Best practices for operating containers](/architecture/best-practices-for-operating-containers) .\nTo perform a migration by using a service mesh, you complete the following phases:\n- **Assess the legacy environment** : Gather information and establish a set of requirements for the target environment and a baseline for testing and validation.\n- **Build a foundation in the target environment** : Provision your target environment and apply an [infrastructure-as-code methodology](/docs/terraform/resource-management/managing-infrastructure-as-code) to make your infrastructure auditable, repeatable, and automatically provisionable.\n- **Deploy services and start routing traffic to the target environment** : Complete a single operation to deploy all the microservice instances at the same time, or complete a gradual deployment to deploy one microservice at a time.\n- **Stop routing traffic to the legacy environment** : Set up routing rules to route traffic to services that are running in the target environment only.\n- **Retire the legacy environment** : Update your DNS records to point to the load balancer you set up during the target environment provisioning phase.\nThis document describes some design considerations for this type of migration, and the accompanying deployment guide provides detailed steps to complete the migration.\n## Design considerations\nThis section provides guidance to help you develop an architecture that meets your specific requirements for reliability, operational efficiency, cost, and performance optimization.\n### Reliability\nThe following sections describe considerations for the reliability of your migration.\nAlthough this architecture can be used for a single-operation migration, we recommend that you use a gradual migration strategy. Completing a migration in one operation is difficult because of the challenges and risks that are involved in migrating one or more applications all at once. When you have constraints on time and budget, focusing on a single-operation migration doesn't leave much capacity for work on new application features.\nBy contrast, a gradual, feature-by-feature migration has a lower overall complexity due to the smaller size of the workload to migrate: a single feature has a smaller footprint compared to a whole application. A gradual migration lets you spread the risk across smaller migration events, instead of on a single, high-stakes exercise. A gradual migration also lets the migration team plan, design, and develop multiple migration strategies to accommodate different kinds of features.\nFor guidance on how to choose which features to migrate first and how to migrate stateful features, see [Choosing the apps to migrate first](/architecture/migration-to-gcp-assessing-and-discovering-your-workloads#choosing_the_apps_to_migrate_first) in \"Migrate to Google Cloud: Assess and discover your workloads.\"\nTo help facilitate your migration, we recommend that you use a . A compliance test suite is a set of tests that you can run against an environment to check whether it satisfies a given set of requirements. If the environment is valid, it meets the requirements. For example, you can validate the response to a test request, or you can check if the dependencies of the application are installed.\nYou can start with monitoring, tracing, and service mesh visualization tools for a manual validation. Then you can implement the test suite and evolve it over time in the following ways:\n- **Load test** : You can evolve the test suite by automatically sending test traffic to the environment and evaluating the results.\n- **Compliance testing tool** : You can design and develop a test suite using a dedicated tool.\nRun the compliance test suite against the legacy environment as a baseline and also against the target environment during and after the migration.\nYour test suites should focus on the following aspects to validate during the migration:\n- **Provisioning** : Provision the resources that you need in your environment before you configure them.\n- **Configuration** : After you provision resources in the environment, configure them to your application needs. Having a configuration test suite ensures that the environment is ready to host your application.\n- **Business logic** : After you validate the provisioning and the configuration of the environment, validate the business logic of your application. For example, you could validate the responses to requests.\n[Chef InSpec](https://www.inspec.io/) , [RSpec](https://rspec.info/) , and [Serverspec](https://serverspec.org/) are tools to develop automated compliance test suites. They work on any platform, and they're extensible so that you can implement your own controls, starting from the built-in controls.\nWhen you provision your target environment, you can use the compliance test suite to validate it. You might have to update the test suite to account for the eventual differences between the legacy and the target environment, like hardware and network topology. Keep in mind that you're moving from an on-premises environment, where you have full control, to a public cloud environment, where you usually don't have full access to the whole stack.\nBefore you route traffic from the load-balancing layer of the legacy environment to the target environment, we recommend that you run the business logic compliance test suite against the microservices that are exposed by the target environment. The test suite can help to ensure that the microservices are working as expected. For example, you can validate the responses returned by services that are exposed by the service mesh. You can keep the original route as a backup option in case you need to roll back the changes and revert to the legacy environment. By routing a small portion of production traffic to instances of the microservices that are running in the target environment, you can build confidence in the target environment and increase total traffic over time.\nDuring the compliance test phase, we recommend that you refine the routing rules to disallow cross-environment requests, so that when a client request hits an environment, either legacy or target, it stays in that environment. Disallowing cross-environment requests helps to ensure that tests correctly validate the target environment. If you don't disallow these requests, a test might report success on the source environment instead of the target environment without your knowledge.\nBefore you retire the legacy environment, verify that all of the following is true:\n- No traffic is being routed to instances of microservices running in the legacy environment.\n- No traffic comes through the interfaces of the legacy environment.\n- The target environment has been completely validated.\nWhen these conditions are met, you can update your DNS records to point to the load balancer you set up during the target environment provisioning phase. Don't retire the legacy environment unless you're sure that the target environment has been validated. And don't limit the validation to the business logic only, but consider other nonfunctional requirements like performance and scalability.\n### Operational efficiency\nThe following sections describe considerations for operational efficiency of your migration.\nBefore you design or implement a migration plan, you should assess the legacy environment to gather information and to establish a set of requirements for the target environment and a baseline for testing and validation. You start by building a catalog of all the application features to migrate. For each feature, you should be able to answer this non-exhaustive set of questions:\n- What are the runtime environment and performance requirements?\n- Are there any dependencies on other features?\n- Is this feature business critical?\n- Is this feature stateless or stateful?\n- How much refactoring is expected to migrate it?\n- Can this feature afford a cut-over window?\nFor more information, see [Migrate to Google Cloud: Assess and discover your workloads](/architecture/migration-to-gcp-assessing-and-discovering-your-workloads) .\nThe architecture uses a service mesh because it decouples service functions (how business logic is implemented) from network functions (how and when to route traffic to service functions). In the accompanying deployment, you use [Istio](https://istio.io/) as the service mesh.\nIn the legacy environment, most service calls don't involve the network, because they occur in a monolithic platform. In a microservices architecture, communications between services occur over a network, and services must handle this different model. A service mesh abstracts away functions to handle network communications, so you don't have to implement them in each application. A service mesh also reduces the operational complexity of the network because it provides secure communication channels, load balancing, traffic management, and observability features that don't require any configuration.\nBy deploying and configuring a service mesh, you can dynamically route traffic to either the legacy environment or the target environment. You don't need to modify the configuration of the application to support your migration, because traffic management is transparent to services in the mesh.\nAlthough this approach works well for stateless features, you need to do additional planning and refactoring in order to migrate features that are stateful, latency sensitive, or highly coupled to other features:\n- **Stateful** : When you migrate stateful features, you have to migrate data as well, in order to minimize downtime and to mitigate synchronization and integrity issues during the migration. You can read more about data migration strategies in the [Evaluating data migration approaches](/architecture/migration-to-google-cloud-transferring-your-large-datasets#data_migration_approaches) section of \"Migration to Google Cloud: Transferring your large datasets.\"\n- **Latency sensitive** : If a feature is sensitive to latency when communicating with other features, you might need to deploy additional components during the migration process. Proxies that can prefetch data or caching layers are commonly used to mitigate this sensitivity.\n- **Highly coupled to other features** : If two or more features are highly coupled, you might have to migrate them at the same time. Although this approach is easier than migrating a whole application, it might be harder than migrating a single feature.Because your legacy environment isn't directly integrated with the service mesh, when you configure your migration, you have to manually register all services that are running in the legacy environment with the service mesh. If your environment is already running in Kubernetes, you can automate the registration by using the built-in integration with the service mesh APIs.\nAfter you register the legacy environment, you use the service mesh to expose the microservices that are running in the legacy environment. You can then gradually route traffic to microservices from the interfaces of the legacy environment to the interfaces of the target environment.\nClients won't see any service disruption, because they access the interfaces of the two environments through a load-balancing layer. Traffic routing inside the service mesh is transparent to clients, so clients won't know that routing configuration has been changed.\n### Cost optimization\nThis architecture uses the following billable components of Google Cloud:\n- [Compute Engine](/compute) \n- [Google Kubernetes Engine (GKE)](/kubernetes-engine) \n- [Persistent Disk](/persistent-disk) \n- [Networking](/vpc) \nWhen you deploy the architecture, you can use the [pricing calculator](/products/calculator) to generate a cost estimate based on your projected usage.\n### Performance optimization\nIn this architecture, traffic is almost equally split between the services that are running in Compute Engine and the services that are running in GKE. The service mesh balances traffic between the instances of a service that it selects, whether they're running in the GKE cluster or in the Compute Engine instances. If you want all the traffic to go through the service mesh, you need to reconfigure the workloads that are running in Compute Engine to point to the services in the service mesh, instead of connecting to them directly. You can configure the load-balancing policy for the revisions of each service with the [DestinationRule](https://istio.io/latest/docs/reference/config/networking/destination-rule/) resource.\n## Deployment\nTo deploy this architecture, see [Deploy your migration with Istio mesh expansion](/architecture/migrate-with-istio-mesh-expansion/deployment) .\n## What's next\n- Read about [GKE](/kubernetes-engine) .\n- Read about [Istio](https://istio.io/) .\n- For more reference architectures, diagrams, and best practices, explore the [Cloud Architecture Center](/architecture) .", "guide": "Docs"}