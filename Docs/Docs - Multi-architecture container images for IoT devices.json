{"title": "Docs - Multi-architecture container images for IoT devices", "url": "https://cloud.google.com/architecture/building-multi-architecture-container-images-iot-devices", "abstract": "# Docs - Multi-architecture container images for IoT devices\nThis document is the first part of a series that discusses building an automated [continuous integration (CI)](https://wikipedia.org/wiki/Continuous_integration) pipeline to build multi-architecture [container](https://wikipedia.org/wiki/OS-level_virtualization) images on Google Cloud. The concepts that are explained in this document apply to any cloud environment.\nThe series consists of this document and an [accompanying tutorial](/solutions/building-multi-architecture-container-images-iot-devices-tutorial) . This document explains the structure of a pipeline for building container images and outlines its high-level steps. The tutorial guides you through building an example pipeline.\nThis series is intended for IT professionals who want to simplify and streamline complex pipelines for building container images, or to extend those pipelines to build multi-architecture images. It assumes that you are familiar with cloud technologies and containers.\nWhen you implement a CI pipeline, you streamline your artifact-building procedures. You don't need to maintain dedicated tools and hardware to build container images for a given architecture. For example, if your current pipeline runs on an [x86_64 architecture](https://wikipedia.org/wiki/X86-64) and produces container images for that architecture only, you might need to maintain additional tooling and hardware if you want to build container images for other architectures, such as for the [ARM family](https://wikipedia.org/wiki/ARM_architecture) .\nThe Internet of Things (IoT) domain often requires multi-architecture builds. When you have a large fleet of devices with different hardware and OS software stacks, the process of building, testing, and managing software applications for a specific device becomes a huge challenge. Using a multi-architecture build process helps to simplify the management of IoT applications.\n", "content": "## The challenge of building multi-architecture container images\nIn most [implementations](https://wikipedia.org/wiki/OS-level_virtualization#Implementations) , container images are architecture-dependent. For example, if you build a container image for the x86_64 architecture, it cannot run on an architecture of the ARM family.\nYou can overcome this limitation in several ways:\n- Build the container images on the target architectures for which you need the container image.\n- Maintain dedicated tooling and a hardware fleet. Your fleet needs at least one device for each architecture that you need to build a container image for.\n- Build multi-architecture container images.\nWhat strategy is best for you depends on various factors, including the following:\n- Pipeline complexity\n- Automation requirements\n- Available resources to design, implement, and maintain the environment for building container images\nFor example, if your runtime environment has limited access to a power supply, you might need to build the container images in a separate environment from your runtime environment.\nThe following diagram illustrates the decision points in choosing a viable strategy.### Build the container images on the target architectures\nOne strategy is to build each container image that you need directly in the runtime environment that supports the container itself, as the following diagram shows.\nFor each build, do the following:\n- Download the source code of the container image from a source code repository on each device in the runtime environment.\n- Build the container image in the runtime environment.\n- Store the container image in the container image repository that is local to each device in the runtime environment.\nThe advantage of this strategy is that you don't need to provision and maintain hardware in addition to what you need for your runtime environments. This strategy also has disadvantages. First, you have to repeat the build process on every hardware instance in your runtime environment, thus wasting resources. For example, if you deploy your containerized workloads in a runtime environment where devices don't have access to a continuous power supply, you waste time and power by running build tasks on such devices every time you need to deploy a new version of a workload. Also, you need to maintain the tooling to access the source code of each container image to build container images in your runtime environment.\n### Maintain dedicated tooling and hardware fleets\nA second strategy is to maintain a hardware fleet that is dedicated only to tasks that build container images. The following diagram illustrates the architecture of this strategy.\nFor each build, you do the following:\n- Download the source code of the container image on a device in the fleet that has the required hardware architecture and the resources to build the container image.\n- Build the container image.\n- Store the container image in a centralized container image repository.\n- Download the container image on each device in the runtime environment when you need to deploy a new instance of that image.\nFor this strategy, you provision at least one instance of each hardware architecture that you need to build container images for. In a non-trivial production environment, you might have more than one instance to increase the fault tolerance of your environment and to shorten build times if you have multiple concurrent build jobs.\nThis strategy has a couple of advantages. First, you can run each build job only once and store the resulting container image in a centralized container image repository, such as [Container Registry](/container-registry) . Also, you can run test suites on the devices in the building fleet that closely resemble the hardware architectures that you have in your runtime environments. The main disadvantage of this strategy is that you have to provision and maintain a dedicated infrastructure and tooling to run the tasks that build container images. Usually, each building task doesn't consume many resources or time by design, so this infrastructure sits idle most of the time.\n### Build multi-architecture container images\nIn this third strategy, you use a general-purpose pipeline to build multi-architecture container images, as the following diagram shows.\nFor each build, you do the following:\n- Download the source code of the container image.\n- Build the container image.\n- Store the container image in a centralized container image repository.\n- Download the container image on each device in the runtime environment when you need to deploy a new instance of that image.\nThe main advantage of this strategy is that you don't have to provision and maintain dedicated hardware or tooling. For example, you can use your existing continuous integration/continuous deployment (CI/CD) pipelines and tooling to build multi-architecture container images. You might also benefit from the better performance of a general-purpose hardware architecture, such as x86_64, compared to an energy-efficient one, such as one in the ARM family.\nThis strategy might also be part of a broader initiative where you adopt [DevOps](/devops) principles. For example, you can implement a CI/CD pipeline for specialized hardware.\n## Implementing a pipeline for building multi-architecture container images\nIn this section, we describe a reference implementation of a CI/CD pipeline that follows the third strategy\u2014building multi-architecture container images.\nThe reference implementation has the following components:\n- A source code repository to manage the source code for container images. For example, you might use [Cloud Source Repositories](/source-repositories) or [GitLab repositories](https://docs.gitlab.com/ee/user/project/repository/) .\n- A CI/CD runtime environment to build container images, such as [Cloud Build](/build) .\n- A platform to manage containers and container images that supports multi-architecture container images, such as [Docker](https://www.docker.com/) .\n- A container image registry such as [Container Registry](/container-registry) . If you want to store your container images closer to the nodes where the images are needed, you might run a container image registry, such as [Docker Registry](https://docs.docker.com/registry/) , directly in your current environment.\nThis reference architecture uses [Moby BuildKit](https://github.com/moby/buildkit) and [QEMU](https://wikipedia.org/wiki/QEMU) to build [multi-architecture Docker container images](https://docs.docker.com/buildx/working-with-buildx/#build-multi-platform-images) . In this case, Moby BuildKit automatically detects the architectures that are available through QEMU hardware emulation and automatically loads the appropriate binaries that are registered in the [binfmt_misc](https://wikipedia.org/wiki/Binfmt_misc) capability of the [Linux kernel](https://wikipedia.org/wiki/Linux_kernel) .\nThe following diagram illustrates the technical stack that is responsible for each multi-architecture container image build that is supported by this reference architecture.\nBecause this reference architecture uses [Docker image manifests](https://docs.docker.com/registry/spec/manifest-v2-2/) , you don't need to provide a container image tag for each target hardware architecture; you can use the same tag for multiple architectures. For example, if you build the `1.0.0` version of a multi-architecture container image, you don't need a unique tag for each hardware architecture, such as `1.0.0-x86_64` , or `1.0.0_ARMv7` . You use the same `1.0.0` tag for all the hardware architectures that you build for, and use Docker image manifests to correctly identify each container image.\nThe following example shows the image manifest for the [official Alpine Linux image](https://hub.docker.com/_/alpine) , where you find information about the architectures that a particular version of that container image supports:\n```\n{\n \"schemaVersion\": 2,\n \"mediaType\": \"application/vnd.docker.distribution.manifest.list.v2+json\",\n \"manifests\": [  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 528,\n   \"digest\": \"sha256:ddba4d27a7ffc3f86dd6c2f92041af252a1f23a8e742c90e6e1297bfa1bc0c45\",\n   \"platform\": {\n   \"architecture\": \"amd64\",\n   \"os\": \"linux\"\n   }\n  },\n  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 528,\n   \"digest\": \"sha256:401f030aa35e86bafd31c6cc292b01659cbde72d77e8c24737bd63283837f02c\",\n   \"platform\": {\n   \"architecture\": \"arm\",\n   \"os\": \"linux\",\n   \"variant\": \"v7\"\n   }\n  },\n  {\n   \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\n   \"size\": 528,\n   \"digest\": \"sha256:2c26a655f6e38294e859edac46230210bbed3591d6ff57060b8671cda09756d4\",\n   \"platform\": {\n   \"architecture\": \"arm64\",\n   \"os\": \"linux\"\n   }\n  }\n ]\n}\n```\nWhen you design an automated pipeline for building container images, we recommend that you include comprehensive test suites that validate compliance to the requirements of each container image. For example, you might use tools such as [Chef InSpec](https://docs.chef.io/inspec) , [Serverspec](https://serverspec.org/) , and [RSpec](https://rspec.info/) to execute compliance test suites against your container images as one of the tasks of the build pipeline.\n## Optimizing the pipeline for building container images\nAfter you validate and consolidate the pipelines for building your container images, you optimize the pipelines. [Migration to Google Cloud: Optimizing your environment](/solutions/migration-to-google-cloud-optimizing-your-environment) contains guidance about optimizing your environment. It describes an optimization framework that you can adopt to make your environment more efficient compared to its current state. By following the optimization framework, you go through several iterations where you modify the state of your environment.\nOne of the first activities of each optimization iteration is to establish a set of requirements and goals for that iteration. For example, one requirement might be to modernize your deployment processes, migrating from manual deployment processes to fully automated, containerized ones. For more information about modernizing your deployment processes, see [Migration to Google Cloud: Migrating from manual deployments to automated, containerized deployments](/solutions/migration-to-google-cloud-automated-containerized-deployments) .\n## What's next\n- Try the accompanying tutorial, [Building multi-architecture container images for IoT devices](/solutions/building-multi-architecture-container-images-iot-devices-tutorial) .\n- Read our resources about [DevOps](/devops) .\n- Read about [Kubernetes and the challenges of continuous software delivery](/solutions/addressing-continuous-delivery-challenges-in-a-kubernetes-world) .\n- Explore reference architectures, diagrams, and best practices about Google Cloud. Take a look at our [Cloud Architecture Center](/architecture) .", "guide": "Docs"}