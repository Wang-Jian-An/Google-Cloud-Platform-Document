{"title": "Cloud Architecture Center - Deploy a secured serverless architecture using Cloud Run", "url": "https://cloud.google.com/architecture/reference-patterns/overview", "abstract": "# Cloud Architecture Center - Deploy a secured serverless architecture using Cloud Run\nLast reviewed 2023-03-10 UTC\nServerless architectures let you develop software and services without provisioning or maintaining servers. You can use serverless architectures to build applications for a wide range of services.\nThis document provides opinionated guidance for DevOps engineers, security architects, and application developers on how to help protect serverless applications that use [Cloud Run](/run/docs/overview/what-is-cloud-run) . The document is part of a security blueprint that consists of the following:\n- A [GitHub repository](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run) that contains a set of Terraform configurations and scripts.\n- A guide to the architecture, design, and security controls that you implement with the blueprint (this document).\nThough you can deploy this blueprint without deploying the [Google Cloud enterprise foundations blueprint](/architecture/security-foundations) first, this document assumes that you've already configured a foundational set of security controls as described in the Google Cloud enterprise foundations blueprint. The architecture that's described in this document helps you to layer additional controls onto your foundation to help protect your serverless applications.\nTo help define key security controls that are related to serverless applications, the [Cloud Security Alliance (CSA)](https://cloudsecurityalliance.org/) published [Top 12 Critical Risks for Serverless Applications](https://cloudsecurityalliance.org/blog/2019/02/11/critical-risks-serverless-applications/) . The security controls used in this blueprint are designed to address the risks that are relevant to the various use cases described in this document.\n", "content": "## Serverless use cases\nThe blueprint supports the following use cases:\n- Deploying a serverless architecture using Cloud Run (this document)\n- [Deploying a serverless architecture using Cloud Functions](/architecture/serverless-functions-blueprint) \nDifferences between Cloud Functions and Cloud Run include the following:\n- Cloud Functions is triggered by events, such as changes to data in a database or the receipt of a message from a messaging system such as Pub/Sub. Cloud Run is triggered by requests, such as HTTP requests.\n- Cloud Functions is limited to a [set of supported runtimes](/functions/docs/concepts/execution-environment#runtimes) . You can use Cloud Run with any programming language.\n- Cloud Functions manages containers and the infrastructure that controls the web server or language runtime so that you can focus on your code. Cloud Run provides the flexibility for you to run these services yourself, so that you have control of the container configuration.\nFor more information about differences between Cloud Run and Cloud Functions, see [Choosing a Google Cloud compute option](/blog/topics/developers-practitioners/where-should-i-run-my-stuff-choosing-google-cloud-compute-option) .\n## Architecture\nThis blueprint lets you run serverless applications on Cloud Run with Shared VPC. We recommend that you use Shared VPC because it centralizes network policy and control for all networking resources. In addition, Shared VPC is deployed in the [enterprise foundations blueprint](/architecture/security-foundations/networking) .\n### Recommended architecture: Cloud Run with a Shared VPC network\nThe following image shows how you can run your serverless applications in a Shared VPC network.\nThe architecture that's shown in the preceding diagram uses a combination of the following Google Cloud services and features:\n- An [external Application Load Balancer](/load-balancing/docs/https) receives the data that serverless applications require from the internet and forwards it to Cloud Run. The external Application Load Balancer is a Layer\u00a07 load balancer.\n- [Google Cloud Armor](/armor/docs/cloud-armor-overview) acts as the web application firewall to help protect your serverless applications against denial of service (DoS) and web attacks.\n- [Cloud Run](/run/docs/overview/what-is-cloud-run) lets you run application code in containers and manages the infrastructure on your behalf. In this blueprint, the [Internal and Cloud Load Balancing ingress setting](/run/docs/securing/ingress) restricts access to Cloud Run so that Cloud Run will accept requests only from the external Application Load Balancer.\n- The Serverless VPC Access connector connects your serverless application to your VPC network using [Serverless VPC Access](/vpc/docs/serverless-vpc-access) . Serverless VPC Access helps to ensure that requests from your serverless application to the VPC network aren't exposed to the internet. Serverless VPC Access lets Cloud Run communicate with other services, storage systems, and resources that [support VPC Service Controls](/vpc-service-controls/docs/supported-products) .By default, you create the Serverless VPC Access connector in the service project. You can create the Serverless VPC Access connector in the host project by specifying `true` for the `connector_on_host_project` input variable when you run the [Secure Cloud Run Network](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run/tree/main/modules/secure-serverless-net) module. For more information, see [Comparison of configuration methods](/run/docs/configuring/connecting-shared-vpc#comparison_of_configuration_methods) .\n- [Virtual Private Cloud (VPC) firewall rules](/vpc/docs/firewalls) control the flow of data into the subnet that hosts your resources, such as a company server hosted on Compute Engine, or company data stored in Cloud Storage.\n- [VPC Service Controls](/vpc-service-controls) creates a security perimeter that isolates your Cloud Run services and resources by setting up authorization, access controls, and [secure data exchange](/vpc-service-controls/docs/secure-data-exchange) . This perimeter is designed to protect incoming content, to isolate your application by setting up additional access controls and monitoring, and to separate your governance of Google Cloud from the application. Your governance includes key management and logging.\n- [Shared VPC](/vpc/docs/shared-vpc) lets you connect the Serverless VPC Access connector in your service project to the host project.\n- [Cloud Key Management Service (Cloud KMS)](/kms) stores the [customer-managed encryption keys (CMEKs)](/kms/docs/cmek) that are used by the services in this blueprint, including your serverless application, Artifact Registry, and Cloud Run.\n- [Identity and Access Management (IAM)](/iam) and [Resource Manager](/resource-manager) help to restrict access and isolate resources. The access controls and resource hierarchy follow the principle of least privilege.\n### Alternative architecture: Cloud Run without a Shared VPC network\nIf you're not using a Shared VPC network, you can deploy Cloud Run and your serverless application in a VPC Service Control perimeter without a Shared VPC network. You might implement this alternative architecture if you're using a [hub-and-spoke topology](/architecture/security-foundations/networking#hub-spoke-network-topology) .\nThe following image shows how you can run your serverless applications without Shared VPC.\nThe architecture that's shown in the preceding diagram uses a combination of Google Cloud services and features that's similar to those that are described in the previous section, [Recommended architecture: Cloud Run with a shared VPC](#recommended-architecture-cloud-run-with-a-shared-vpc-network) .\n## Organization structure\nYou group your resources so that you can manage them and separate your development and testing environments from your production environment. Resource Manager lets you logically group resources by project, folder, and organization.\nThe following diagram shows a resource hierarchy with folders that represent different environments such as bootstrap, common, production, non-production (or testing), and development. This resource hierarchy is based on the hierarchy that's described in the [enterprise foundations blueprint](/architecture/security-foundations/organization-structure) . You deploy the projects that the blueprint specifies into the following folders: `Common` , `Production` , `Non-production` , and `Dev` .\nThe following sections describe this diagram in more detail.\n### Folders\nYou use folders to isolate your production environment and governance services from your non-production and testing environments. The following table describes the folders from the enterprise foundations blueprint that are used by this blueprint.\n| Folder   | Description                                              |\n|:---------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Bootstrap  | Contains resources required to deploy the enterprise foundations blueprint.                              |\n| Common   | Contains centralized services for the organization, such as the security project.                            |\n| Production  | Contains projects that have cloud resources that have been tested and are ready to use by customers. In this blueprint, the Production folder contains the service project and host project. |\n| Non-production | Contains projects that have cloud resources that are currently being tested and staged for release. In this blueprint, the Non-production folder contains the service project and host project. |\n| Dev   | Contains projects that have cloud resources that are currently being developed. In this blueprint, the Dev folder contains the service project and host project.        |\nYou can change the names of these folders to align with your organization's folder structure, but we recommend that you maintain a similar structure. For more information, see [Organization structure](/architecture/security-foundations/organization-structure) . For other folder structures, see [Decide a resource hierarchy for your Google Cloud landing zone](/architecture/landing-zones/decide-resource-hierarchy) .\n### Projects\nYou isolate resources in your environment using [projects](/resource-manager/docs/creating-managing-projects) . The following table describes the projects that are needed within the organization. You can change the names of these projects, but we recommend that you maintain a similar project structure.\n| Project   | Description                                                                                                                                                                        |\n|:-----------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Host project  | This project includes the firewall ingress rules and any resources that have internal IP addresses (as described in Connect to a VPC network). When you use Shared VPC, you designate a project as a host project and attach one or more other service projects to it. When you apply the Terraform code, you specify the name of this project, and the blueprint deploys the services.                                                                             |\n| Service project | This project includes your serverless application, Cloud Run, and the Serverless VPC Access connector. You attach the service project to the host project so that the service project can participate in the Shared VPC network. When you apply the Terraform code, you specify the name of this project. The blueprint deploys Cloud Run, Google Cloud Armor, Serverless VPC Access connector, and the load balancer.                                                                      |\n| Security project | This project includes your security-specific services, such as Cloud KMS and Secret Manager. When you apply the Terraform code, you specify the name of this project, and the blueprint deploys Cloud KMS. If you use the Secure Cloud Run Harness module, Artifact Registry is also deployed. If you deploy this blueprint after you deploy the security foundations blueprint, this project is the secrets project created by the enterprise foundations blueprint. For more information about the enterprise foundations blueprint projects, see Projects. If you deploy multiple instances of this blueprint without the enterprise foundations blueprint, each instance has its own security project. |\n## Mapping roles and groups to projects\nYou must give different user groups in your organization access to the projects that make up the serverless architecture. The following table describes the blueprint recommendations for user groups and role assignments in the projects that you create. You can customize the groups to match your organization's existing structure, but we recommend that you maintain a similar segregation of duties and role assignment.\n| Group                   | Project   | Roles                    |\n|:--------------------------------------------------------------------------------|:-----------------|:------------------------------------------------------------------------------------|\n| Serverless administrator grp-gcp-serverless-admin@example.com     | Service project | roles/run.admin roles/compute.networkViewer compute.networkUser      |\n| Serverless security administrator grp-gcp-serverless-security-admin@example.com | Security project | roles/run.viewer roles/cloudkms.viewer roles/artifactregistry.reader    |\n| Cloud Run developer grp-gcp-secure-cloud-run-developer@example.com    | Security project | roles/run.developer roles/artifactregistry.writer roles/cloudkms.cryptoKeyEncrypter |\n| Cloud Run user grp-gcp-secure-cloud-run-user@example.com      | Service project | roles/run.invoker                 |\n## Security controls\nThis section discusses the security controls in Google Cloud that you use to help secure your serverless architecture. The key security principles to consider are as follows:\n- Secure access according to the principle of least privilege, giving entities only the privileges required to perform their tasks.\n- Secure network connections through segmentation design, organization policies, and firewall policies.\n- Secure configuration for each of the services.\n- Understand the risk levels and security requirements for the environment that hosts your serverless workloads.\n- Configure sufficient monitoring and logging to allow detection, investigation, and response.\n### Security controls for serverless applications\nYou can help to protect your serverless applications using controls that protect traffic on the network, control access, and encrypt data.\nWhen you deploy your serverless application, you use Artifact Registry to store the container images and binaries. Artifact Registry supports CMEK so that you can encrypt the repository using your own encryption keys.\nTo support HTTPS traffic to your serverless application, you configure an SSL certificate for your [external Application Load Balancer](/load-balancing/docs/https) . By default, you use a self-signed certificate that you can change to a managed certificate after you apply the Terraform code. For more information about installing and using managed certificates, see [Using Google-managed SSL certificates](/load-balancing/docs/ssl-certificates/google-managed-certs) .\n[Virtual Private Cloud (VPC) firewall rules](/vpc/docs/firewalls) control the flow of data into the perimeters. You create firewall rules that deny all egress, except for specific TCP port 443 connections from restricted.googleapis.com special domain names. Using the restricted.googleapis.com domain has the following benefits:\n- It helps reduce your network attack surface by using Private Google Access when workloads communicate with Google APIs and services.\n- It ensures that you use only services that support VPC Service Controls.\nFor more information, see [Configuring Private Google Access](/vpc/docs/configure-private-google-access) .\nAs shown in the [recommended-architecture diagram](#recommended-architecture-cloud-run-with-a-shared-vpc-network) , you place the resources for the serverless application in a separate perimeter. This perimeter helps protect the serverless application from unintended access and data exfiltration.\nTo help ensure that only specific identities (users or services) can access resources and data, you enable IAM groups and roles.\nTo help ensure that only specific resources can access your projects, you enable an [access policy](/access-context-manager/docs/overview) for your Google organization. For more information, see [Access level attributes](/access-context-manager/docs/access-level-attributes) .\nIf your environment already includes Identity and Access Proxy (IAP), you can configure the external Application Load Balancer to use IAP to authorize traffic for your serverless application. IAP lets you establish a central authorization layer for your serverless application so that you can use application-level access controls instead of relying on network-level firewalls.\nTo enable IAP for your application, in the [loadbalancer.tf](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run/blob/main/modules/secure-cloud-run-core/loadbalancer.tf) file, set `iap_config.enable` to `true` .\nFor more information about IAP, see [Identity-Aware Proxy overview](/iap/docs/concepts-overview) .\nService accounts are identities that Google Cloud can use to run API requests on your behalf. To implement separation of duties, you create service accounts that have different roles for specific purposes. The service accounts are as follows:\n- A Cloud Run service account ( `cloud_run_sa` ) that has the following roles:- `roles/run.invoker`\n- `roles/secretmanager.secretAccessor`\nFor more information, see [Allow Cloud Run to access a secret](/run/docs/configuring/secrets#access-secret) .\n- A Serverless VPC Access connector account ( `gcp_sa_vpcaccess` ) that has the `roles/compute.networkUser` role.\n- A second Serverless VPC Access connector account ( `cloud_services` ) that has the `roles/compute.networkUser` role.These service accounts for the Serverless VPC Access connector are required so that the connector can create the firewall ingress and egress rules in the host project. For more information, see [Grant permissions to service accounts in your service projects](/run/docs/configuring/shared-vpc-service-projects#grant-permissions) .\n- A service identity to run Cloud Run ( `run_identity_services` ) that has the `roles/vpcaccess.user` role.\n- A [service agent for the Google APIs](/iam/docs/service-account-types#google-managed) ( `cloud_services_sa` ) that has the `roles/editor` role. This service account lets Cloud Run communicate with the Serverless VPC Access connector.\n- A [service identity](/run/docs/securing/service-identity) for Cloud Run ( `serverless_sa` ) that has the `roles/artifactregistry.reader` role. This service account provides access to Artifact Registry and CMEK encryption and decryption keys.You use the CMEK keys to help protect your data in Artifact Registry and in Cloud Run. You use the following encryption keys:\n- A software key for Artifact Registry that attests the code for your serverless application.\n- An [encryption key](/run/docs/securing/using-cmek) to encrypt the container images that Cloud Run deploys.\nWhen you apply the Terraform configuration, you specify the [CMEK location](/kms/docs/locations) , which determines the geographical location where the keys are stored. You must ensure that your CMEK keys are in the same region as your resources. By default, CMEK keys are rotated every 30 days.\nCloud Run supports [Secret Manager](/secret-manager/docs/overview) to store the secrets that your serverless application might require. These secrets can include API keys and database usernames and passwords. To expose the secret as a mounted volume, use the `volume_mounts` and `volumes` variables in the [main module](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run/tree/3311307f2f77f2dc7a69d838f7e27f595a32d57c) .\nWhen you deploy this blueprint with the enterprise foundations blueprint, you must add your secrets to the secrets project before you apply the Terraform code. The blueprint will grant the Secret Manager Secret Accessor role to the Cloud Run service account. For more information, see [Use secrets](/run/docs/configuring/secrets#access-secret) .\nThis blueprint adds constraints to the [organization policy constraints](/resource-manager/docs/organization-policy/org-policy-constraints) . For more information about the constraints that the enterprise foundations blueprint uses, see [Organization policy constraints](/architecture/security-foundations/preventative-controls#organization-policy) .\nThe following table describes the additional organization policy constraints that are defined in the [Secure Cloud Run Security](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run/tree/main/modules/secure-cloud-run-security) module of this blueprint.\n| Policy constraint    | Description                                        | Recommended value     |\n|:---------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------|\n| constraints/run.allowedIngress | Allow ingress traffic only from internal services or the external Application Load Balancer.                    | internal-and-cloud-load-balancing |\n| constraints/run.allowedVPCEgress | Require a Cloud Run service's revisions to use a Serverless VPC Access connector, and ensure that the revisions' VPC egress settings are set to allow private ranges only. | private-ranges-only    |\n### Operational controls\nYou can enable logging and [Security Command Center Premium tier features](/security-command-center/pricing#premium-tier) such as security health analytics and threat detection. These controls help you to do the following:\n- Monitor who is accessing your data.\n- Ensure that proper auditing is in place.\n- Support the ability of your incident management and operations teams to respond to issues that might occur.To help you meet auditing requirements and get insight into your projects, you configure the [Google Cloud Observability](/products/operations) with data logs for the services that you want to track. Deploy [Cloud Logging](/logging/docs/overview) in the projects before you apply the Terraform code to ensure that the blueprint can configure logging for the firewall, load balancer, and VPC network.\nAfter you deploy the blueprint, we recommend that you configure the following:\n- [Create an aggregated log sink](/logging/docs/export/aggregated_sinks) across all projects.\n- Select the appropriate region to store your logs.\n- Add CMEK keys to your logging sink.\nFor all services within the projects, ensure that your logs include information about data reads and writes, and ensure that they include information about what administrators access. For more information about logging best practices, see [Detective controls](/architecture/security-foundations/detective-controls) .\nAfter you deploy the blueprint, you can set up alerts to notify your security operations center (SOC) that a security incident might be occurring. For example, you can use alerts to let your security analysts know when a permission has changed in an IAM role. For more information about configuring Security Command Center alerts, see [Setting up finding notifications](/security-command-center/docs/how-to-notifications) .\nThe Cloud Run Monitoring dashboard, which is part of the sample dashboard library, provides you with the following information:\n- Request count\n- Request latency\n- Billable instance time\n- Container CPU allocation\n- Container memory allocation\n- Container CPU utilization\n- Container memory utilization\nFor instructions on importing the dashboard, see [Install sample dashboards](/monitoring/dashboards/dashboard-templates) . To export alerts, see the following documents:\n- [Introduction to alerting](/monitoring/alerts) \n- [Cloud Monitoring metric export](/architecture/monitoring-metric-export) You can run [Connectivity Tests](/network-intelligence-center/docs/connectivity-tests/concepts/overview) to help you debug network configuration issues between Cloud Run and the resources within your subnet. Connectivity Tests simulates the expected path of a packet and provides details about the connectivity, including resource-to-resource connectivity analysis.\nConnectivity Tests isn't enabled by the Terraform code; you must set it up separately. For more information, see [Create and run Connectivity Tests](/architecture/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests) .\n### Detective controls\nThis section describes the detective controls that are included in the blueprint.\nYou use an external Application Load Balancer and Google Cloud Armor to provide distributed denial of service (DDoS) protection for your serverless application. Google Cloud Armor is the web application firewall (WAF) included with Google Cloud.\nYou configure the Google Cloud Armor rules described in the following table to help protect the serverless application. The rules are designed to help mitigate against [OWASP Top 10 risks](https://owasp.org/www-project-top-ten/) .\n| Google Cloud Armor rule name | ModSecurity rule name  |\n|:-------------------------------|:----------------------------|\n| Remote code execution   | rce-v33-stable    |\n| Local file include    | lfi-v33-stable    |\n| Protocol attack    | protocolattack-v33-stable |\n| Remote file inclusion   | rfi-v33-stable    |\n| Scanner detection    | scannerdetection-v33-stable |\n| Session fixation attack  | sessionfixation-v33-stable |\n| SQL injection     | sqli-v33-stable    |\n| Cross-site scripting   | xss-v33-stable    |\nWhen these rules are enabled, Google Cloud Armor automatically denies any traffic that matches the rule.\nFor more information about these rules, see [Tune Google Cloud Armor preconfigured WAF rules](/armor/docs/rule-tuning) .\nYou can detect potential security issues in Cloud Run using [Recommender](/run/docs/recommender) . Recommender can detect security issues such as the following:\n- API keys or passwords that are stored in environment variables instead of in Secret Manager.\n- Containers that include hard-coded credentials instead of using [service identities](/run/docs/securing/service-identity#per-service-identity) .\nAbout a day after you deploy Cloud Run, Recommender starts providing its findings and recommendations. Recommender displays its findings and recommended corrective actions in the [Cloud Run service list](/run/docs/managing/services) or the [Recommendation Hub](/recommender/docs/recommendation-hub/identify-configuration-problems) .\n## Terraform deployment modes\nThe following table describes the ways that you can deploy this blueprint, and which Terraform modules apply for each deployment mode.\n| Deployment mode                                                                                                             | Terraform modules                                |\n|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------|\n| Deploy this blueprint after deploying the enterprise foundations blueprint (recommended). This option deploys the resources for this blueprint in the same VPC Service Controls perimeter that is used by the enterprise foundations blueprint. For more information, see How to customize Foundation v2.3.1 for Secured Serverless deployment. This option also uses the secrets project that you created when you deployed the enterprise foundations blueprint. | Use these Terraform modules: secure-cloud-run-core secure-serverless-net secure-cloud-run-security secure-cloud-run       |\n| Install this blueprint without installing the enterprise foundations blueprint. This option requires that you create a VPC Service Controls perimeter.                                                                            | Use these Terraform modules: secure-cloud-run-core secure-serverless-harness secure-serverless-net secure-cloud-run-security secure-cloud-run |\n## Bringing it all together\nTo implement the architecture described in this document, do the following:\n- Review the [README](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run) for the blueprint and ensure that you meet all the prerequisites.\n- Create an [SSL certificate](/load-balancing/docs/ssl-certificates/google-managed-certs) for use with the [external Application Load Balancer](/load-balancing/docs/https) .If you do not complete this step, the blueprint uses a self-signed certificate to deploy the load balancer, and your browser will display warnings about insecure connections when you attempt to access your serverless application.\n- In your testing environment, deploy the [Secure Cloud Run Example](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run/tree/main/examples/secure_cloud_run) to see the blueprint in action. As part of your testing process, consider doing the following:- Use Security Command Center to scan the projects against common [compliance requirements](/security-command-center/docs/concepts-vulnerabilities-findings) .\n- Replace the sample application with a real application and run through a typical deployment scenario.\n- Work with the application engineering and operations teams in your enterprise to test their access to the projects and to verify whether they can interact with the solution in the way that they would expect.\n- Deploy the blueprint into your environment.## Compliance mappings\nTo help define key security controls that are related to serverless applications, the [Cloud Security Alliance (CSA)](https://cloudsecurityalliance.org/) published [Top 12 Critical Risks for Serverless Applications](https://cloudsecurityalliance.org/blog/2019/02/11/critical-risks-serverless-applications/) . The security controls used in this blueprint help you address most of these risks, as described in the following table.\n| Risk              | Blueprint mitigation                                                                    | Your responsibility                                             |\n|:------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| 1. Function event-data injection       | Google Cloud Armor and external Application Load Balancers help protect against OWASP Top 10, as described in OWASP Top 10 2021 mitigation options on Google Cloud                                | Secure coding practices such as exception handling, as described in the OWASP Secure Coding Practices and Supply chain Levels for Software Artifacts (SLSA)           |\n| 2. Broken authentication         | nan                                                                        | IAP and Identity Platform to authenticate users to the service                                  |\n| 3. Insecure serverless deployment configuration    | CMEK with Cloud KMS                                                                    | Management of your own encryption keys                                        |\n| 4. Over-privileged function permissions and roles   | Custom service account for service authentication (not the default Compute Engine service account) Tightly-scoped IAM roles on the Cloud Run service account VPC Service Controls to limit scope of Google Cloud API access (as provided using the Google Cloud enterprise foundations blueprint) | nan                                                 |\n| 5. Inadequate function monitoring and logging    | Cloud Logging                                                                      | Cloud Monitoring dashboards and alerting structure                                     |\n| 6. Insecure third-party dependencies      | nan                                                                        | Protect the CI/CD pipeline using code scanning and pre-deployment analysis                               |\n| 7. Insecure application secrets storage      | Secret Manager                                                                     | Secret management in application code                                         |\n| 8. Denial of service and financial resource exhaustion  | Google Cloud Armor Cloud Run service timeouts (default is 120 seconds)                                                       | nan                                                 |\n| 9. Serverless business logic manipulation     | VPC Service Controls to limit scope of Google Cloud API access (provided using enterprise foundations blueprint)                                             | nan                                                 |\n| 10. Improper exception handling and verbose error messages | nan                                                                        | Secure programming best practices                                          |\n| 11. Obsolete functions, cloud resources, and event triggers | Use revisions to minimize the attack surface. Revisions help to reduce the likelihood of accidentally enabling a previous, obsolete iteration of a service. Revisions also help you test a new revision's security posture using A/B testing along with monitoring and logging tools.    | Infrastructure as code (IaC) to manage cloud resources Cloud resources monitoring using Security Command Center Cloud Billing monitoring Cleanup of unused cloud resources to minimize attack surface |\n| 12. Cross-execution data persistency      | nan                                                                        | nan                                                 |\n## What's next\n- For a baseline secure environment, review the [Google Cloud enterprise foundations blueprint](/architecture/security-foundations) .\n- To see the details of the blueprint that's described in this document, read the [Terraform configuration README file](https://github.com/GoogleCloudPlatform/terraform-google-cloud-run) .\n- To read about security and compliance best practices, see [Google Cloud Architecture Framework: Security, privacy, and compliance](/architecture/framework/security) .\n- For more best practices and blueprints, see the [security best practices center](/security/best-practices) .", "guide": "Cloud Architecture Center"}